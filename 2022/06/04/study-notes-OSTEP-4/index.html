<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"adamska1008.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Three easy pieces: 虚拟化，并发，持久性 本段内容包括I&#x2F;O结构，磁盘结构，RAID，文件结构的实现与崩溃恢复。">
<meta property="og:type" content="article">
<meta property="og:title" content="OSTEP笔记（四）—— 持久性">
<meta property="og:url" content="https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/index.html">
<meta property="og:site_name" content="Adamska&#39;s Blog">
<meta property="og:description" content="Three easy pieces: 虚拟化，并发，持久性 本段内容包括I&#x2F;O结构，磁盘结构，RAID，文件结构的实现与崩溃恢复。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-04T07:17:31.000Z">
<meta property="article:modified_time" content="2022-06-28T02:21:40.318Z">
<meta property="article:author" content="Adamska">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/","path":"2022/06/04/study-notes-OSTEP-4/","title":"OSTEP笔记（四）—— 持久性"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>OSTEP笔记（四）—— 持久性 | Adamska's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Adamska's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text"> 持久性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.</span> <span class="nav-text"> I&#x2F;O设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 系统架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%AE%BE%E5%A4%87"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 标准设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.3.</span> <span class="nav-text"> 标准协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%B8%AD%E6%96%AD%E5%92%8Cdma"><span class="nav-number">1.1.4.</span> <span class="nav-text"> 利用中断和DMA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E4%BA%A4%E4%BA%92"><span class="nav-number">1.1.5.</span> <span class="nav-text"> 设备交互</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text"> 磁盘驱动器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 基本几何形状</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text"> 延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-number">1.2.4.</span> <span class="nav-text"> 磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sstf-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-number">1.2.4.1.</span> <span class="nav-text"> SSTF: 最短寻道时间优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E6%A2%AF-%E5%8F%88%E7%A7%B0scan-%E6%88%96-c-scan"><span class="nav-number">1.2.4.2.</span> <span class="nav-text"> 电梯 (又称SCAN 或 C-SCAN)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sptf-%E6%9C%80%E7%9F%AD%E5%AE%9A%E4%BD%8D%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-number">1.2.4.3.</span> <span class="nav-text"> SPTF: 最短定位时间优先</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%89%E4%BB%B7%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97raid"><span class="nav-number">1.3.</span> <span class="nav-text"> 廉价冗余磁盘阵列（RAID）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 故障模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0raid"><span class="nav-number">1.3.2.</span> <span class="nav-text"> 如何评估RAID</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#raid-0-%E6%9D%A1%E5%B8%A6%E5%8C%96"><span class="nav-number">1.3.2.1.</span> <span class="nav-text"> RAID 0： 条带化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#raid-1%E9%95%9C%E5%83%8F"><span class="nav-number">1.3.2.2.</span> <span class="nav-text"> RAID 1：镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#raid-4-%E9%80%9A%E8%BF%87%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4"><span class="nav-number">1.3.2.3.</span> <span class="nav-text"> RAID 4: 通过奇偶校验节省空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#raid-5-%E6%97%8B%E8%BD%AC%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="nav-number">1.3.2.4.</span> <span class="nav-text"> RAID 5: 旋转奇偶校验</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text"> 文件系统的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%BB%84%E7%BB%87"><span class="nav-number">1.4.1.</span> <span class="nav-text"> 整体组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inode"><span class="nav-number">1.4.2.</span> <span class="nav-text"> inode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87"><span class="nav-number">1.4.3.</span> <span class="nav-text"> 目录组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.4.</span> <span class="nav-text"> 空闲空间管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5"><span class="nav-number">1.4.5.</span> <span class="nav-text"> 访问路径：读取和写入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E7%A3%81%E7%9B%98%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">1.4.5.1.</span> <span class="nav-text"> 从磁盘读文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98"><span class="nav-number">1.4.5.2.</span> <span class="nav-text"> 写入磁盘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E7%BC%93%E5%86%B2"><span class="nav-number">1.4.6.</span> <span class="nav-text"> 缓存和缓冲</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B4%A9%E6%BA%83%E4%B8%80%E8%87%B4%E6%80%A7fsck%E5%92%8C%E6%97%A5%E5%BF%97"><span class="nav-number">1.5.</span> <span class="nav-text"> 崩溃一致性：FSCK和日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%9F%A5%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 解决方案1：文件系统检查程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%E6%97%A5%E5%BF%97%E6%88%96%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 解决方案2：日志（或预写日志）</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adamska</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OSTEP笔记（四）—— 持久性
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-04 15:17:31" itemprop="dateCreated datePublished" datetime="2022-06-04T15:17:31+08:00">2022-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-28 10:21:40" itemprop="dateModified" datetime="2022-06-28T10:21:40+08:00">2022-06-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OSTEP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">OSTEP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><em>Three easy pieces: 虚拟化，并发，持久性</em></p>
<p>本段内容包括I/O结构，磁盘结构，RAID，文件结构的实现与崩溃恢复。</p>
<span id="more"></span>
<h1 id="持久性"><a class="markdownIt-Anchor" href="#持久性"></a> 持久性</h1>
<h2 id="io设备"><a class="markdownIt-Anchor" href="#io设备"></a> I/O设备</h2>
<h3 id="系统架构"><a class="markdownIt-Anchor" href="#系统架构"></a> 系统架构</h3>
<p>CPU通过内存总线（memory bus）连接到系统内存，图像或其他高性能I/O设备通过I/O总线（I/O bus）连接到系统。外围总线如SCSI、SATA、USB连接低速设备。</p>
<h3 id="标准设备"><a class="markdownIt-Anchor" href="#标准设备"></a> 标准设备</h3>
<p>一个标准的设备大致由两部分组成。</p>
<p>第一部分是向系统展示的<strong>硬件接口（interface）</strong> 和典型的交互协议。</p>
<p>第二部分是<strong>内部结构（internal structure）</strong> ，设备通常使用芯片实现它们的功能。</p>
<h3 id="标准协议"><a class="markdownIt-Anchor" href="#标准协议"></a> 标准协议</h3>
<p>一个简化的设备接口包含三个寄存器：</p>
<ul>
<li>状态（status）寄存器，可以读取并查看设备的状态</li>
<li>命令（command）寄存器，通知设备执行某个具体任务</li>
<li>数据（data）寄存器，将数据传给设备或从设备接收数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (status == BUSY)</span><br><span class="line">    ; <span class="comment">// wait until device is ready</span></span><br><span class="line"><span class="comment">// Write data to DATA register</span></span><br><span class="line"><span class="comment">// Write Command to COMMAND register</span></span><br><span class="line"><span class="comment">//      (Doing so starts the device and executes the command)</span></span><br><span class="line"><span class="keyword">while</span> (status == BUSY)</span><br><span class="line">    ; <span class="comment">// wait until device is ready</span></span><br></pre></td></tr></table></figure>
<p>交互包含四步：</p>
<ol>
<li><strong>轮询（polling）</strong> 设备</li>
<li>操作系统下发数据到数据寄存器</li>
<li>操作系统将命令写入命令寄存器</li>
<li>再次轮询，等待并判断设备是否完成指令</li>
</ol>
<h3 id="利用中断和dma"><a class="markdownIt-Anchor" href="#利用中断和dma"></a> 利用中断和DMA</h3>
<p>使用中断，CPU不需要轮询设备，而是向设备发送请求并睡眠。当设备完成了操作，会抛出硬件中断（interrupt），引发CPU执行操作系统中的<strong>中断服务例程（Interrupt Service Routine, ISR）</strong> 。</p>
<p>如果使用编程中的I/O将数据传送给设备，会浪费CPU的算力。</p>
<p>使用<strong>DMA（Direct Memory Access）</strong> 引擎——系统中的一个特殊设备，可以协调完成内存和设备间的数据传递，不需要CPU介入。</p>
<p>使用DMA时，操作系统告诉DMA引擎数据在内存中的位置，要拷贝的大小和目的设备，之后处理其他请求。而当DMA完成任务后，DMA控制器会抛出中断。</p>
<h3 id="设备交互"><a class="markdownIt-Anchor" href="#设备交互"></a> 设备交互</h3>
<p>有两种方法：</p>
<ol>
<li>使用明确的I/O指令</li>
<li><strong>内存映射I/O（memory-mapped I/O）</strong> ，将设备寄存器作为内存地址提供。</li>
</ol>
<p><strong>设备驱动程序</strong><br />
在操作系统最底层，有一部分软件知道设备如何工作，其称为<strong>设备驱动程序（device driver）</strong> 。</p>
<h2 id="磁盘驱动器"><a class="markdownIt-Anchor" href="#磁盘驱动器"></a> 磁盘驱动器</h2>
<p>磁盘驱动器是计算机系统中持久数据存储的主要形式。</p>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p>驱动器由大量扇区（每个扇区512字节）组成，每个扇区都可以读取或写入。在具有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个扇区的磁盘上，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 编号，这就是驱动器的<strong>地址空间（address space）</strong> 。</p>
<h3 id="基本几何形状"><a class="markdownIt-Anchor" href="#基本几何形状"></a> 基本几何形状</h3>
<p><strong>盘片（platter）</strong> 是一个圆形坚硬的表面，通过引入磁性变化来永久存储数据。所有盘片都围绕<strong>主轴（spindle）</strong> 。</p>
<h3 id="延迟"><a class="markdownIt-Anchor" href="#延迟"></a> 延迟</h3>
<p><strong>单磁道延迟：旋转延迟</strong><br />
磁盘必须等待期望的扇区旋转到磁头下，这称为<strong>旋转延迟（rotational delay）</strong> 。如果旋转一圈的时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，那么期望旋转延迟为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">R/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 。</p>
<p><strong>多磁道：寻道时间</strong><br />
多磁道涉及<strong>寻道（seek）过程</strong>，驱动器必须首先将磁盘臂移动到正确的磁道。</p>
<p>I/O最后发生<strong>传输（transfer）</strong>，完整的I/O过程为：首先寻道，然后等待旋转延迟，最后传输。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub><mo>=</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">寻</mi><mi mathvariant="normal">道</mi></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">旋</mi><mi mathvariant="normal">转</mi></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">传</mi><mi mathvariant="normal">输</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{I/O}=T_{寻道}+T_{旋转}+T_{传输}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">寻</span><span class="mord cjk_fallback mtight">道</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">旋</span><span class="mord cjk_fallback mtight">转</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">输</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>I/O速率（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{I/O}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>）则为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi mathvariant="normal">大</mi><msub><mi mathvariant="normal">小</mi><mrow><mi mathvariant="normal">传</mi><mi mathvariant="normal">输</mi></mrow></msub></mrow><msub><mi>T</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">R_{I/O}=\cfrac{大小_{传输}}{T_{I/O}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.6311999999999998em;vertical-align:-1.0412em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">大</span><span class="mord"><span class="mord cjk_fallback">小</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">输</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0412em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<p>显然，由于更多的寻道和旋转时间，随机工作负载的时间远超于顺序工作负载。</p>
<p>假设一个磁盘平均寻道时间4ms，RPM为15000，最大传输速度125MB/S。</p>
<p>寻道时间以4ms计算，而对于旋转延迟则用RPM（圈每分钟）计算，15000RPM意味着，旋转一圈所花时间为60/15000=4ms，而旋转延迟取最大（转一圈）的二分之一，也就是2ms。在随机工作中，假设读取4KB的小数据，则传输时间只有4KB/125MB ≈ 0.000032ms = 32us 。</p>
<h3 id="磁盘调度"><a class="markdownIt-Anchor" href="#磁盘调度"></a> 磁盘调度</h3>
<p>对于磁盘调度，我们可以猜测到任务的大致时间，所以我们会尝试使用SJF（最短任务优先）。</p>
<h4 id="sstf-最短寻道时间优先"><a class="markdownIt-Anchor" href="#sstf-最短寻道时间优先"></a> SSTF: 最短寻道时间优先</h4>
<p>SSTF（Shortest-Seek-Time-First）按磁道对I/O请求队列排序，选择在最近磁道上的请求先完成。但有一个小问题：操作系统只能看到一系列的块。故可以使用<strong>最近块优先（Nearest-Block-First, NBF）</strong> ，而不是SSTF。]</p>
<p>显然，这种算法可能造成饥饿问题，加入在某一磁道上有稳定请求，磁头可能不会移动。</p>
<h4 id="电梯-又称scan-或-c-scan"><a class="markdownIt-Anchor" href="#电梯-又称scan-或-c-scan"></a> 电梯 (又称SCAN 或 C-SCAN)</h4>
<p>SCAN以跨越磁道的顺序来服务磁盘请求。如果请求的块所属的磁道在这一次扫一遍中已经服务过了，它就不会立即处理，而是排队等待下次扫一遍。</p>
<p>这种算法很像电梯，电梯要么一直向下要么一直向上，不会根据哪层楼近来服务请求。</p>
<p>常见的C-SCAN算法，从外圈扫到内圈，再从内圈扫到外圈，如此往复。</p>
<h4 id="sptf-最短定位时间优先"><a class="markdownIt-Anchor" href="#sptf-最短定位时间优先"></a> SPTF: 最短定位时间优先</h4>
<p>SPTF(Shortest Positioning Time First, SPTF)，需要计算旋转与寻道相比的时间，并在计算完成后选择下一个请求应该如何安排，它通常在驱动器内部进行。</p>
<h2 id="廉价冗余磁盘阵列raid"><a class="markdownIt-Anchor" href="#廉价冗余磁盘阵列raid"></a> 廉价冗余磁盘阵列（RAID）</h2>
<p><strong>廉价冗余磁盘整列（Redundant Array of Inexpensive Disks）</strong> 使用多个磁盘一起构建更快、更大、更可靠的磁盘系统。</p>
<p>从外部看来，RAID看起来像是一个磁盘；在内部，RAID由多个磁盘、内存以及一个或多个处理器来管理系统。</p>
<p>RAID有三个好处：</p>
<ul>
<li>性能，并行使用磁盘大大加快I/O时间</li>
<li>容量</li>
<li>可靠性，某种情况下，RAID容许损失一个磁盘并保持运行</li>
</ul>
<p>在内部，RAID包括一个微控制器，运行固件以指导RAID的操作。它还包括DRAM这样的易失性存储器，在读取和写入时缓冲数据块。在某些情况下，还包括SRAM等。</p>
<h3 id="故障模型"><a class="markdownIt-Anchor" href="#故障模型"></a> 故障模型</h3>
<p>我们假设第一个故障模型<strong>故障-停止（fail-stop）</strong> ，在这种模式下，磁盘可以处于两种状态之一：工作状态或故障状态。工作状态一切正常，人出现故障时，永久丢失数据。</p>
<h3 id="如何评估raid"><a class="markdownIt-Anchor" href="#如何评估raid"></a> 如何评估RAID</h3>
<ul>
<li>容量（capacity）</li>
<li>可靠性（reliability）</li>
<li>性能（performance）</li>
</ul>
<p>我们考虑3个重要的RAID设计：</p>
<ul>
<li>RAID 0（条带化）</li>
<li>RAID 1（镜像）</li>
<li>RAID 4/5 （基于奇偶校验的冗余）</li>
</ul>
<h4 id="raid-0-条带化"><a class="markdownIt-Anchor" href="#raid-0-条带化"></a> RAID 0： 条带化</h4>
<p>RAID 0没有冗余，但是性能和容量优秀。例如四个磁盘阵列</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<p>基本思想：以轮转方式将磁盘阵列的块分布在磁盘上。这种方法的目的是在对数组的连续块进行请求时，从阵列中获得最大的并行性。我们将同一行中的块称为条带。例如，上面的块0、1、2和3在同一条带中。</p>
<p>上面的例子中，一个磁盘一次存储一个块，但我们可以在一个磁盘上一次存储两个块。这使得大块大小为2.</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">13</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<p>大块大小会影响阵列性能。在上例中，大块大小为8KB，条带由四个大块组成。</p>
<p><strong>评估RAID 0性能</strong><br />
分析RAID性能主要看两点：</p>
<ol>
<li>单请求延迟</li>
<li>稳态吞吐量</li>
</ol>
<p>吞吐量需要考虑两种负载：顺序和随机。顺序块一次访问例如1MB的大量数据，而随机块则多次访问4KB的小数据，且数据地址不连续。</p>
<p>不妨假设连续工作下，以S MB/s 传送数据，在随机工作下以R MB/s传送数据，显而易见，考虑到寻道时间和旋转延迟的影响，前者大部分时间用于传输数据，后者大部分时间用于寻道和旋转，所以后者的传输速率远低于前者。</p>
<p>从延迟的角度来说，对于RAID0，单块请求的延迟与单个磁盘相同。在期望情况下，获得系统全部带宽，吞吐量等于N（磁盘数量）乘以S（单个磁盘的顺序带块）。对于大量随机磁盘，同样有吞吐量N × R MB/s 。</p>
<h4 id="raid-1镜像"><a class="markdownIt-Anchor" href="#raid-1镜像"></a> RAID 1：镜像</h4>
<p>镜像系统就是，生成每个块的多个副本。</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>在这个例子中，磁盘0和1有相同的内容。2、3亦然。数据在镜像对上条带化。</p>
<p>从容量角度上来看，对于N个硬盘，镜像的有用容量为N/2。</p>
<p>从可靠性角度来看，RAID-1表现良好，可以容许任何一个磁盘的故障，最多可容许N/2个磁盘的故障。</p>
<p>从读取请求的角度来看，与单个磁盘的延迟相同。写入时，需要两次物理写入，但是并行发生，所以大致等于单次写入的时间。但是略差。</p>
<p>顺序写入时，每个逻辑写入都导致两个物理写入，所以最大带宽为(N/2*S)，即峰值带宽的一半。</p>
<p>顺序读取时，同样只有(N/2*S)，这需要考虑到，单个磁盘读取请求时，可能只响应一部分，而镜像响应另外一部分，使得带宽不能充分利用。</p>
<p>而随机读取可以获得N*R的完整带宽。随机写入为N/2*R，同样因为每个逻辑写入需要变成两个物理写入。</p>
<h4 id="raid-4-通过奇偶校验节省空间"><a class="markdownIt-Anchor" href="#raid-4-通过奇偶校验节省空间"></a> RAID 4: 通过奇偶校验节省空间</h4>
<p>奇偶校验试图使用较少的容量完成检验，但是以性能为代价。</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
<th style="text-align:center">磁盘4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">P0</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">P1</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">P2</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
<td style="text-align:center">15</td>
<td style="text-align:center">P3</td>
</tr>
</tbody>
</table>
<p>对每一条数据添加奇偶校验块，用于存储该条块的冗余信息。</p>
<p>对于给定的一组比特，如果比特中有偶数个1，则所有比特的XOR返回0；如果比特中有奇数个1，返回1。显然可以利用其进行检验和恢复，这就是校验位。</p>
<p>顺序读取时，可以提供(N-1)*S的峰值有效带块（只有奇偶校验位是用不上的）。顺序写入时，通过全条带写入，也就是一次写入一个条带的内容，顺带计算奇偶校验位，也可以达到(N-1)*S。同样，随机读取为(N-1)*S。</p>
<p>但是，随机写入比较麻烦。因为每次写入都要考虑更新校验位。总之，随机写非常糟糕，大概可以认为是1/2 R。</p>
<h4 id="raid-5-旋转奇偶校验"><a class="markdownIt-Anchor" href="#raid-5-旋转奇偶校验"></a> RAID 5: 旋转奇偶校验</h4>
<p>RAID 5和RAID 4几乎相同，只是将奇偶校验块跨驱动器旋转。</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
<th style="text-align:center">磁盘4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">P0</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">P1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">P2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">P3</td>
<td style="text-align:center">12</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">P4</td>
<td style="text-align:center">16</td>
<td style="text-align:center">17</td>
<td style="text-align:center">18</td>
<td style="text-align:center">19</td>
</tr>
</tbody>
</table>
<p>顺序读写和随机读的性能基本相同。它明显提高了随机写入性能，因为它允许跨请求进行并行处理，可以接近N/4*R 。</p>
<h2 id="文件系统的实现"><a class="markdownIt-Anchor" href="#文件系统的实现"></a> 文件系统的实现</h2>
<p>文件系统是纯软件，没有硬件支持，所有文件系统都有不同的数据结构。使用VSFS文件系统进行教学。</p>
<p>考虑文件系统时，通常需要考虑两个方面：</p>
<ul>
<li>文件系统的数据结构（data structure）</li>
<li>文件系统的访问方法（access method）</li>
</ul>
<h3 id="整体组织"><a class="markdownIt-Anchor" href="#整体组织"></a> 整体组织</h3>
<p>首先，将磁盘分成4KB大小的块。</p>
<p>磁盘分区：一系列大小为4KB的块，在大小为N个4KB块的分区中，这些块的地址为从0到N-1。</p>
<p>假设有64块4KB分区，大部分（后56个块）都留给了用户数据。但是，文件系统必须记录每个块的信息，该信息是<strong>元数据（metadata）</strong>，为了存储这些信息，需要<strong>inode</strong> 解构。</p>
<p>为了存放inode，我们还需要再磁盘上留出空间，我们称之为<strong>inode表（inode table）</strong> 。inode非常小，例如256B，inode的数量可以多于文件块。</p>
<p>我们还需要某种方法记录inode或数据块是空闲还是已分配，这种<strong>分配结构（allocation structure）</strong> 也是必须的。</p>
<p>常用的数据结构是<strong>位图（bitmap）</strong>，一种用于数据区域，<strong>数据位图（data bitmap）</strong> ，一种用于inode表，<strong>inode位图（inode bitmap）</strong>。位图是一种简单的数据结构，每一个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。</p>
<p>最后保留一块超级块（superblock），包含特定文件系统的信息，例如文件中有多少inode和数据块，inode表的开始位置，可能还包括一些幻数来标识文件类型。</p>
<h3 id="inode"><a class="markdownIt-Anchor" href="#inode"></a> inode</h3>
<p>inode是index node的缩写，用于描述保存给定文件的元数据的结构，例如其长度、权限以及组成块的位置。</p>
<p>每一个inode都由一个数字（inumber）隐式引用，称为文件的<strong>低级名称（low-level name）</strong> 。在VSFS中，给定一个inumber，可以直接计算相应节点的位置。</p>
<p>例如，要读取inode号32，文件系统会首先计算inode区域的偏移量，32 × inode的大小，加上inode表的起始位置。</p>
<p>同时，注意到磁盘由大量可寻址扇区组成，所以为了获取inode地址，计算如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blk = (inumber * <span class="keyword">sizeof</span>(<span class="keyword">inode_t</span>)) / blockSize;</span><br><span class="line">sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;</span><br></pre></td></tr></table></figure>
<p>设计inode时，需要考虑如何引用数据块的位置。一个简单方法是在inode中有一个或多个直接指针，指向属于该文件的一个磁盘块。</p>
<p><strong>多级索引</strong><br />
为了支持更大的文件，文件系统设计者可能使用间接指针，指向包含更多指针的块。因此，inode可以有一些固定数量（例如12个）的直接指针和一个间接指针。如果文件变得足够大，可能会分配一个间接块（来自磁盘的数据块区域），并设置间接指针指向它。假设一个块是4KB，磁盘地址4字节，就增加1024个指针，文件增长到(12 + 1024) × 4KB = 4144KB。</p>
<p>还有可能使用双重间接指针，如此便可使用 1024 × 1024 个4KB的块来构建文件，从而支持4GB的文件。</p>
<p>这种不平衡树可以称为指向文件块的<strong>多级索引（multi-level index）</strong> 。</p>
<h3 id="目录组织"><a class="markdownIt-Anchor" href="#目录组织"></a> 目录组织</h3>
<p>一个目录基本上只包含一个二元组<code>(条目名称, inode号)</code>的表。对于给定目录中的每一个文件或目录，目录的数据块中都有一个字符串和数字。对于每个字符串，可能还有一个长度。</p>
<p>假设目录dir（inode号是5）中有3个文件（foo、bar 和 foobar），它们的inode号分别为12、13、24，dir在磁盘上的数据可能如下所示。</p>
<table>
<thead>
<tr>
<th>inum</th>
<th>reclen</th>
<th>strlen</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>4</td>
<td>2</td>
<td>.</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>3</td>
<td>…</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>4</td>
<td>foo</td>
</tr>
<tr>
<td>13</td>
<td>4</td>
<td>4</td>
<td>bar</td>
</tr>
<tr>
<td>24</td>
<td>8</td>
<td>7</td>
<td>foobar</td>
</tr>
</tbody>
</table>
<p>在这个例子中，每个条目都有一个inode号，记录长度（名称的长度+剩余空间），字符串长度（名称的实际长度），最后是条目的名称。</p>
<p>通常，文件系统将目录视为特殊类型的文件，因此，目录有一个inode，该目录具有由inode指向的数据块（或间接块）。</p>
<p>删除一个文件会在目录中留下一段空白空间，因此使用一些方法来标记它。这种删除也是使用记录长度的一个原因：新条目可能会重复使用旧的、更大的条目，从而留有额外空间。</p>
<h3 id="空闲空间管理"><a class="markdownIt-Anchor" href="#空闲空间管理"></a> 空闲空间管理</h3>
<p><strong>空闲空间管理（free space management）</strong> 记录哪些inode和数据块是空闲的。可以使用两个位图来实现。例如，创建一个文件时，为其分配一个inode。文件系统将通过位图搜索一个空闲的内容，并将其分配给该文件。</p>
<h3 id="访问路径读取和写入"><a class="markdownIt-Anchor" href="#访问路径读取和写入"></a> 访问路径：读取和写入</h3>
<p>假设文件系统已挂在，超级块在内存中，而其他信息在磁盘上。</p>
<h4 id="从磁盘读文件"><a class="markdownIt-Anchor" href="#从磁盘读文件"></a> 从磁盘读文件</h4>
<p>当发出<code>open</code>调用时，文件系统首先需要找到文件的inode。为此，文件系统需要遍历路径名。</p>
<p>从文件系统的根开始，通过inumber号查找inode。root的inumber一般是2，要开始查找，文件系统首先读入inumber 2，挂载对应的inode，这就是第一个inode块。</p>
<p>接下来，文件系统在inode中查找指向数据块的指针，数据块包含根目录的内容，其中将有我们需要的条目。接下来递归执行上述过程，直到找到对应文件。</p>
<p>最后，将文件的inode读入内存，为此进程分配一个文件描述符，接下来可以使用系统函数在文件中读取。</p>
<h4 id="写入磁盘"><a class="markdownIt-Anchor" href="#写入磁盘"></a> 写入磁盘</h4>
<p>写入文件的大部分过程类似上文。但是，写入文件可能会涉及块的分配，并更新其他结果，例如数据位图和inode。写入文件在逻辑上会有五个I/O：读取数据位图，写入位图，再是两次读取，最后写入inode，最后一次写入块本身。</p>
<p>创建文件时，不仅要分配inode，还要再目录中分配空间。</p>
<h3 id="缓存和缓冲"><a class="markdownIt-Anchor" href="#缓存和缓冲"></a> 缓存和缓冲</h3>
<p>为了弥补读取和写入文件的巨大I/O代价。大多数文件系统积极使用DRAM缓存重要的块。现代系统常使用动态划分，将虚拟内存页面和文件系统页面集成到统一页面缓存中。</p>
<h2 id="崩溃一致性fsck和日志"><a class="markdownIt-Anchor" href="#崩溃一致性fsck和日志"></a> 崩溃一致性：FSCK和日志</h2>
<p>文件系统面临的一个挑战在于：如何在出现断电或系统崩溃时，更新持久数据结构。这是<strong>崩溃一致性问题（crash-consistency problem）</strong> 。</p>
<p>使用<strong>FSCK(文件系统检查程序，file system checker)</strong>，或<strong>日志记录（journaling，或预写日志）</strong> 解决这个问题。</p>
<p>假设为文件添加内容，首先需要更新三个结构：</p>
<ol>
<li>inode，添加指向新块的指针</li>
<li>数据块本身</li>
<li>数据位图</li>
</ol>
<p>一开始，这些更新存放在内存中。写入到磁盘上时，可能会发生崩溃，可能在三个结构中，只更新了一个或两个，这就造成了不一致性。这就是崩溃一致性问题。</p>
<h3 id="解决方案1文件系统检查程序"><a class="markdownIt-Anchor" href="#解决方案1文件系统检查程序"></a> 解决方案1：文件系统检查程序</h3>
<p>fsck是一个UNIX工具，用于查找这些不一致并修复它们。</p>
<p>以下是fsck的基本总结：</p>
<ul>
<li><strong>超级块</strong>：fsck首先检查超级块是否合理。进行健全性检查，以搜索有没有冲突的超级块。</li>
<li><strong>空闲块</strong>：接下来，fsck扫描inode、间接块等，并利用其生成正确的分配位图。因此，如果位图和inode存在不一致，则信任inode。</li>
<li><strong>inode状态</strong>：检查每个inode是否存在损坏或其他问题，如字段无效。如果存在问题，则被清除，同时更新inode位图。</li>
<li><strong>inode链接</strong>：fsck还会验证每一个已分配的inode的链接数。为了验证，fsck从根目录开始扫描整个目录树，并构建自己的链接计数。如果新计算的计数与inode中找到的计数不匹配，则必须采取纠正措施。</li>
<li><strong>重复</strong>：fsck还检查重复指针。即两个不同的inode引用同一个块的情况。</li>
<li><strong>坏块</strong>：如果指针显然指向超出其有效范围的某个指针，则该指针被认为是坏的。</li>
<li><strong>目录检查</strong>：fsck对每个目录进行检查，确保<code>.</code> <code>..</code>正常分配，目录条目中引用的每一个inode都已分配。</li>
</ul>
<h3 id="解决方案2日志或预写日志"><a class="markdownIt-Anchor" href="#解决方案2日志或预写日志"></a> 解决方案2：日志（或预写日志）</h3>
<p>基本思路：更新磁盘时，在覆写结构之前，先写注记。当正在更新时若发生崩溃，可以返回并查看注记，然后重试。因此，可以在崩溃之后准确知道要修复的内容。</p>
<p>在ext3文件系统中，将日志数据存放在超级块后。</p>
<p>以更新数据为例，在更新时，先将inode，位图和数据块写入日志，称为一个事务。当其安全地存储在磁盘上，就可以覆写文件系统中的旧结构。这两部分称之为<strong>日志写入</strong>、<strong>加检查点</strong>。</p>
<p>一个事务包含头块TxB和尾块TxE，在写入事务时，为了防止中途出现崩溃，分两步写入日志事务：尾块之前的部分和尾块本身。写入尾块称之为<strong>提交日志</strong>，这在上文两点中增加了一步。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Adamska
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/" title="OSTEP笔记（四）—— 持久性">https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/03/study-notes-CSAPP-7/" rel="prev" title="CSAPP笔记（七）—— 异常控制流">
                  <i class="fa fa-chevron-left"></i> CSAPP笔记（七）—— 异常控制流
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/06/06/study-notes-CSAPP-8/" rel="next" title="CSAPP笔记（八）—— 虚拟内存">
                  CSAPP笔记（八）—— 虚拟内存 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adamska</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.2/dist/mermaid.min.js","integrity":"sha256-UIQPVkGifpwMvDH5yGgORJ9sSTDq38zz6BGU6dNaKhM="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha256-M6KFoDq9eUpmogkDgw6+3R3ZgUPSuFXnQyr8tskSfQs=" crossorigin="anonymous">



</body>
</html>
