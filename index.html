<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"adamska1008.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Adamska&#39;s Blog">
<meta property="og:url" content="https://adamska1008.github.io/index.html">
<meta property="og:site_name" content="Adamska&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adamska">
<meta property="article:tag" content="算法竞赛, Modern C++, JVM, Kotlin, GoLang, Rust, Basic CS knowledge">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://adamska1008.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Adamska's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Adamska's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adamska</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/06/study-notes-CSAPP-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/06/study-notes-CSAPP-8/" class="post-title-link" itemprop="url">CSAPP笔记（八）—— 虚拟内存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-06 17:29:52 / 修改时间：17:30:31" itemprop="dateCreated datePublished" datetime="2022-06-06T17:29:52+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/04/study-notes-OSTEP-4/" class="post-title-link" itemprop="url">OSTEP笔记（四）—— 持久性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-04 15:17:31" itemprop="dateCreated datePublished" datetime="2022-06-04T15:17:31+08:00">2022-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-15 13:08:33" itemprop="dateModified" datetime="2022-06-15T13:08:33+08:00">2022-06-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OSTEP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">OSTEP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>Three easy pieces: 虚拟化，并发，持久性</em></p>
<h1 id="持久性"><a class="markdownIt-Anchor" href="#持久性"></a> 持久性</h1>
<h2 id="io设备"><a class="markdownIt-Anchor" href="#io设备"></a> I/O设备</h2>
<h3 id="系统架构"><a class="markdownIt-Anchor" href="#系统架构"></a> 系统架构</h3>
<p>CPU通过内存总线（memory bus）连接到系统内存，图像或其他高性能I/O设备通过I/O总线（I/O bus）连接到系统。外围总线如SCSI、SATA、USB连接低速设备。</p>
<h3 id="标准设备"><a class="markdownIt-Anchor" href="#标准设备"></a> 标准设备</h3>
<p>一个标准的设备大致由两部分组成。</p>
<p>第一部分是向系统展示的<strong>硬件接口（interface）</strong> 和典型的交互协议。</p>
<p>第二部分是<strong>内部结构（internal structure）</strong> ，设备通常使用芯片实现它们的功能。</p>
<h3 id="标准协议"><a class="markdownIt-Anchor" href="#标准协议"></a> 标准协议</h3>
<p>一个简化的设备接口包含三个寄存器：</p>
<ul>
<li>状态（status）寄存器，可以读取并查看设备的状态</li>
<li>命令（command）寄存器，通知设备执行某个具体任务</li>
<li>数据（data）寄存器，将数据传给设备或从设备接收数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (status == BUSY)</span><br><span class="line">    ; <span class="comment">// wait until device is ready</span></span><br><span class="line"><span class="comment">// Write data to DATA register</span></span><br><span class="line"><span class="comment">// Write Command to COMMAND register</span></span><br><span class="line"><span class="comment">//      (Doing so starts the device and executes the command)</span></span><br><span class="line"><span class="keyword">while</span> (status == BUSY)</span><br><span class="line">    ; <span class="comment">// wait until device is ready</span></span><br></pre></td></tr></table></figure>
<p>交互包含四步：</p>
<ol>
<li><strong>轮询（polling）</strong> 设备</li>
<li>操作系统下发数据到数据寄存器</li>
<li>操作系统将命令写入命令寄存器</li>
<li>再次轮询，等待并判断设备是否完成指令</li>
</ol>
<h3 id="利用中断和dma"><a class="markdownIt-Anchor" href="#利用中断和dma"></a> 利用中断和DMA</h3>
<p>使用中断，CPU不需要轮询设备，而是向设备发送请求并睡眠。当设备完成了操作，会抛出硬件中断（interrupt），引发CPU执行操作系统中的<strong>中断服务例程（Interrupt Service Routine, ISR）</strong> 。</p>
<p>如果使用编程中的I/O将数据传送给设备，会浪费CPU的算力。</p>
<p>使用<strong>DMA（Direct Memory Access）</strong> 引擎——系统中的一个特殊设备，可以协调完成内存和设备间的数据传递，不需要CPU介入。</p>
<p>使用DMA时，操作系统告诉DMA引擎数据在内存中的位置，要拷贝的大小和目的设备，之后处理其他请求。而当DMA完成任务后，DMA控制器会抛出中断。</p>
<h3 id="设备交互"><a class="markdownIt-Anchor" href="#设备交互"></a> 设备交互</h3>
<p>有两种方法：</p>
<ol>
<li>使用明确的I/O指令</li>
<li><strong>内存映射I/O（memory-mapped I/O）</strong> ，将设备寄存器作为内存地址提供。</li>
</ol>
<p><strong>设备驱动程序</strong><br />
在操作系统最底层，有一部分软件知道设备如何工作，其称为<strong>设备驱动程序（device driver）</strong> 。</p>
<h2 id="磁盘驱动器"><a class="markdownIt-Anchor" href="#磁盘驱动器"></a> 磁盘驱动器</h2>
<p>磁盘驱动器是计算机系统中持久数据存储的主要形式。</p>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p>驱动器由大量扇区（每个扇区512字节）组成，每个扇区都可以读取或写入。在具有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个扇区的磁盘上，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 编号，这就是驱动器的<strong>地址空间（address space）</strong> 。</p>
<h3 id="基本几何形状"><a class="markdownIt-Anchor" href="#基本几何形状"></a> 基本几何形状</h3>
<p><strong>盘片（platter）</strong> 是一个圆形坚硬的表面，通过引入磁性变化来永久存储数据。所有盘片都围绕<strong>主轴（spindle）</strong> 。</p>
<h3 id="延迟"><a class="markdownIt-Anchor" href="#延迟"></a> 延迟</h3>
<p><strong>单磁道延迟：旋转延迟</strong><br />
磁盘必须等待期望的扇区旋转到磁头下，这称为<strong>旋转延迟（rotational delay）</strong> 。如果旋转一圈的时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，那么期望旋转延迟为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">R/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 。</p>
<p><strong>多磁道：寻道时间</strong><br />
多磁道涉及<strong>寻道（seek）过程</strong>，驱动器必须首先将磁盘臂移动到正确的磁道。</p>
<p>I/O最后发生<strong>传输（transfer）</strong>，完整的I/O过程为：首先寻道，然后等待旋转延迟，最后传输。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub><mo>=</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">寻</mi><mi mathvariant="normal">道</mi></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">旋</mi><mi mathvariant="normal">转</mi></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mi mathvariant="normal">传</mi><mi mathvariant="normal">输</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{I/O}=T_{寻道}+T_{旋转}+T_{传输}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">寻</span><span class="mord cjk_fallback mtight">道</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">旋</span><span class="mord cjk_fallback mtight">转</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">输</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>I/O速率（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{I/O}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>）则为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi mathvariant="normal">大</mi><msub><mi mathvariant="normal">小</mi><mrow><mi mathvariant="normal">传</mi><mi mathvariant="normal">输</mi></mrow></msub></mrow><msub><mi>T</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">R_{I/O}=\cfrac{大小_{传输}}{T_{I/O}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.6311999999999998em;vertical-align:-1.0412em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">大</span><span class="mord"><span class="mord cjk_fallback">小</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">输</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0412em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<p>显然，由于更多的寻道和旋转时间，随机工作负载的时间远超于顺序工作负载。</p>
<p>假设一个磁盘平均寻道时间4ms，RPM为15000，最大传输速度125MB/S。</p>
<p>寻道时间以4ms计算，而对于旋转延迟则用RPM（圈每分钟）计算，15000RPM意味着，旋转一圈所花时间为60/15000=4ms，而旋转延迟取最大（转一圈）的二分之一，也就是2ms。在随机工作中，假设读取4KB的小数据，则传输时间只有4KB/125MB ≈ 0.000032ms = 32us 。</p>
<h3 id="磁盘调度"><a class="markdownIt-Anchor" href="#磁盘调度"></a> 磁盘调度</h3>
<p>对于磁盘调度，我们可以猜测到任务的大致时间，所以我们会尝试使用SJF（最短任务优先）。</p>
<h4 id="sstf-最短寻道时间优先"><a class="markdownIt-Anchor" href="#sstf-最短寻道时间优先"></a> SSTF: 最短寻道时间优先</h4>
<p>SSTF（Shortest-Seek-Time-First）按磁道对I/O请求队列排序，选择在最近磁道上的请求先完成。但有一个小问题：操作系统只能看到一系列的块。故可以使用<strong>最近块优先（Nearest-Block-First, NBF）</strong> ，而不是SSTF。]</p>
<p>显然，这种算法可能造成饥饿问题，加入在某一磁道上有稳定请求，磁头可能不会移动。</p>
<h4 id="电梯-又称scan-或-c-scan"><a class="markdownIt-Anchor" href="#电梯-又称scan-或-c-scan"></a> 电梯 (又称SCAN 或 C-SCAN)</h4>
<p>SCAN以跨越磁道的顺序来服务磁盘请求。如果请求的块所属的磁道在这一次扫一遍中已经服务过了，它就不会立即处理，而是排队等待下次扫一遍。</p>
<p>这种算法很像电梯，电梯要么一直向下要么一直向上，不会根据哪层楼近来服务请求。</p>
<p>常见的C-SCAN算法，从外圈扫到内圈，再从内圈扫到外圈，如此往复。</p>
<h4 id="sptf-最短定位时间优先"><a class="markdownIt-Anchor" href="#sptf-最短定位时间优先"></a> SPTF: 最短定位时间优先</h4>
<p>SPTF(Shortest Positioning Time First, SPTF)，需要计算旋转与寻道相比的时间，并在计算完成后选择下一个请求应该如何安排，它通常在驱动器内部进行。</p>
<h2 id="廉价冗余磁盘阵列raid"><a class="markdownIt-Anchor" href="#廉价冗余磁盘阵列raid"></a> 廉价冗余磁盘阵列（RAID）</h2>
<p><strong>廉价冗余磁盘整列（Redundant Array of Inexpensive Disks）</strong> 使用多个磁盘一起构建更快、更大、更可靠的磁盘系统。</p>
<p>从外部看来，RAID看起来像是一个磁盘；在内部，RAID由多个磁盘、内存以及一个或多个处理器来管理系统。</p>
<p>RAID有三个好处：</p>
<ul>
<li>性能，并行使用磁盘大大加快I/O时间</li>
<li>容量</li>
<li>可靠性，某种情况下，RAID容许损失一个磁盘并保持运行</li>
</ul>
<p>在内部，RAID包括一个微控制器，运行固件以指导RAID的操作。它还包括DRAM这样的易失性存储器，在读取和写入时缓冲数据块。在某些情况下，还包括SRAM等。</p>
<h3 id="故障模型"><a class="markdownIt-Anchor" href="#故障模型"></a> 故障模型</h3>
<p>我们假设第一个故障模型<strong>故障-停止（fail-stop）</strong> ，在这种模式下，磁盘可以处于两种状态之一：工作状态或故障状态。工作状态一切正常，人出现故障时，永久丢失数据。</p>
<h3 id="如何评估raid"><a class="markdownIt-Anchor" href="#如何评估raid"></a> 如何评估RAID</h3>
<ul>
<li>容量（capacity）</li>
<li>可靠性（reliability）</li>
<li>性能（performance）</li>
</ul>
<p>我们考虑3个重要的RAID设计：</p>
<ul>
<li>RAID 0（条带化）</li>
<li>RAID 1（镜像）</li>
<li>RAID 4/5 （基于奇偶校验的冗余）</li>
</ul>
<h4 id="raid-0-条带化"><a class="markdownIt-Anchor" href="#raid-0-条带化"></a> RAID 0： 条带化</h4>
<p>RAID 0没有冗余，但是性能和容量优秀。例如四个磁盘阵列</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<p>基本思想：以轮转方式将磁盘阵列的块分布在磁盘上。这种方法的目的是在对数组的连续块进行请求时，从阵列中获得最大的并行性。我们将同一行中的块称为条带。例如，上面的块0、1、2和3在同一条带中。</p>
<p>上面的例子中，一个磁盘一次存储一个块，但我们可以在一个磁盘上一次存储两个块。这使得大块大小为2.</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">13</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<p>大块大小会影响阵列性能。在上例中，大块大小为8KB，条带由四个大块组成。</p>
<p><strong>评估RAID 0性能</strong><br />
分析RAID性能主要看两点：</p>
<ol>
<li>单请求延迟</li>
<li>稳态吞吐量</li>
</ol>
<p>吞吐量需要考虑两种负载：顺序和随机。顺序块一次访问例如1MB的大量数据，而随机块则多次访问4KB的小数据，且数据地址不连续。</p>
<p>不妨假设连续工作下，以S MB/s 传送数据，在随机工作下以R MB/s传送数据，显而易见，考虑到寻道时间和旋转延迟的影响，前者大部分时间用于传输数据，后者大部分时间用于寻道和旋转，所以后者的传输速率远低于前者。</p>
<p>从延迟的角度来说，对于RAID0，单块请求的延迟与单个磁盘相同。在期望情况下，获得系统全部带宽，吞吐量等于N（磁盘数量）乘以S（单个磁盘的顺序带块）。对于大量随机磁盘，同样有吞吐量N × R MB/s 。</p>
<h4 id="raid-1镜像"><a class="markdownIt-Anchor" href="#raid-1镜像"></a> RAID 1：镜像</h4>
<p>镜像系统就是，生成每个块的多个副本。</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>在这个例子中，磁盘0和1有相同的内容。2、3亦然。数据在镜像对上条带化。</p>
<p>从容量角度上来看，对于N个硬盘，镜像的有用容量为N/2。</p>
<p>从可靠性角度来看，RAID-1表现良好，可以容许任何一个磁盘的故障，最多可容许N/2个磁盘的故障。</p>
<p>从读取请求的角度来看，与单个磁盘的延迟相同。写入时，需要两次物理写入，但是并行发生，所以大致等于单次写入的时间。但是略差。</p>
<p>顺序写入时，每个逻辑写入都导致两个物理写入，所以最大带宽为(N/2*S)，即峰值带宽的一半。</p>
<p>顺序读取时，同样只有(N/2*S)，这需要考虑到，单个磁盘读取请求时，可能只响应一部分，而镜像响应另外一部分，使得带宽不能充分利用。</p>
<p>而随机读取可以获得N*R的完整带宽。随机写入为N/2*R，同样因为每个逻辑写入需要变成两个物理写入。</p>
<h4 id="raid-4-通过奇偶校验节省空间"><a class="markdownIt-Anchor" href="#raid-4-通过奇偶校验节省空间"></a> RAID 4: 通过奇偶校验节省空间</h4>
<p>奇偶校验试图使用较少的容量完成检验，但是以性能为代价。</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
<th style="text-align:center">磁盘4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">P0</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">P1</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">P2</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
<td style="text-align:center">15</td>
<td style="text-align:center">P3</td>
</tr>
</tbody>
</table>
<p>对每一条数据添加奇偶校验块，用于存储该条块的冗余信息。</p>
<p>对于给定的一组比特，如果比特中有偶数个1，则所有比特的XOR返回0；如果比特中有奇数个1，返回1。显然可以利用其进行检验和恢复，这就是校验位。</p>
<p>顺序读取时，可以提供(N-1)*S的峰值有效带块（只有奇偶校验位是用不上的）。顺序写入时，通过全条带写入，也就是一次写入一个条带的内容，顺带计算奇偶校验位，也可以达到(N-1)*S。同样，随机读取为(N-1)*S。</p>
<p>但是，随机写入比较麻烦。因为每次写入都要考虑更新校验位。总之，随机写非常糟糕，大概可以认为是1/2 R。</p>
<h4 id="raid-5-旋转奇偶校验"><a class="markdownIt-Anchor" href="#raid-5-旋转奇偶校验"></a> RAID 5: 旋转奇偶校验</h4>
<p>RAID 5和RAID 4几乎相同，只是将奇偶校验块跨驱动器旋转。</p>
<table>
<thead>
<tr>
<th style="text-align:center">磁盘0</th>
<th style="text-align:center">磁盘1</th>
<th style="text-align:center">磁盘2</th>
<th style="text-align:center">磁盘3</th>
<th style="text-align:center">磁盘4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">P0</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">P1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">P2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">P3</td>
<td style="text-align:center">12</td>
<td style="text-align:center">13</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">P4</td>
<td style="text-align:center">16</td>
<td style="text-align:center">17</td>
<td style="text-align:center">18</td>
<td style="text-align:center">19</td>
</tr>
</tbody>
</table>
<p>顺序读写和随机读的性能基本相同。它明显提高了随机写入性能，因为它允许跨请求进行并行处理，可以接近N/4*R 。</p>
<h2 id="文件系统的实现"><a class="markdownIt-Anchor" href="#文件系统的实现"></a> 文件系统的实现</h2>
<p>文件系统是纯软件，没有硬件支持，所有文件系统都有不同的数据结构。使用VSFS文件系统进行教学。</p>
<p>考虑文件系统时，通常需要考虑两个方面：</p>
<ul>
<li>文件系统的数据结构（data structure）</li>
<li>文件系统的访问方法（access method）</li>
</ul>
<h3 id="整体组织"><a class="markdownIt-Anchor" href="#整体组织"></a> 整体组织</h3>
<p>首先，将磁盘分成4KB大小的块。</p>
<p>磁盘分区：一系列大小为4KB的块，在大小为N个4KB块的分区中，这些块的地址为从0到N-1。</p>
<p>假设有64块4KB分区，大部分（后56个块）都留给了用户数据。但是，文件系统必须记录每个块的信息，该信息是<strong>元数据（metadata）</strong>，为了存储这些信息，需要<strong>inode</strong> 解构。</p>
<p>为了存放inode，我们还需要再磁盘上留出空间，我们称之为<strong>inode表（inode table）</strong> 。inode非常小，例如256B，inode的数量可以多于文件块。</p>
<p>我们还需要某种方法记录inode或数据块是空闲还是已分配，这种<strong>分配结构（allocation structure）</strong> 也是必须的。</p>
<p>常用的数据结构是<strong>位图（bitmap）</strong>，一种用于数据区域，<strong>数据位图（data bitmap）</strong> ，一种用于inode表，<strong>inode位图（inode bitmap）</strong>。位图是一种简单的数据结构，每一个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。</p>
<p>最后保留一块超级块（superblock），包含特定文件系统的信息，例如文件中有多少inode和数据块，inode表的开始位置，可能还包括一些幻数来标识文件类型。</p>
<h3 id="inode"><a class="markdownIt-Anchor" href="#inode"></a> inode</h3>
<p>inode是index node的缩写，用于描述保存给定文件的元数据的结构，例如其长度、权限以及组成块的位置。</p>
<p>每一个inode都由一个数字（inumber）隐式引用，称为文件的<strong>低级名称（low-level name）</strong> 。在VSFS中，给定一个inumber，可以直接计算相应节点的位置。</p>
<p>例如，要读取inode号32，文件系统会首先计算inode区域的偏移量，32 × inode的大小，加上inode表的起始位置。</p>
<p>同时，注意到磁盘由大量可寻址扇区组成，所以为了获取inode地址，计算如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blk = (inumber * <span class="keyword">sizeof</span>(<span class="keyword">inode_t</span>)) / blockSize;</span><br><span class="line">sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;</span><br></pre></td></tr></table></figure>
<p>设计inode时，需要考虑如何引用数据块的位置。一个简单方法是在inode中有一个或多个直接指针，指向属于该文件的一个磁盘块。</p>
<p><strong>多级索引</strong><br />
为了支持更大的文件，文件系统设计者可能使用间接指针，指向包含更多指针的块。因此，inode可以有一些固定数量（例如12个）的直接指针和一个间接指针。如果文件变得足够大，可能会分配一个间接块（来自磁盘的数据块区域），并设置间接指针指向它。假设一个块是4KB，磁盘地址4字节，就增加1024个指针，文件增长到(12 + 1024) × 4KB = 4144KB。</p>
<p>还有可能使用双重间接指针，如此便可使用 1024 × 1024 个4KB的块来构建文件，从而支持4GB的文件。</p>
<p>这种不平衡树可以称为指向文件块的<strong>多级索引（multi-level index）</strong> 。</p>
<h3 id="目录组织"><a class="markdownIt-Anchor" href="#目录组织"></a> 目录组织</h3>
<p>一个目录基本上只包含一个二元组<code>(条目名称, inode号)</code>的表。对于给定目录中的每一个文件或目录，目录的数据块中都有一个字符串和数字。对于每个字符串，可能还有一个长度。</p>
<p>假设目录dir（inode号是5）中有3个文件（foo、bar 和 foobar），它们的inode号分别为12、13、24，dir在磁盘上的数据可能如下所示。</p>
<table>
<thead>
<tr>
<th>inum</th>
<th>reclen</th>
<th>strlen</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>4</td>
<td>2</td>
<td>.</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>3</td>
<td>…</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>4</td>
<td>foo</td>
</tr>
<tr>
<td>13</td>
<td>4</td>
<td>4</td>
<td>bar</td>
</tr>
<tr>
<td>24</td>
<td>8</td>
<td>7</td>
<td>foobar</td>
</tr>
</tbody>
</table>
<p>在这个例子中，每个条目都有一个inode号，记录长度（名称的长度+剩余空间），字符串长度（名称的实际长度），最后是条目的名称。</p>
<p>通常，文件系统将目录视为特殊类型的文件，因此，目录有一个inode，该目录具有由inode指向的数据块（或间接块）。</p>
<p>删除一个文件会在目录中留下一段空白空间，因此使用一些方法来标记它。这种删除也是使用记录长度的一个原因：新条目可能会重复使用旧的、更大的条目，从而留有额外空间。</p>
<h3 id="空闲空间管理"><a class="markdownIt-Anchor" href="#空闲空间管理"></a> 空闲空间管理</h3>
<p><strong>空闲空间管理（free space management）</strong> 记录哪些inode和数据块是空闲的。可以使用两个位图来实现。例如，创建一个文件时，为其分配一个inode。文件系统将通过位图搜索一个空闲的内容，并将其分配给该文件。</p>
<h3 id="访问路径读取和写入"><a class="markdownIt-Anchor" href="#访问路径读取和写入"></a> 访问路径：读取和写入</h3>
<p>假设文件系统已挂在，超级块在内存中，而其他信息在磁盘上。</p>
<h4 id="从磁盘读文件"><a class="markdownIt-Anchor" href="#从磁盘读文件"></a> 从磁盘读文件</h4>
<p>当发出<code>open</code>调用时，文件系统首先需要找到文件的inode。为此，文件系统需要遍历路径名。</p>
<p>从文件系统的根开始，通过inumber号查找inode。root的inumber一般是2，要开始查找，文件系统首先读入inumber 2，挂载对应的inode，这就是第一个inode块。</p>
<p>接下来，文件系统在inode中查找指向数据块的指针，数据块包含根目录的内容，其中将有我们需要的条目。接下来递归执行上述过程，直到找到对应文件。</p>
<p>最后，将文件的inode读入内存，为此进程分配一个文件描述符，接下来可以使用系统函数在文件中读取。</p>
<h4 id="写入磁盘"><a class="markdownIt-Anchor" href="#写入磁盘"></a> 写入磁盘</h4>
<p>写入文件的大部分过程类似上文。但是，写入文件可能会涉及块的分配，并更新其他结果，例如数据位图和inode。写入文件在逻辑上会有五个I/O：读取数据位图，写入位图，再是两次读取，最后写入inode，最后一次写入块本身。</p>
<p>创建文件时，不仅要分配inode，还要再目录中分配空间。</p>
<h3 id="缓存和缓冲"><a class="markdownIt-Anchor" href="#缓存和缓冲"></a> 缓存和缓冲</h3>
<p>为了弥补读取和写入文件的巨大I/O代价。大多数文件系统积极使用DRAM缓存重要的块。现代系统常使用动态划分，将虚拟内存页面和文件系统页面集成到统一页面缓存中。</p>
<h2 id="崩溃一致性fsck和日志"><a class="markdownIt-Anchor" href="#崩溃一致性fsck和日志"></a> 崩溃一致性：FSCK和日志</h2>
<p>文件系统面临的一个挑战在于：如何在出现断电或系统崩溃时，更新持久数据结构。这是<strong>崩溃一致性问题（crash-consistency problem）</strong> 。</p>
<p>使用<strong>FSCK(文件系统检查程序，file system checker)</strong>，或<strong>日志记录（journaling，或预写日志）</strong> 解决这个问题。</p>
<p>假设为文件添加内容，首先需要更新三个结构：</p>
<ol>
<li>inode，添加指向新块的指针</li>
<li>数据块本身</li>
<li>数据位图</li>
</ol>
<p>一开始，这些更新存放在内存中。写入到磁盘上时，可能会发生崩溃，可能在三个结构中，只更新了一个或两个，这就造成了不一致性。这就是崩溃一致性问题。</p>
<h3 id="解决方案1文件系统检查程序"><a class="markdownIt-Anchor" href="#解决方案1文件系统检查程序"></a> 解决方案1：文件系统检查程序</h3>
<p>fsck是一个UNIX工具，用于查找这些不一致并修复它们。</p>
<p>以下是fsck的基本总结：</p>
<ul>
<li><strong>超级块</strong>：fsck首先检查超级块是否合理。进行健全性检查，以搜索有没有冲突的超级块。</li>
<li><strong>空闲块</strong>：接下来，fsck扫描inode、间接块等，并利用其生成正确的分配位图。因此，如果位图和inode存在不一致，则信任inode。</li>
<li><strong>inode状态</strong>：检查每个inode是否存在损坏或其他问题，如字段无效。如果存在问题，则被清除，同时更新inode位图。</li>
<li><strong>inode链接</strong>：fsck还会验证每一个已分配的inode的链接数。为了验证，fsck从根目录开始扫描整个目录树，并构建自己的链接计数。如果新计算的计数与inode中找到的计数不匹配，则必须采取纠正措施。</li>
<li><strong>重复</strong>：fsck还检查重复指针。即两个不同的inode引用同一个块的情况。</li>
<li><strong>坏块</strong>：如果指针显然指向超出其有效范围的某个指针，则该指针被认为是坏的。</li>
<li><strong>目录检查</strong>：fsck对每个目录进行检查，确保<code>.</code> <code>..</code>正常分配，目录条目中引用的每一个inode都已分配。</li>
</ul>
<h3 id="解决方案2日志或预写日志"><a class="markdownIt-Anchor" href="#解决方案2日志或预写日志"></a> 解决方案2：日志（或预写日志）</h3>
<p>基本思路：更新磁盘时，在覆写结构之前，先写注记。当正在更新时若发生崩溃，可以返回并查看注记，然后重试。因此，可以在崩溃之后准确知道要修复的内容。</p>
<p>在ext3文件系统中，将日志数据存放在超级块后。</p>
<p>以更新数据为例，在更新时，先将inode，位图和数据块写入日志，称为一个事务。当其安全地存储在磁盘上，就可以覆写文件系统中的旧结构。这两部分称之为<strong>日志写入</strong>、<strong>加检查点</strong>。</p>
<p>一个事务包含头块TxB和尾块TxE，在写入事务时，为了防止中途出现崩溃，分两步写入日志事务：尾块之前的部分和尾块本身。写入尾块称之为<strong>提交日志</strong>，这在上文两点中增加了一步。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/03/study-notes-CSAPP-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/study-notes-CSAPP-7/" class="post-title-link" itemprop="url">CSAPP笔记（七）—— 异常控制流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 20:54:27" itemprop="dateCreated datePublished" datetime="2022-06-03T20:54:27+08:00">2022-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-06 17:17:41" itemprop="dateModified" datetime="2022-06-06T17:17:41+08:00">2022-06-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序计数器假设一个值的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_0, a_1, ··· ,a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6527810000000001em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 其中，每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是某个相应的指令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">I_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的地址，每次从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 的过渡称为<strong>控制转移（control transfer）</strong>，这样的控制转移序列叫作处理器的<strong>控制流(control flow)</strong>。</p>
<p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。现代系统通过使控制流发生突变来对这些情况作出反应。一般而言，称之为<strong>异常控制流（Exceptional Control Flow, ECF）</strong> 。</p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<p><strong>异常（exception）</strong> 就是控制流中的突变。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件（event）</strong> 。</p>
<p>任何情况下，当处理器检测到有事件发生时，它就会通过<strong>异常表（exception table）</strong> 的跳转表进行一个间接过程调用，到<strong>异常处理程序（exception handler）</strong> 处理这些异常。当异常处理完之后，可能发生以下情况：</p>
<ol>
<li>将控制返回给指令 I<sub>curr</sub>。</li>
<li>将控制返回给 I<sub>next</sub>。</li>
<li>处理程序终止被中断的程序。</li>
</ol>
<h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3>
<p>系统中可能的异常都被分配了<strong>异常号（exception number）</strong> ，一些由处理器设计，一些由操作系统设计。</p>
<p>在系统启动时，初始化一场表，对于检测的事件，通过异常表跳转到相应的处理程序。</p>
<p>异常处理与过程调用的不同：</p>
<ul>
<li>返回地址</li>
<li>压入额外状态，如EFFLAGS寄存器</li>
<li>如果控制转移到内核，则所有项目都被压到内核栈中</li>
<li>异常处理程序运行在内核模式下</li>
</ul>
<p>通过从中断返回指令，就可以返回到程序中。如果异常中断了用户程序，就返回到用户态。</p>
<h3 id="异常的类别"><a class="markdownIt-Anchor" href="#异常的类别"></a> 异常的类别</h3>
<p>分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自I/O设备的信号</td>
<td>异步</td>
<td>总是返回到下一步指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一步指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
<h4 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h4>
<p>中断是来自I/O设备信号的结果，它是异步发生的。</p>
<h4 id="陷阱"><a class="markdownIt-Anchor" href="#陷阱"></a> 陷阱</h4>
<p>陷阱是有意的异常。陷阱最重要的作用是提供系统调用。当用户程序需要请求系统调用时，执行<code>syscall</code>，导致一个陷阱。通过陷阱，用户可以使用内核模式。</p>
<h4 id="故障"><a class="markdownIt-Anchor" href="#故障"></a> 故障</h4>
<p>故障由错误引起，但是可能被故障处理程序修正。如果能修正，就将控制返回，并重新执行，否则返回到<code>abort</code>进程。例如缺页异常。</p>
<h4 id="终止"><a class="markdownIt-Anchor" href="#终止"></a> 终止</h4>
<p>例如SRAM或DRAM损坏发生的奇偶错误，无法恢复。</p>
<h2 id="故障-2"><a class="markdownIt-Anchor" href="#故障-2"></a> 故障</h2>
<p>异常允许提供<strong>进程（process）<strong>概念。系统中的每个程序都运行在某个进程的</strong>上下文（context）</strong> 中。上下文是由程序正确运行所需的状态组成的。进程提供了两个假象：</p>
<ul>
<li>一个独立的逻辑控制流</li>
<li>一个私有的地址空间</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/03/study-notes-CSAPP-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/study-notes-CSAPP-6/" class="post-title-link" itemprop="url">CSAPP笔记（六）—— 链接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 15:39:35" itemprop="dateCreated datePublished" datetime="2022-06-03T15:39:35+08:00">2022-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-14 13:24:01" itemprop="dateModified" datetime="2022-06-14T13:24:01+08:00">2022-06-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>链接（linking）</strong> 将各种代码和数据片段收集并组合为一个单一文件。这个文件可以被加载到内存并执行。链接可以执行于编译时（compile time），加载时（load time）甚至运行时（run time）。</p>
<h2 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h2>
<p><strong>静态连接器（static linker）</strong> 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件为输出。输入的可重定位目标文件由各种不同的代码和数据节（section）构成。</p>
<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li><strong>符号解析（symbol resolution）</strong>。目标文件定义和引用符号，每个符号对应一个函数、全局变量或静态变量。符号解析将每个符号引用和符号定义关联起来。</li>
<li><strong>重定位（relocation）</strong>。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，而重定位这些节，然后修改符号引用，使得它们指向这个内存位置。</li>
</ul>
<h2 id="目标文件"><a class="markdownIt-Anchor" href="#目标文件"></a> 目标文件</h2>
<p>目标文件有三种形式</p>
<ul>
<li><strong>可重定位目标文件</strong>。</li>
<li><strong>可执行目标文件</strong>。</li>
<li><strong>共享目标文件</strong>。较为特殊，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件与共享目标文件，链接器生成可执行目标文件。一个<strong>目标模块（object module）</strong> 就是一个字节序列，而一个<strong>目标文件（object file）</strong> 就是一个以文件形式存放在磁盘中的目标模块。x86-64 Linux和Unix使用<strong>可执行可链接格式（Executable and Linkable Format, ELF）</strong> 。</p>
<h3 id="可重定位目标文件"><a class="markdownIt-Anchor" href="#可重定位目标文件"></a> 可重定位目标文件</h3>
<p><img src="https://s2.loli.net/2022/06/03/abRD7xsMc9HQzlp.png" alt="7-3.png" /></p>
<p>ELF头以一个16字节的序列开始，描述了生成该文件的操作系统的字的大小和字节顺序。剩下的部分包括ELF头的大小、目标文件的类型、机器类型、节头部表和文件偏移。夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包括：</p>
<ul>
<li><code>.text</code>：已编译程序的机器代码</li>
<li><code>.rodata</code>：只读数据，比如<code>printf</code>语句中的格式串和开关语句的跳转表</li>
<li><code>.data</code>：已初始化的全局和静态C变量。</li>
<li><code>.bss</code>：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中，这个节仅仅是一个占位符，不占据实际的空间。区分是否初始化，是为了空间效率。</li>
<li><code>.symtab</code>：一个符号表，存放程序中定义和引用的函数和全局变量的信息。</li>
<li><code>.rel.text</code>：一个<code>.text</code>节中，位置的列表。当链接器把这个目标文件和其他文件组合时，需要修改这些位置。可执行目标文件中并不需要，因此通常省略。</li>
<li><code>.rel.data</code>：被模块引用或定义的所有全局变量的重定位信息。</li>
<li><code>.debug</code>：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量以及原始的C源文件。必须使用<code>-g</code>编译才会有。</li>
<li><code>.line</code>：原始C源代码中的行号和<code>.text</code>机器指令之间的映射。必须使用<code>-g</code>编译才会有。</li>
<li><code>.strtab</code>：字符串表。</li>
</ul>
<h2 id="符号和符号表"><a class="markdownIt-Anchor" href="#符号和符号表"></a> 符号和符号表</h2>
<p>在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由模块m定义并能被其他模块引用的全局符号。</li>
<li>由其他模块定义并被模块m引用的全局符号。</li>
<li>只被模块m定义和引用的局部符号。</li>
</ul>
<p>带有<code>static</code>属性的本地过程变量不在栈中管理，而处于<code>.data</code>或<code>.bss</code>中，并在符号表中创建一个有唯一名字的本地链接器符号。</p>
<h2 id="符号解析"><a class="markdownIt-Anchor" href="#符号解析"></a> 符号解析</h2>
<p>链接器解析符号引用时，将每个引用与它输入的ELF中的符号表的一个确定的符号定义关联起来。对于引用和定义在相同模块里的局部符号的引用，比较容易。</p>
<p>但全局符号不同。当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他模块中定义的，生成一个链接器符号表条目，并交给链接器处理。如果在任何输入模块中都找不到，则报错。</p>
<h3 id="解析多重定义的全局符号"><a class="markdownIt-Anchor" href="#解析多重定义的全局符号"></a> 解析多重定义的全局符号</h3>
<p>如果多个模块定义同名的全局符号，则针对符号的强弱性质（强：函数或初始化变量；弱：未初始化变量），有下面的规则：</p>
<ul>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号</li>
<li>如果有多个弱符号同名，则任意选择。</li>
</ul>
<h3 id="与静态库链接"><a class="markdownIt-Anchor" href="#与静态库链接"></a> 与静态库链接</h3>
<p>将所有相关的目标模块打包成为一个单独的文件，称为<strong>静态库（static library）</strong> 。</p>
<p>在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小，也方便程序员包含库文件。在Linux系统中，静态库作为**存档（archive）**文件存放在磁盘中。</p>
<h3 id="静态库解析引用"><a class="markdownIt-Anchor" href="#静态库解析引用"></a> 静态库解析引用</h3>
<p>在符号解析阶段，链接器逐个解析目标文件或存档文件。</p>
<p>记一个可重定位目标文件集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，未解析符号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>，以及已定义符号集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>。在扫描过程中：</p>
<ul>
<li>对每个输入文件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，链接器判断其为目标文件还是存档文件。目标文件则添加至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，修改<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>。</li>
<li>如果是存档文件，则尝试匹配<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>中未解析符号。如果某个存档文件成员<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>定义了对应符号，则将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>并修改<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>。</li>
<li>如果最后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>非空，则报错并终止。</li>
</ul>
<p>在这种算法下，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析。</p>
<h2 id="重定位"><a class="markdownIt-Anchor" href="#重定位"></a> 重定位</h2>
<p>一旦链接器完成了符号解析，就可以开始重定位。重定位由两部分组成：</p>
<ul>
<li><em>重定位节和符号定义</em>。 链接器将所有相同类型的节合并为同一类型的新的聚合节，例如合并所有的<code>.data</code>。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节和符号。</li>
<li><em>重定位节中的符号引用</em>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。这依赖于<strong>重定位条目（relocation entry）</strong> 。</li>
</ul>
<h3 id="重定位条目"><a class="markdownIt-Anchor" href="#重定位条目"></a> 重定位条目</h3>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。当汇编器遇到位置的目标引用，就会生成重定位条目，存放在<code>.rel.text</code>和<code>.rel.data</code>中。</p>
<p>重定位条目的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;        <span class="comment">// Offset of the reference to relocate</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>,       <span class="comment">// Relocation type</span></span><br><span class="line">         symbol:<span class="number">32</span>;     <span class="comment">// Symbol table index</span></span><br><span class="line">    <span class="keyword">long</span> addend;        <span class="comment">// Constant part of relocation expression</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p><code>Offset</code>是需要被修改的节引用偏移量，<code>symbol</code>表示被修改引用应该指向的符号，<code>type</code>告知链接器如何修改新的引用，一些类型的重定位使用<code>addend</code>对被修改引用的值作偏移调整。</p>
<p>有两种最基本的重定位类型：</p>
<ul>
<li><code>R_X86_64_PC32</code>：重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距PC的当前运行值的偏移量。CPU用指令中编码的32位值加上PC的值，得到有效地址。</li>
<li><code>R_x86_64_32</code>：绝对地址。不需要修改。</li>
</ul>
<h3 id="重定位符号引用"><a class="markdownIt-Anchor" href="#重定位符号引用"></a> 重定位符号引用</h3>
<p>假设每个节为<code>s</code>，每个节相关联的重定位条目为<code>r</code>，重定位算法可以用伪代码表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">    foreach relocation entry r &#123;</span><br><span class="line">        refptr = s + r.offset; // ptr to reference to be relocated</span><br><span class="line"></span><br><span class="line">        if (r.type == R_X86_64_PC32) &#123;</span><br><span class="line">            refaddr = ADDR(s) + r.offset;</span><br><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (r.type == R_X86_64_32)</span><br><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如如下反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">    0:  48 83 ec 08             sub     $0x8, %rsp</span><br><span class="line">    4:  be 02 00 00 00          mov     $0x2, %esi</span><br><span class="line">    9:  bf 00 00 00 00          mov     $0x0, %edi          %edi = &amp;array</span><br><span class="line">                        a: R_X86_64_32 array                Relocation entry</span><br><span class="line"></span><br><span class="line">    e:  e8 00 00 00 00          callq 13&lt;main+0x13&gt;         sum()</span><br><span class="line">                        f: R_X86_64_PC32 sum-0x4            Relocation entry</span><br><span class="line">    13: 48 83 c4 08             add     $0x8, %rsp</span><br><span class="line">    17: c3                      retq</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数引用了两个全局符号：<code>array</code>和<code>sum</code>。为每个引用，汇编器产生一个重定位条目，显示在引用后面的一行上。</p>
<h4 id="重定位pc相对引用"><a class="markdownIt-Anchor" href="#重定位pc相对引用"></a> 重定位PC相对引用</h4>
<p>以<code>sum</code>为例，相对应的重定位条目<code>r</code>为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span></span><br><span class="line">r.symbol = sum</span><br><span class="line">r.type = R_x86_64_PC32</span><br><span class="line">r.addend = <span class="number">-4</span></span><br></pre></td></tr></table></figure>
<p><code>call</code>指令开始于节偏移<code>0xe</code>的地方，这些字段告诉链接器修改位于<code>0xf</code>处的32位PC相对引用。假设有<code>ADDR(s) = ADDR(.text) = 0x4004d0</code>，重定位后代码段的实际地址是<code>0x4004d0</code> 和 <code>ADDR(r.symbol) = ADDR(sum) = 0x4004e8</code>，需要调用的<code>sum</code>地址是<code>0x400e8</code></p>
<p>根据算法，首先算出引用的运行时地址，显然是<code>0x4004df</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refaddr = ADDR(s) + r.offset</span><br><span class="line">        = <span class="number">0x4004d0</span> + <span class="number">0xf</span></span><br><span class="line">        = <span class="number">0x4004df</span></span><br></pre></td></tr></table></figure>
<p>然后，更新该引用，使得它在运行时指向sum程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr = (<span class="keyword">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x4004e8</span>       + (<span class="number">-4</span>)     - <span class="number">0x4004df</span>)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x5</span>)</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4004de:     e8 05 00 00 00          callq   4004e8 &lt;sum&gt; </span><br></pre></td></tr></table></figure>
<p>执行<code>call</code>指令时，PC为<code>0x4004e3</code>，先把PC压入栈中，随后相对寻址PC = PC + 0x5，得到<code>sum</code>第一条指令的地址。</p>
<h4 id="重定位绝对引用"><a class="markdownIt-Anchor" href="#重定位绝对引用"></a> 重定位绝对引用</h4>
<p>以<code>array</code>为例，<code>mov</code>指令开始于<code>0x9</code>，对应重定位条目<code>r</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xa</span></span><br><span class="line">r.symbol = <span class="built_in">array</span></span><br><span class="line">r.type   = R_X86_64_32</span><br><span class="line">r.addend = <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p>假设有<code>ADDR(r.symbol) = ADDR(array) = 0x601018</code>，则直接修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr = (<span class="keyword">unsigned</span>)(ADDR(r.symbol) + r.addend)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x601018</span>       + <span class="number">0</span>)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x601018</span>)</span><br></pre></td></tr></table></figure>
<p>故原指令重定位为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4004</span>d9:     bf <span class="number">18</span> <span class="number">10</span> <span class="number">60</span> <span class="number">00</span>          mov     $<span class="number">0x601018</span>, %edi</span><br></pre></td></tr></table></figure>
<h2 id="可执行目标文件"><a class="markdownIt-Anchor" href="#可执行目标文件"></a> 可执行目标文件</h2>
<p><img src="https://s2.loli.net/2022/06/05/ZxtY869l7IHJaG1.png" alt="7-13.png" /></p>
<p>相较于可重定位目标文件，ELF头中包含了程序的<em>入口点（entry point）</em>，不需要<code>.rel</code>节，</p>
<p>要加载可执行目标文件，可以直接运行。通过<strong>加载器（loader）</strong> 可以运行程序。使用<code>execve</code>等函数可以调用加载器。将程序复制到内存并运行，称作加载。</p>
<p>每个程序都有运行时内存映像。</p>
<h2 id="动态共享链接库"><a class="markdownIt-Anchor" href="#动态共享链接库"></a> 动态共享链接库</h2>
<p><strong>共享库（shared library）</strong> 是一个目标模块，在运行或加载时，可以加载到任意内存地址，并和一个在内存中的程序链接。这个过程称为<strong>动态链接（dynamic linking）</strong> ，是由<strong>动态链接器（dynamic linker）</strong> 来执行的。</p>
<p><img src="https://s2.loli.net/2022/06/03/HlouNzSfXPjQdhI.png" alt="7-16.png" /></p>
<p>共享库以两种不同方式来共享。所有引用共享库的可执行目标文件共享一个动态链接库文件。在内存中，一个库的<code>.text</code>节可以被不同进程共享。动态链接器完成以下链接任务：</p>
<ul>
<li>重定位<code>.so</code>的文本和数据到某个内存段</li>
<li>重定位程序中对<code>.so</code>定义的符号引用</li>
</ul>
<p>当程序中主动调用动态链接库时，引入代码段和数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/02/study-notes-CSAPP-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/02/study-notes-CSAPP-5/" class="post-title-link" itemprop="url">CSAPP笔记（五）—— 存储器层次结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-02 19:41:56" itemprop="dateCreated datePublished" datetime="2022-06-02T19:41:56+08:00">2022-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 15:39:40" itemprop="dateModified" datetime="2022-06-03T15:39:40+08:00">2022-06-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>存储器系统（memory system）</strong> 是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的<strong>高速缓存存储器（cache memory）</strong> 作为一部分存储在相对慢速的<strong>主存储器（main memory）</strong> 中数据和指令的缓冲区域。主存缓存磁盘上的数据。</p>
<p>计算机程序有称为<strong>局部性（locality）</strong> 的属性。具有良好局部性的程序倾向于访问邻近的数据项集合。</p>
<h2 id="存储技术"><a class="markdownIt-Anchor" href="#存储技术"></a> 存储技术</h2>
<h3 id="随机访问存储器random-access-memory"><a class="markdownIt-Anchor" href="#随机访问存储器random-access-memory"></a> 随机访问存储器（Random-Access Memory）</h3>
<p>随机访问存储器分为两类：静态的（SRAM）和动态(DRAM)的。</p>
<ul>
<li>SRAM将每个位存储在一个<strong>双稳态的（bistable）</strong> 存储器单元里。这个电路可以无限期地保持在两个不同的电压配置或状态之一。其他任何状态都是不稳定的。</li>
<li>DRAM将每个位存储为对一个电容的充电。与SRAM不同，DRAM对干扰非常敏感。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">每位晶体管数</th>
<th style="text-align:center">相对访问时间</th>
<th style="text-align:center">持续的？</th>
<th style="text-align:center">敏感的？</th>
<th style="text-align:center">相对花费</th>
<th style="text-align:center">应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SRAM</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1×</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">1000×</td>
<td style="text-align:center">高速缓存存储器</td>
</tr>
<tr>
<td style="text-align:center">DRAM</td>
<td style="text-align:center">1</td>
<td style="text-align:center">10×</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">1×</td>
<td style="text-align:center">主存，帧缓冲区</td>
</tr>
</tbody>
</table>
<h4 id="传统的dram"><a class="markdownIt-Anchor" href="#传统的dram"></a> 传统的DRAM</h4>
<p>DRAM芯片中的单元（位）被分成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 个<strong>超单元（supercell）</strong> ，每个超单元都由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个DRAM单元组成。一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>×</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">d \times w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的DRAM总共存储了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">dw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位信息。超单元被组织成一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 列的长方形阵列，这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>c</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">rc=d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 。每个超单元有形如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的地址。这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 表示行，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 表示列。</p>
<p><img src="https://s2.loli.net/2022/06/03/mf1cZe6LCxIMXz5.png" alt="6-1.png" /></p>
<p>信息通过称为<strong>引脚（pin）</strong> 的外部连接器流入和流出芯片。每个引脚携带一个1位的信号。每个DRAM芯片被连接到<strong>内存控制器（memory controller）</strong> 电路。这个电路可以一次传送 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位到每个DRAM芯片或一次从每个DRAM芯片传出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位。</p>
<p>为了读出超单元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的内容，内存控制器将行地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，列地址<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>逐次发给DRAM。DRAM把超单元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的内容发回给控制器作为响应。行地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 称为<strong>RAS(Row Access Strobe，行访问选通脉冲)</strong> 请求。列地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 称为<strong>CAS（Column Access Strobe，列访问选通脉冲）</strong> 请求。二者共享相同的DRAM地址引脚。</p>
<p>DRAM在响应时，首先根据RAS将整行内容复制到内部行缓冲区，然后根据CAS选取对应的超单元，并将其发送到内存控制器。</p>
<p>通过将DRAM组织成二维阵列而不是线性数组，可以降低芯片上地址引脚的数量。</p>
<h4 id="内存模块"><a class="markdownIt-Anchor" href="#内存模块"></a> 内存模块</h4>
<p>DRAM芯片封装在<strong>内存模块（memory module）</strong> 中。</p>
<p><img src="https://s2.loli.net/2022/06/03/osT6pDy8a2lxh7d.png" alt="6-2.png" /></p>
<p>图中，用相应超单元地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的8个超单元来表示主存中字节地址A处的64位字。要取出数据，内存控制器将A转换成一个超单元地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，并将它发送到内存模块，然后内存模块再将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 广播到每个DRAM。作为响应，每个DRAM输出它对应超单元的8位内容，模块中的电路手机输出并合成64位字。</p>
<h4 id="增强的dram"><a class="markdownIt-Anchor" href="#增强的dram"></a> 增强的DRAM</h4>
<p>略</p>
<h4 id="非易失性存储器"><a class="markdownIt-Anchor" href="#非易失性存储器"></a> 非易失性存储器</h4>
<p>如果断电，DRAM和SRAM会丢失它们的信息，所以它们是 <strong>易失的（volatile）</strong> 。另一方面，非易失性存储器（nonvolatile memory）即使是在关电后，仍然保存信息。由于历史原因，被称为<strong>只读存储器（Read-Only Memory, ROM）</strong>，常见如下：</p>
<ul>
<li>PROM(Programmable ROM，可编程ROM)只能被编程一次。</li>
<li>可擦写可编程ROM(Erasable Programmable ROM)。</li>
<li>闪存(flash memory)。</li>
</ul>
<p>存储在ROM设备中的程序通常被称为固件(firmware)，如BIOS。</p>
<h4 id="访问主存"><a class="markdownIt-Anchor" href="#访问主存"></a> 访问主存</h4>
<p>数据流通过<strong>总线(bus)</strong> 的共享电子电路在处理器和DRAM主存之间来来回回。每次数据传送通过一系列步骤完成，称为<strong>总线事务（bus transaction）</strong>，包括<strong>读事务（read transaction）</strong> 和 <strong>写事务（write transaction）</strong> 。</p>
<p>总线是一组并行的导线，能携带地址、数据和控制信号。</p>
<p><img src="https://s2.loli.net/2022/06/03/S1oW9HZTmEIcMPB.png" alt="6-3.png" /></p>
<p>在如上计算机系统中，有CPU芯片、I/O桥、主存三部分。这些部件由一对总线连接起来。考虑当CPU执行指令<code>movq A, %rax</code>时，CPU芯片上的<strong>总线接口（bus interface）</strong> 发起读事务，这分为三部分：</p>
<ol>
<li>CPU将地址A放到系统总线上，I/O桥将信号传递到内存总线。</li>
<li>主存从总线读出A，从DRAM读出数据字，并写入内存总线，I/O桥将内存总线信号翻译为系统总线信号</li>
<li>CPU从总线上读数据，复制到寄存器%rax。</li>
</ol>
<h3 id="磁盘存储"><a class="markdownIt-Anchor" href="#磁盘存储"></a> 磁盘存储</h3>
<p>磁盘速度远慢于主存。</p>
<h4 id="磁盘构造"><a class="markdownIt-Anchor" href="#磁盘构造"></a> 磁盘构造</h4>
<p>磁盘由<strong>盘片（platter）</strong> 构成，每个盘片有两面（surface）。盘片中央有一个可旋转的<strong>主轴（spindle）</strong> ，使得盘片旋转，通常为5400~15000转每分钟。</p>
<p><img src="https://s2.loli.net/2022/06/03/9qGzwx4PADmOEju.png" alt="6-4.png" /></p>
<p>每个表面由一组称为<strong>磁道(track)</strong> 的同心圆组成。每个磁道被划分为一组<strong>扇区(sector)</strong>，每个扇区包含相等数量的数据为（通常是512字节）。间隙存储用来表示扇区的格式化位。</p>
<p>磁盘是由一个或多个叠放在一起的盘片组成的。整个装置通常被称为<strong>磁盘驱动器（disk driver）</strong>，简称为<strong>磁盘（disk）</strong> 。</p>
<p>术语<strong>柱面（cylinder）</strong> 是所有盘片表面上到注重中心举例相等的磁道的集合。</p>
<h4 id="磁盘容量"><a class="markdownIt-Anchor" href="#磁盘容量"></a> 磁盘容量</h4>
<p>一个磁盘上可以记录的最大位数称为它的<em>最大容量</em>，或简称为<em>容量</em>。这由许多技术因素决定。简单地说，磁盘容量可以由以下公式计算：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">盘</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">量</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">平</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">面</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">盘</mi><mi mathvariant="normal">片</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">盘</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">盘</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">磁盘容量=\cfrac{字节数}{扇区}\times \cfrac{平均扇区数}{磁道}\times \cfrac{磁道数}{表面}\times \cfrac{表面数}{盘片}\times \cfrac{盘片数}{磁盘}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">面</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">片</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">盘</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">片</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<h4 id="磁盘操作"><a class="markdownIt-Anchor" href="#磁盘操作"></a> 磁盘操作</h4>
<p>磁盘用<strong>读/写头（read/write head）</strong> 来读写存储在磁性表面上的位。读写头连接到一个传动臂一端，定位到磁盘的任何磁道上，这样的机械运动被称为<strong>寻道(seek)</strong> 。其极为精细，故为避免读写头冲撞灰尘，磁盘总是密封包装的。</p>
<p>磁盘以扇区大小的块来读写数据。对扇区的<strong>访问时间（access time）</strong> 有三个主要的部分：<strong>寻道时间（seek time）</strong>、<strong>旋转时间（rotational latency）</strong>、<strong>传送时间（transfer time）</strong> 。</p>
<ul>
<li>寻道时间：传动臂首先将读/写头定位到包含目标扇区的磁道上。移动传动臂所需要的时间称为寻道时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{seek}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。通常一次3~9ms。</li>
<li>旋转时间：一旦读/写头定位到了期望的磁道，驱动器等待目标山区的第一个位旋转到读/写头下，这个步骤时间依赖于盘面位置和旋转速度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mtext> </mtext><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mrow><mi>R</mi><mi>P</mi><mi>M</mi></mrow></mfrac></mstyle><mo>×</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mn>60</mn><mi>s</mi></mrow><mrow><mn>1</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">T_{max \ rotation}=\cfrac{1}{RPM} \times \cfrac{60s}{1min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></li>
<li>最后，驱动器开始读或写内容。传送时间依赖于旋转速度和每条磁道的扇区数目，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mrow><mi>R</mi><mi>P</mi><mi>M</mi></mrow></mfrac></mstyle><mo>×</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">平</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle><mo>×</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mn>60</mn><mi>s</mi></mrow><mrow><mn>1</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">T_{avg \ transfer}=\cfrac{1}{RPM} \times \cfrac{1}{(平均扇区数/磁道)}\times \cfrac{60s}{1min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.526em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">数</span><span class="mord">/</span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></li>
</ul>
<p>考虑如下磁盘：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">旋转速率<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>s</mi><mi>e</mi><mi>e</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{avg \ seek}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><br>每条磁道的平均扇区数</td>
<td style="text-align:left">7200RPM<br>9 ms<br>400</td>
</tr>
</tbody>
</table>
<p>对于这个磁盘</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>×</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mtext> </mtext><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mn>60</mn><mi>s</mi><mi mathvariant="normal">/</mi><mn>7200</mn><mi>R</mi><mi>P</mi><mi>M</mi><mo stretchy="false">)</mo><mo>×</mo><mn>1000</mn><mi>m</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>≈</mo><mn>4</mn><mi>m</mi><mi>s</mi><mspace linebreak="newline"></mspace><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mn>60</mn><mi mathvariant="normal">/</mi><mn>7200</mn><mi>R</mi><mi>P</mi><mi>M</mi><mo>×</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>400</mn><mo stretchy="false">(</mo><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi><mo stretchy="false">)</mo><mo>×</mo><mn>1000</mn><mi>m</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>m</mi><mi>s</mi><mo>≈</mo><mn>0.02</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T_{avg \ rotation}=1/2 \times T_{max \ rotation}=1/2 \times (60s/7200 RPM) \times 1000ms/s \approx 4ms \\
T_{avg \ transfer}=60/7200 RPM \times 1/400 (扇区/磁道) \times 1000ms/ms \approx 0.02ms
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord">7</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">/</span><span class="mord">7</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mord">/</span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<ul>
<li>访问一个扇区的主要时间是寻道时间和旋转延迟</li>
<li>因为寻道时间和旋转延迟大致相同，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的方法。</li>
<li>对存储在SRAM中的一个64位字的访问时间大约是4ms，对DRAM的访问时间是60ns。磁盘访问时间大约是10ms。</li>
</ul>
<h4 id="逻辑磁盘块"><a class="markdownIt-Anchor" href="#逻辑磁盘块"></a> 逻辑磁盘块</h4>
<p>为了对操作系统隐藏磁盘的复杂性，现代磁盘将它们的构造呈现为一个简单的视图：一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 个扇区大小的<em>逻辑块</em>的序列，编号为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><mi>B</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0, 1, ···, B-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。磁盘中封装有<em>磁盘控制器</em>，维护者逻辑块号和实际磁盘扇区之间的映射关系。</p>
<p>一个逻辑块号经由固件翻译为一个<code>(盘面, 磁道, 扇区)</code>的三元组。这个三元组唯一地标识了对应的物理扇区。控制器上的硬件会解释这个三元组。</p>
<h4 id="连接io设备"><a class="markdownIt-Anchor" href="#连接io设备"></a> 连接I/O设备</h4>
<p>例如图形卡、监视器、鼠标、键盘和磁盘的I/O设备都是通过<strong>I/O总线</strong> 连接到CPU和主存的。虽然I/O总线比系统总线和内存总线慢，但是它可以容纳大量第三方I/O设备。</p>
<p><img src="https://s2.loli.net/2022/06/03/Pmp2aGb9VIBgqMn.png" alt="6-5.png" /></p>
<h4 id="访问磁盘"><a class="markdownIt-Anchor" href="#访问磁盘"></a> 访问磁盘</h4>
<p>CPU使用一种称为<strong>内存映射I/O（memory-mapped I/O）</strong> 的技术来向I/O设备发射命令，地址空间中有一块地址是为与I/O设备通信而保留的。这样的地址称为<strong>I/O端口（I/O port）</strong> 。</p>
<p>在磁盘控制器收到来自CPU的读命令后，将逻辑块号翻译成一个扇区地址，读取内容并传送到主存，不需要CPU的干涉，这称为<strong>直接内存访问（Direct Memory Access, DMA）</strong>。这种数据传送称为<strong>DMA传送(DMA transfer)</strong> 。</p>
<h4 id="固态硬盘"><a class="markdownIt-Anchor" href="#固态硬盘"></a> 固态硬盘</h4>
<p>固态硬盘（Solid State Dist, SSD）是一种基于闪存的存储技术。</p>
<ul>
<li>闪存芯片：相对于机械驱动器</li>
<li>闪存翻译层：相对于磁盘控制器</li>
</ul>
<p>一个闪存由<strong>B个块</strong>的序列组成，每个块由<strong>P个页</strong>组成，页的大小通常是512字节 ~ 4K字节，块是由32 ~ 128页组成，块的大小为16K字节 ~ 512K字节。数据以页为单位进行读写。一个块被擦除后，才能写这个块中的页。块的寿命一般为100,000次写。</p>
<h4 id="存储技术趋势"><a class="markdownIt-Anchor" href="#存储技术趋势"></a> 存储技术趋势</h4>
<ul>
<li>不同的存储技术有不同的价格和性能折中</li>
<li>不同的存储技术的价格和性能以不同的速率变化</li>
<li>DRAM和磁盘的性能提升滞后于CPU性能的提升</li>
</ul>
<h2 id="局部性"><a class="markdownIt-Anchor" href="#局部性"></a> 局部性</h2>
<p>编写良好的程序倾向于引用邻近于其他最近引用过的数据项的数据项，或最近引用过的数据项本身。这种倾向性为称为<strong>局部性原理（principle of locality）</strong>。</p>
<p>局部性有两种不同的形式：<strong>时间局部性（temporal locality）</strong> 和 <strong>空间局部性（spatial locality）</strong> 。有良好局部性的程序运行地更快。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">        <span class="comment">// visit a[i][j];</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="comment">// visit a[i][j];</span></span><br></pre></td></tr></table></figure>
<p>前者具有更好的空间局部性。</p>
<h2 id="存储器层次结构"><a class="markdownIt-Anchor" href="#存储器层次结构"></a> 存储器层次结构</h2>
<ul>
<li>存储技术：不同存储技术的访问时间差异很大。</li>
<li>计算机软件：一个编写良好的程序倾向于展示出良好的局部性。</li>
</ul>
<p>因此使用一种称为<strong>存储器层次结构（memory hierarchy）</strong> 的方法组织存储器系统。从高层往底层走，存储设备变得更慢、更便宜和更大。</p>
<p><img src="https://s2.loli.net/2022/06/03/dqwyA8MXpYuCS3Q.png" alt="6-21.jpg" /></p>
<h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3>
<p><strong>高速缓存（cache）</strong> 是一个小而快的存储设备。使用高速缓存的过程称为<strong>缓存（caching）</strong> 。</p>
<p>存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。</p>
<p>第k+1层的存储器被划分为连续的数据对象组成块（chunk），简记为块（block）。每个块都有一个唯一的地址或名字。</p>
<p><img src="https://s2.loli.net/2022/06/03/nVkey9PcK6x2XNl.jpg" alt="6-22.jpg" /></p>
<p>数据总是以块大小位<strong>传送单元（transfer unit）</strong> 在第k层和第k+1层之间来回复制的。</p>
<h4 id="缓存命中"><a class="markdownIt-Anchor" href="#缓存命中"></a> 缓存命中</h4>
<p>当程序需要第k+1层某个数据对象d时，首先在第k层的一个块中查找d。如果d刚好缓存在第k层中，就是<strong>缓存命中（cache hit）</strong> 。该程序直接从第k层读取d。</p>
<h4 id="缓存不命中"><a class="markdownIt-Anchor" href="#缓存不命中"></a> 缓存不命中</h4>
<p>如果第k层没有缓存数据对象d，那么就是<strong>缓存不命中（cache miss）</strong> 。此时，从k+1层中取出包含d的块放在k层。如果k层已满，可能覆盖现存的一个块。</p>
<p>如果第k层的缓存是空的，那么任何访问都不命中，这称之为<strong>冷缓存（cold cache）</strong> ，此类不命中称之为<strong>强制性不命中</strong> 或<strong>冷不命中</strong> 。</p>
<p>只要发生了不命中，第k层缓存就必须执行某个<strong>放置策略（placement policy）</strong> 。对于严格的放置策略，可能限制放置的位置，有可能导致<strong>冲突不命中（conflict miss）</strong> 。</p>
<p>当工作集大小超过缓存大小时，会经历<strong>容量不命中（capacity miss）</strong>。</p>
<h2 id="高速缓存存储器"><a class="markdownIt-Anchor" href="#高速缓存存储器"></a> 高速缓存存储器</h2>
<p>由于CPU和主存之间的速度差距，系统设计这被迫在CPU寄存器和主存中插入了小的SRAM高速缓存存储器，称为<em>L1高速缓存（一级缓存）</em> 。随后也出现了L2高速缓存和L3高速缓存。</p>
<p><img src="https://s2.loli.net/2022/06/03/ZBmJsQ7zSWfuVIy.png" alt="6-24.png" /></p>
<h3 id="通用高速缓存存储器组织结构"><a class="markdownIt-Anchor" href="#通用高速缓存存储器组织结构"></a> 通用高速缓存存储器组织结构</h3>
<p>假设每个内存地址为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>位。高速缓存被组织成一个有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">S=2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span>个<strong>高速缓存组（cache set）</strong> 的数组。每个组包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>个<strong>高速缓存行（cache line）</strong> 。每行包括：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B=2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span>字节的数据块</li>
<li>一个<strong>有效位（valid bit）</strong>。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mi>m</mi><mo>−</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t=m-(b+s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>个<strong>标记位（tag bit）</strong> 。</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/03/RcBEVJ5xGwhlH2U.png" alt="6-25.png" /></p>
<p>一般而言，高速缓存的结构可以用元组<code>(S, E, B, m)</code>来描述。高速缓存的大小C指所有块大小的和，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>S</mi><mo>×</mo><mi>E</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C=S \times E \times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。</p>
<h3 id="直接映射高速缓存"><a class="markdownIt-Anchor" href="#直接映射高速缓存"></a> 直接映射高速缓存</h3>
<p>根据每个组的高速缓存行数E，高速缓存被分为不同的类。每个组只有一行（E=1）的高速缓存称为<strong>直接映射高速缓存（direct-mapped cache）</strong>。</p>
<p>当CPU执行一条读内存字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的指令，它向高速缓存L1请求这个字。如果L1高速缓存有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的一个缓存的副本，那么就得到L1高速缓存命中。高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：</p>
<ol>
<li>组选择，高速缓存从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的地址中间抽取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个组索引位，类似于数组索引。</li>
<li>行匹配，确定是否有字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的一个副本在组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>包含的一个高速缓存行中。在直接映射高速缓存中，组只有一行，故直接检查标记位是否匹配之后返回值就行了。</li>
<li>字抽取，最后一步确定所需要的字在块中是从那里开始的。块偏移位提供了这个值。</li>
</ol>
<p><img src="https://s2.loli.net/2022/06/03/CKNr8vxUG4i2wZt.png" alt="6-29.png" /></p>
<p>不命中时，用新取出的行替换当前的行。</p>
<h3 id="组相联高速缓存"><a class="markdownIt-Anchor" href="#组相联高速缓存"></a> 组相联高速缓存</h3>
<p>直接映射高速缓存由于每个组只有一行，可能造成冲突不命中。<strong>组相联高速缓存（set associative cache）</strong> 中每个组保存有多于一个的高速缓存行。一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>E</mi><mo>&lt;</mo><mi>C</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1 &lt; E &lt; C/B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的高速缓存通常称为E路组相联高速缓存。</p>
<ol>
<li>组选择，与直接映射高速缓存没有区别。</li>
<li>行匹配，需要检查多行。<em>相联存储器</em>是一个<code>(key, value)</code>对的数组，我们可以把每个组看成一个小的相联存储器，key是标记和有效位，value是块的内容。高速缓存必须搜索组中的每一行，其标记与地址中的标记相匹配。</li>
<li>字抽取，与前者相同。</li>
</ol>
<h3 id="全相联高速缓存"><a class="markdownIt-Anchor" href="#全相联高速缓存"></a> 全相联高速缓存</h3>
<p>是由一个包含所有高速缓存行的组（E=C/B）组成的。</p>
<ol>
<li>组选择，只有一个组</li>
<li>行选择，与组相联高速缓存一样，但是更大，可能需要TLB。</li>
<li>字抽取，与前者相同。</li>
</ol>
<h3 id="写操作"><a class="markdownIt-Anchor" href="#写操作"></a> 写操作</h3>
<p>如果写一个已经缓存了的字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，即<strong>写命中（write hit）</strong> 。在高速缓存更新后，同时要更新低一层次的副本。</p>
<ul>
<li><strong>直写（write-through）</strong> 立即将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的高速缓存块写回到第一层中，简单，但是每次写都会引起总线流量。</li>
<li><strong>写回（write-back）</strong> 尽可能地推迟更新。只有替换算法驱逐这个块时，才写到低层中，但是需要为每一个高速缓存行维护一个修改为（dirty bit）。</li>
</ul>
<p>写不命中时，也有两种处理方法</p>
<ul>
<li><strong>写分配（write-allowance）</strong>，加载相应低层中的块到高层中并更新，缺点是每次不命中都会导致数据传输。</li>
<li><strong>非写分配（not-write-allowance）</strong>，直接写到低层中。</li>
</ul>
<p>直写通常搭配写分配，写回通常搭配非写分配。</p>
<h3 id="高速缓存参数的性能影响"><a class="markdownIt-Anchor" href="#高速缓存参数的性能影响"></a> 高速缓存参数的性能影响</h3>
<ul>
<li><strong>不命中率（miss rate）</strong>，不命中数量/引用数量。</li>
<li><strong>命中率（hit rate）</strong>，1-不命中率。</li>
<li><strong>命中时间（hit time）</strong>，从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。</li>
<li><strong>不命中处罚（miss penalty）</strong>。由于不命中所需要的额外时间，L1不命中需要从L2得到服务，这就是不命中处罚。</li>
</ul>
<p><strong>高速缓存大小的影响</strong><br />
较大的缓存可能会提高命中率，同时可能会增加命中时间。</p>
<p><strong>块大小的影响</strong><br />
较大的块可以利用空间局部性。但块越大意味着高速缓存行数越小，会损害时间局部性。块越大，传送时间也越长。<br />
<strong>相联度的影响</strong><br />
参数E选择的影响。较高的相联度降低了冲突不命中造成抖动的可能性，但是成本高，且会增加命中时间，增加不命中处罚。最终变成命中时间和不命中处罚之间的折中。<br />
<strong>写策略的影响</strong><br />
一般而言，高速缓存越下层，越可能使用写回而不是直写。</p>
<h2 id="编写高速缓存友好的代码"><a class="markdownIt-Anchor" href="#编写高速缓存友好的代码"></a> 编写高速缓存友好的代码</h2>
<ol>
<li>让最常见的情况运行地最快。</li>
<li>减小每个循环内部的缓存不命中数量，例如：
<ul>
<li>对局部变量的反复引用是好的，因为编译器能将它们缓存在寄存器中（时间局部性）。</li>
<li>步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。</li>
</ul>
</li>
</ol>
<p>在多维数组中，空间局部性尤其重要。</p>
<h2 id="高速缓存对程序性能的影响"><a class="markdownIt-Anchor" href="#高速缓存对程序性能的影响"></a> 高速缓存对程序性能的影响</h2>
<p>一个程序从存储系统中读数据的速率称为<strong>读吞吐量（read throughput）</strong> 或<strong>读带宽（read bandwidth）</strong>。如果程序在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>秒内读<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>字节，那么读吞吐量就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">n/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/02/study-notes-CSAPP-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/02/study-notes-CSAPP-4/" class="post-title-link" itemprop="url">CSAPP笔记（四）—— 优化程序性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-02 14:27:04 / 修改时间：19:40:39" itemprop="dateCreated datePublished" datetime="2022-06-02T14:27:04+08:00">2022-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>编写高效程序需要做到三点：</p>
<ol>
<li>选择适当的算法和数据结构。</li>
<li>编写出编译器能够有效转化的代码。</li>
<li>在多核多线程处理器上并行地计算。</li>
</ol>
<h2 id="优化编译器的能力和局限性"><a class="markdownIt-Anchor" href="#优化编译器的能力和局限性"></a> 优化编译器的能力和局限性</h2>
<p>现代编译器会尽可能地化简表达式。GCC使用<code>-Ox</code>表示优化等级。但是，编译器必须小心地只进行 <em>安全的优化</em> 。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在大部分情况下，两函数等效。显然，前者读内存6次，后者读内存3次，后者效率高。但考虑到 <code>xp == yp</code> 的情况，此时前者使得值变化为4倍，后者值变化为3倍。故不能直接用后者代替前者。这体现了优化的局限性。</p>
<p>两个指针可能指向同一个内存位置的情况称为 <strong>内存别名使用（memory aliasing）</strong> 。在执行安全优化中，编译器必须假设不同的指针可能会指向内存中的同一个位置。</p>
<p>再例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1000</span>; y = <span class="number">3000</span>;</span><br><span class="line">*q = y; *p = x;</span><br><span class="line">t1 = *q;</span><br></pre></td></tr></table></figure>
<p><code>t1</code>的值依赖于<code>p</code>和<code>q</code>是否指向同一个位置。如果不是，<code>t1 = 3000</code>，否则<code>t1 = 1000</code>。</p>
<p>第二个可能妨碍优化的因素是函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> counter++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f() + f() + f() + f(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span> * f(); &#125;</span><br></pre></td></tr></table></figure>
<p>考虑到修改了<code>counter</code>的影响，<code>func1()</code>返回<code>0</code>，而<code>func2()</code>返回<code>6</code>。由于大多数编译器不会判断一个函数是否有副作用，其假设最糟糕的情况，并保持所有函数调用不变。</p>
<h2 id="表示程序性能"><a class="markdownIt-Anchor" href="#表示程序性能"></a> 表示程序性能</h2>
<p>引入度量标准 <strong>每元素的周期数（Cycles Per Element, CPE）</strong> 。</p>
<p>处理器活动的顺序由时钟控制。时钟频率通常由<em>千兆赫兹（GHz）</em>，十亿周期每秒来表示。时钟周期为频率的倒数，例如 4GHz 时钟频率的时钟周期为 0.25 纳秒。</p>
<p>以两个不同的前缀和算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compute prefix sum of vector a */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psum1</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">float</span> p[], <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psum2</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">float</span> p[], <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> mid_val = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        p[i]     = mid_val;</span><br><span class="line">        p[i + <span class="number">1</span>] = mid_val + a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For even n, finish remaining element</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个函数每次迭代两个元素（循环展开）。两个函数的处理时间与元素数量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 有关，此例中为线性关系。</p>
<p><img src="https://s2.loli.net/2022/06/02/RW31AUSs5ulQ8Fb.png" alt="5-2.png" /></p>
<p>两者运行时间近似于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>368</mn><mo>+</mo><mn>9.0</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">368 + 9.0n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">.</span><span class="mord">0</span><span class="mord mathdefault">n</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>368</mn><mo>+</mo><mn>6.0</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">368 + 6.0n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span><span class="mord mathdefault">n</span></span></span></span> 。两个等式表明对代码计时和初始化过程、准备循环以及完成过程的开销为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>368</mn></mrow><annotation encoding="application/x-tex">368</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span></span></span></span> 个周期加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6.0</mn></mrow><annotation encoding="application/x-tex">6.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9.0</mn></mrow><annotation encoding="application/x-tex">9.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 周期的线性因子。</p>
<p>这些项的系数称为每元素的周期数（CPE）的有效值。我们更愿意使用每元素的周期数而不是每循环的周期数。前者CPE为6.0，后者CPE为9.0。</p>
<h2 id="基础优化方法"><a class="markdownIt-Anchor" href="#基础优化方法"></a> 基础优化方法</h2>
<h3 id="代码移动code-motion"><a class="markdownIt-Anchor" href="#代码移动code-motion"></a> 代码移动（code motion）</h3>
<p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_func</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            compute</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记字符串长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，每次循环中调用<code>strlen(s)</code>，其本身需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，完整的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p>
<p>通过简单的代码移动，提前计算<code>len</code>就可以优化至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_func</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            compute</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="减少过程调用"><a class="markdownIt-Anchor" href="#减少过程调用"></a> 减少过程调用</h3>
<p>过程调用本身会对性能造成影响。但是区别很小。</p>
<h3 id="消除不必要的内存引用"><a class="markdownIt-Anchor" href="#消除不必要的内存引用"></a> 消除不必要的内存引用</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data_t</span> * dest;</span><br><span class="line"><span class="keyword">data_t</span> data[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* loop conditions */</span>)</span><br><span class="line">    *dest = *dest OP data[i];</span><br></pre></td></tr></table></figure>
<p>以上程序中，每一次循环内部均引用一次堆内存，其会造成性能影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data_t</span> *dest;</span><br><span class="line"><span class="keyword">data_t</span> data[N];</span><br><span class="line"><span class="keyword">data_t</span> acc = *dest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* loop conditions */</span>)</span><br><span class="line">    acc = acc OP data[i];</span><br><span class="line">*dest = acc;</span><br></pre></td></tr></table></figure>
<p>即可大量减少堆内存引用。</p>
<h2 id="理解现代处理器"><a class="markdownIt-Anchor" href="#理解现代处理器"></a> 理解现代处理器</h2>
<p>当一系列操作必须严格按顺序执行时，就会遇到 <strong>延迟界限（latency bound）</strong> ，因为在下一条指令开始之前，上一条指令必须结束。<strong>吞吐量界限（throughput bound）</strong> 刻画了处理器功能单元的原始计算能力。</p>
<h3 id="整体操作"><a class="markdownIt-Anchor" href="#整体操作"></a> 整体操作</h3>
<p>现代微处理器在工业界称为 <strong>超标量（superscalar）</strong>，意思是一个时钟周期可以执行多个指令，而且是 <strong>乱序的（out-of-order）</strong> 。</p>
<p>整个设计有两个主要部分：</p>
<ol>
<li>
<p><strong>指令控制单元（Instruction Control Unit, ICU）</strong>，负责从内存中读出指令序列，并根据其生成针对程序数据的基本操作。</p>
</li>
<li>
<p><strong>执行单元（Execution Unit, EU）</strong>，执行ISA产生的操作。</p>
</li>
</ol>
<p>乱序处理器需要更大、更复杂的硬件，但是它们能更好地到达更高的指令级并行度。</p>
<p><img src="https://s2.loli.net/2022/06/02/RyBF4HJUPuxnZKt.png" alt="5-12.png" /></p>
<p>ICU从<strong>指令高速缓存（instruction cache）</strong> 中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。</p>
<p>当程序遇到分支时，程序有两个可能的前进方向。现代处理器采用了一种<strong>分支预测（branch prediction）</strong> 技术，处理器会猜测是否选择分支，同时还猜测分支的目标地址。</p>
<p>使用<strong>投机执行（speculative execution）</strong> 技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并译码，甚至执行。如果过后确定分支预测错误，会将状态重新设置到分支点的状态。这部分被包含在<em>取指控制</em>之中。</p>
<p><em>指令译码</em>逻辑接收实际的逻辑指令，并将它们转换成一组基本操作（微操作）。对于具有复杂指令的机器，如x86，一条指令可以被译码成多个操作。例如<code>add %rax, %rax</code>只被转化成一个操作，但<code>addq %rax, 8(%rdx)</code>会把内存引用和算术运算分开。这条指令会被译码为三个操作：从内存中加载值、相加、将值存回内存。</p>
<p>EU接收来自取指单元的操作。通常，每个时钟周期会接收多个操作。这些操作会被分派到一组<em>功能单元</em>中，它们会执行实际的操作。</p>
<h3 id="处理器操作的抽象模型"><a class="markdownIt-Anchor" href="#处理器操作的抽象模型"></a> 处理器操作的抽象模型</h3>
<p><strong>数据流（data-flow）</strong> 是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了图中的<strong>关键路径（critical path）</strong> 。</p>
<p>例如</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># acc in %xmm0, data+i in %rdx, data+length in %rax</span></span><br><span class="line">.L25</span><br><span class="line">    vmulsd  (%rdx), %xmm0, %xmm0    # Multiply acc by data[i]</span><br><span class="line">    addq    $8, %rdx                <span class="comment"># Increment data+i</span></span><br><span class="line">    cmpq    %rax, %rdx              <span class="comment"># Compare to data+length</span></span><br><span class="line">    jne     .L25                    <span class="comment"># If !=, goto loop</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/06/02/GQ2FOkgUy9bj6JL.png" alt="5.13.png" /><br />
如图所示，指令译码器把这4条指令扩展成为一系列的5个操作。</p>
<p>我们可以把访问到的寄存器分为四类：</p>
<ul>
<li>只读，不会被修改</li>
<li>只写，作为数据传送的目的</li>
<li>局部，只在单次循环内部被使用</li>
<li>循环：一次迭代中产生的值会在另一次迭代中用到</li>
</ul>
<p>循环寄存器之间的操作链决定了限制性能的数据相关。进一步对数据流图进行优化，消除不直接影响数据流的操作（即cmp和jne）以及循环寄存器后有</p>
<p><img src="https://willendless.github.io/assets/images/csapp/5-17.png" alt="5.14.png" /></p>
<p><img src="https://willendless.github.io/assets/images/csapp/5-18.png" alt="5.15.png" /></p>
<p>在单精度浮点乘法条件下，由于mul操作的执行需要5个时钟周期，而数据依赖的情况下迭代n次就需要5n个时钟周期。加法操作需要1个时钟周期，因此n次迭代整体仅需要n个时钟周期。所以关键路径为mul操作的数据依赖。</p>
<h2 id="循环展开"><a class="markdownIt-Anchor" href="#循环展开"></a> 循环展开</h2>
<p>循环展开通过增加每次迭代计算的元素数量，减少循环的迭代次数。循环展开能从两个方面改善程序性能：</p>
<ol>
<li>减少了循环索引计算、条件分支等不直接有助于结果的操作数量。</li>
<li>提供了一些方法可以进一步减少关键路径上的操作数量。</li>
</ol>
<p>对一个循环按任意因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 展开，由此产生 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 循环展开。这种变换为“<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 循环展开”。这种循环展开不能将性能改进到超过延迟界限，因为关键路径不随着迭代次数的减小而改变。</p>
<h2 id="提高并行性"><a class="markdownIt-Anchor" href="#提高并行性"></a> 提高并行性</h2>
<p>我们将累积值放在一个单独的变量之中，会使得前面的计算完成前都不能计算新值。</p>
<h3 id="多个累积变量"><a class="markdownIt-Anchor" href="#多个累积变量"></a> 多个累积变量</h3>
<p>例如，分别计算奇、偶的和或积，就能获得极大的性能改进，且打破延迟界限。它既使用了两次循环展开，又使用了两路并行，我们将其称为“ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 循环展开” 。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/05/30/study-notes-CSAPP-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/30/study-notes-CSAPP-3/" class="post-title-link" itemprop="url">CSAPP笔记（三）—— 处理器体系结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-30 13:18:37" itemprop="dateCreated datePublished" datetime="2022-05-30T13:18:37+08:00">2022-05-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-02 15:27:04" itemprop="dateModified" datetime="2022-06-02T15:27:04+08:00">2022-06-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一个处理器支持的指令和指令的字节级编码称为它的 <strong>指令集体系结构（Instruction-Set Architecture, ISA）</strong>。</p>
<p>在本章中，我们通过设计Y86-64指令集体系结构来学习处理器体系结构</p>
<h2 id="y86-64指令集体系结构"><a class="markdownIt-Anchor" href="#y86-64指令集体系结构"></a> Y86-64指令集体系结构</h2>
<p>定义一个指令体系结构包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。</p>
<h3 id="程序可见的状态"><a class="markdownIt-Anchor" href="#程序可见的状态"></a> 程序可见的状态</h3>
<p>显然，程序中的每条指令都会读取或修改处理器状态的某些部分。这称为<em>程序员可见状态</em> 。这里的程序状态包括：</p>
<ul>
<li>程序寄存器（Y86-64中没有<code>%r15</code>）。</li>
<li>条件码</li>
<li>程序计数器</li>
<li>内存</li>
<li>状态码<code>Stat</code>，用于指示程序是正常运行还是出现了某种异常。</li>
</ul>
<h3 id="y86-64指令"><a class="markdownIt-Anchor" href="#y86-64指令"></a> Y86-64指令</h3>
<p>基本上，Y86-64是x86-64指令集的一个子集。它只包括8字节整数操作。</p>
<ul>
<li>数据传送指令<code>irmovq</code>、<code>rrmovq</code>、<code>mrmovq</code>和<code>rmmovq</code>。<code>i</code>为立即数、<code>r</code>为寄存器、<code>m</code>为内存。</li>
<li>整数操作<code>addq</code>、<code>subq</code>、<code>andq</code>和<code>xorq</code>。</li>
<li>跳转指令<code>jmp</code>、<code>jle</code>、<code>jl</code>、<code>je</code>、<code>jne</code>、<code>jge</code>、<code>jg</code>。</li>
<li>条件传送指令<code>cmovle</code>、<code>cmovl</code>、<code>cmove</code>、<code>cmovne</code>、<code>cmovge</code>、<code>cmovg</code>。</li>
<li><code>call</code>、<code>ret</code>。</li>
<li><code>pushq</code>、<code>popq</code>。</li>
<li><code>halt</code>，停止指令的执行。</li>
</ul>
<h3 id="指令编码"><a class="markdownIt-Anchor" href="#指令编码"></a> 指令编码</h3>
<p><img src="https://s2.loli.net/2022/06/01/JS7cn8ZLuewHyFi.png" alt="code.png" /></p>
<p>每个指令需要1~10个字节不等。每条指令第一个字节表示指令的类型。</p>
<p>15个程序寄存器都有一个相对应的范围在<code>0</code>到<code>0xE</code>的 <strong>寄存器标识符（register ID）</strong>。</p>
<p>指令可能有附加的 <strong>寄存器指示符字节（register specifier byte）</strong> ，指定一个或两个寄存器。图中表现为<code>rA</code>、<code>rB</code> 。有些指令需要一个附加的四字节<strong>常数字（const word）</strong> 作为立即数或地址偏移量。</p>
<p>指令集的一个重要性质就是字节编码必须有唯一的解释。</p>
<h3 id="y86-64异常"><a class="markdownIt-Anchor" href="#y86-64异常"></a> Y86-64异常</h3>
<p><code>Stat</code>状态码可能的情况有如下几种</p>
<table>
<thead>
<tr>
<th>值</th>
<th>名字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>AOK</code></td>
<td>正常操作</td>
</tr>
<tr>
<td>2</td>
<td><code>HLT</code></td>
<td>执行<code>halt</code>指令</td>
</tr>
<tr>
<td>3</td>
<td><code>ADR</code></td>
<td>遇到非法地址</td>
</tr>
<tr>
<td>4</td>
<td><code>INS</code></td>
<td>遇到非法指令</td>
</tr>
</tbody>
</table>
<p>对于Y86-64，当遇到异常时，就直接停止处理指令。</p>
<h3 id="y86-64程序"><a class="markdownIt-Anchor" href="#y86-64程序"></a> Y86-64程序</h3>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> *start, <span class="keyword">long</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += *start;</span><br><span class="line">        start++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>:</span><br><span class="line">    irmovq $<span class="number">8</span>, %r8      # Constant 8</span><br><span class="line">    irmovq $1, %r9      <span class="comment"># Constant 1</span></span><br><span class="line">    xorq %rax, %rax     <span class="comment"># sum = 0</span></span><br><span class="line">    andq %rsi, %rsi     <span class="comment"># Set CC</span></span><br><span class="line">    jmp test            <span class="comment"># Goto test</span></span><br><span class="line">loop:</span><br><span class="line">    mrmovq (%rdi), %r10 <span class="comment"># Get *start</span></span><br><span class="line">    addq %r10, %rax     <span class="comment"># Add to sum</span></span><br><span class="line">    addq %r8, %rdi      <span class="comment"># start++</span></span><br><span class="line">    subq %r9, %rsi      <span class="comment"># count--, Set CC</span></span><br><span class="line">test:</span><br><span class="line">    jne loop            <span class="comment"># Stop when 0</span></span><br><span class="line">    ret                 <span class="comment"># Return</span></span><br></pre></td></tr></table></figure>
<p>注意到</p>
<ul>
<li>Y86-64将常数加载到寄存器，因为其算术质指令中没有立即数</li>
<li>需要两条指令来从内存中读取一个数值，并与一个寄存器相加</li>
<li><code>subq</code>指令同时设置了条件码</li>
</ul>
<p>一个完整的程序如下，伪指令（directive）指明应该将数据或代码放在什么地方。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Execution begins at address 0</span></span><br><span class="line">        .pos <span class="number">0</span></span><br><span class="line">        irmovq stack, %rsp          # Set up stack pointer</span><br><span class="line">        call main                   # Execute main program</span><br><span class="line">        halt                        # Terminate program</span><br><span class="line">    </span><br><span class="line"># Array of 4 elements</span><br><span class="line">        .align 8</span><br><span class="line">array:</span><br><span class="line">        .quad 0x000d000d000d</span><br><span class="line">        .quad 0x00c000c000c0</span><br><span class="line">        .quad 0x0b000b000b00</span><br><span class="line">        .quad 0xa000a000a000</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        irmovq array, %rdi</span><br><span class="line">        irmovq $<span class="number">4</span>, %rsi</span><br><span class="line">        call sum                    # sum(array, 4)</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"># long sum(long *start, long count)</span><br><span class="line"># start in %rdi, count <span class="keyword">in</span> %rsi</span><br><span class="line">sum:</span><br><span class="line">        irmovq $8, %r8      <span class="comment"># Constant 8</span></span><br><span class="line">        irmovq $<span class="number">1</span>, %r9      # Constant 1</span><br><span class="line">        xorq %rax, %rax     # sum = 0</span><br><span class="line">        andq %rsi, %rsi     # Set CC</span><br><span class="line">        jmp test            # Goto test</span><br><span class="line">loop:</span><br><span class="line">        mrmovq (%rdi), %r10 # Get *start</span><br><span class="line">        addq %r10, %rax     # Add to sum</span><br><span class="line">        addq %r8, %rdi      # start++</span><br><span class="line">        subq %r9, %rsi      # count--, Set CC</span><br><span class="line">test:</span><br><span class="line">        jne loop            # Stop when 0</span><br><span class="line">        ret                 # Return</span><br><span class="line"></span><br><span class="line"># Stack starts here and grows to lower address</span><br><span class="line">        .pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>
<p>以<code>.</code>开头的词是<strong>汇编器伪指令（assembler directive）</strong> 。</p>
<h2 id="逻辑设计和硬件控制语言hcl"><a class="markdownIt-Anchor" href="#逻辑设计和硬件控制语言hcl"></a> 逻辑设计和硬件控制语言HCL</h2>
<h2 id="y86-64的顺序实现"><a class="markdownIt-Anchor" href="#y86-64的顺序实现"></a> Y86-64的顺序实现</h2>
<p>我们描述一个称为SEQq（“sequential”）的处理器。每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤。</p>
<h3 id="将处理组织成阶段"><a class="markdownIt-Anchor" href="#将处理组织成阶段"></a> 将处理组织成阶段</h3>
<ul>
<li><strong>取值（fetch）</strong>，从内存读取指令字节。地址为PC的值，从指令中抽取出指令指示符字节的两个四位部分，称为 <code>icode</code>（指令代码）和 <code>ifun</code>（指令功能）。可能取出寄存器指示符字节，指明<code>rA</code>或<code>rB</code>。它还可能取出一个四字节常数字<code>valC</code>。</li>
<li><strong>译码（decode）</strong>，从寄存器文件中读取最多两个数，得到值<code>valA</code>和/或<code>valB</code>。</li>
<li><strong>执行（execute）</strong>，算数/逻辑单元（ALU）要么执行指令指明的操作，要么增加或减少栈指针。此外，也可能设置条件码，或决定跳转指令是否选择分支。</li>
<li><strong>访存（memory）</strong>，将数据写入内存，或从内存读出数据。</li>
<li><strong>写回（write back）</strong>，写回阶段最多可以写两个结果到寄存器文件。</li>
<li><strong>更新PC（PC update）</strong>，设置PC地址。</li>
</ul>
<p>例如：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th><code>OPq rA,rB</code></th>
<th><code>rrmovq rA,rB</code></th>
<th><code>irmovq V,rB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>取指</td>
<td>icode: ifun &lt;- M<sub>1</sub>[PC]<br>rA:rB &lt;- M1[PC+1]<br><br>valP&lt;-PC+2</td>
<td>icode:ifun &lt;- M<sub>1</sub>[PC]<br>rA:rB &lt;- M<sub>1</sub>[PC+1]<br><br>valP&lt;-PC+2</td>
<td>icode:ifun&lt;-M<sub>1</sub>PC<br>rA:rB&lt;-M<sub>1</sub>[PC+1]<br>valC&lt;-M<sub>s</sub>[PC+2]<br>valP&lt;-PC+10</td>
</tr>
<tr>
<td>译码</td>
<td>valA&lt;-R[rA]<br>valB&lt;-R[rB]</td>
<td>valA&lt;-R[rA]<br>  </td>
<td></td>
</tr>
<tr>
<td>执行</td>
<td>valE&lt;-valB OP valA<br>Set CC</td>
<td>valE&lt;-0+valA<br> </td>
<td>valE&lt;-0+valC</td>
</tr>
<tr>
<td>访存</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>写回</td>
<td>R[rB]&lt;-valE</td>
<td>R[rB]&lt;-valE</td>
<td>R[rB]&lt;-valE</td>
</tr>
<tr>
<td>更新PC</td>
<td>PC&lt;-valP</td>
<td>PC&lt;-valP</td>
<td>PC&lt;-valP</td>
</tr>
</tbody>
</table>
<h3 id="seq硬件结构"><a class="markdownIt-Anchor" href="#seq硬件结构"></a> SEQ硬件结构</h3>
<p>图给出了一个能够执行这些计算的硬件结构的抽象表示。PC放在寄存器中，信息沿着线流动，先向上再向右。同各阶段相关的 <strong>硬件单元（hardware units）</strong> 负责执行这些处理。</p>
<p><img src="https://s2.loli.net/2022/06/01/ujEByFSpkU1sImV.png" alt="SEQ.png" />。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/05/22/study-notes-OSTEP-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/22/study-notes-OSTEP-API/" class="post-title-link" itemprop="url">OSTEP笔记 —— Linux C 系统调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-22 15:38:48" itemprop="dateCreated datePublished" datetime="2022-05-22T15:38:48+08:00">2022-05-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-05-26 11:10:36" itemprop="dateModified" datetime="2022-05-26T11:10:36+08:00">2022-05-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OSTEP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">OSTEP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="进程api"><a class="markdownIt-Anchor" href="#进程api"></a> 进程API</h2>
<h3 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">        fork() - create a child process</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">        #include &lt;sys/types.h&gt;</span><br><span class="line">        #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">        pid_t fork(void);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>fork()</code>用于创建子进程，子进程与调用<code>fork()</code>的父进程几乎完全一样，但进程描述符（process identifier, PID）不同，这是因为它们是两个进程。</p>
<p>子进程几乎拷贝了父进程的所有内容，除了<code>fork()</code>返回进程的pid。对于子进程，返回0；对于父进程，返回子进程的pid。子进程并不会从<code>main()</code>函数开始执行，而是直接从<code>fork()</code>系统调用处继续执行。</p>
<p>使用<code>fork()</code>后，两个进程没有明显的运行顺序差异。</p>
<h3 id="wait"><a class="markdownIt-Anchor" href="#wait"></a> wait</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">        wait, waitpid, waitid - wait for process to change state</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">        #include &lt;sys/types.h&gt;</span><br><span class="line">        #include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">        pid_t wait(int *wstatus);</span><br><span class="line"></span><br><span class="line">        pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line"></span><br><span class="line">        int waitid()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相较于<code>wait()</code>，<code>waitpid()</code>更加完整。</p>
<p>父进程调用<code>wait()</code>，直到子进程执行完毕，再执行父进程。</p>
<h3 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> exec</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">        execl, execlp, execle, execv, execvp, execvpe - execute a file</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">        #include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">        extern char **environ;</span><br><span class="line"></span><br><span class="line">        int execl(const char *pathname, const char* arg, ...);</span><br><span class="line"></span><br><span class="line">        int execlp(const char *file, const char *arg, ...);</span><br><span class="line">        </span><br><span class="line">        int execle(const char *pathname, const char *arg, ...);</span><br><span class="line"></span><br><span class="line">        int execv(const char *pathname, char *const argv[]);</span><br><span class="line">        int execvp(const char *file, char *const argv[]);</span><br><span class="line">        int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以<code>int execvp(const char* __file, char *const *__argv)</code>为例，前一参数为需运行的二进制文件，后一参数为程序参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);</span><br><span class="line">myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p3.c&quot;</span>);</span><br><span class="line">myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; </span><br><span class="line">execvp(myargs[<span class="number">0</span>], myargs);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt &gt; wc p3.c</span><br></pre></td></tr></table></figure>
<p><code>exec()</code>会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段以及静态数据，堆、栈和其他内存空间也会被重新初始化。它没有创建新进程，而是改变运行程序。</p>
<h2 id="内存操作api"><a class="markdownIt-Anchor" href="#内存操作api"></a> 内存操作API</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">        malloc, free, calloc, realloc, reallocarray - allocate and free dynamic memory</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">        #include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">        void *malloc(size_t size);</span><br><span class="line">        void free(void *ptr);</span><br><span class="line">        void *calloc(size_t nmemb, size_t size);</span><br><span class="line">        void *realloc(void *ptr, size_t size);</span><br><span class="line">        void *reallocarray(void *ptr, size_t nmemb, size_t size);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例如，如果需要为double分配堆内存，可以写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> *d = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure>
<p>而不建议直接传入数字参数。</p>
<p>对于为数组分配内存，可以使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 int 为例</span></span><br><span class="line"><span class="keyword">int</span> *a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">int</span> *b = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(N, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">// 下者可读性较强</span></span><br></pre></td></tr></table></figure>
<p>但是此时<code>sizeof(a)</code>或<code>sizeof(b)</code>会得到 8 （64位），这是由于没有足够的静态信息，<code>sizeof</code>计算的值为指针大小。</p>
<p>对于字符串，常使用<code>malloc(strlen(s) + 1)</code>，这是为字符串末尾的<code>\0</code>多留一点空间。也可以直接使用<code>strdup()</code>函数直接为指针分配堆内存。</p>
<p>使用<code>free()</code>释放内存。注意到<code>free()</code>只需要指针参数而不需要内存大小。</p>
<h3 id="底层系统调用"><a class="markdownIt-Anchor" href="#底层系统调用"></a> 底层系统调用</h3>
<p>事实上，<code>malloc</code>等函数并不是系统调用，而是库调用。</p>
<p>控制堆内存分断（break）的函数为<code>brk</code>，也就是改变堆结束的位置。它需求传入一个参数，来设置新分断的地址。而<code>sbrk</code>函数则类似，区别是，它传入的参数为增量。直接使用这两个函数很可能会造成错误。</p>
<p>这些函数存放在<code>unistd.h</code>中，表示<code>unix</code>标准下的系统调用。</p>
<h2 id="进程api-2"><a class="markdownIt-Anchor" href="#进程api-2"></a> 进程API</h2>
<blockquote>
<p>PPOSIX线程（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。<br />
实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-like POSIX 系统，如Linux、 Solaris。但是Microsoft Windows上的实现也存在，例如直接使用Windows API实现的第三方库pthreads-w32；而利用Windows的SFU/SUA子系统，则可以使用微软提供的一部分原生POSIX API。<br />
<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-cn/POSIX%E7%BA%BF%E7%A8%8B">维基百科（中文） POSIX线程 ［DB/OL］</a></p>
</blockquote>
<h3 id="pthread_create"><a class="markdownIt-Anchor" href="#pthread_create"></a> pthread_create</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">        pthread_create - create a new thread</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">        #include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">        int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);</span><br><span class="line"></span><br><span class="line">        Complie and link with -pthread</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数有四个参数：<code>thread</code>、<code>attr</code>、<code>start_routine</code> 和 <code>arg</code> 。</p>
<ul>
<li>参数<code>thread</code>是指向<code>pthread_t</code>结构类型的指针，我们将利用这个结构与线程交互</li>
<li>参数<code>attr</code>用于指定该线程可能具有的任何属性，包括设置栈大小或关于该线程调度优先级的信息。不需设置时传入<code>NULL</code> 。</li>
<li>参数<code>start_routine</code>为一个函数指针（function pointer）。它被传入一个<code>void *</code>类型的参数，返回一个<code>void *</code>指针。通过强制类型转化，<code>void *</code>可以转化为指向任何类型的执政。</li>
<li>参数<code>arg</code>是要传递给线程开始执行的函数的参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> p;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">myarg_t</span> args;</span><br><span class="line">args.a = <span class="number">10</span>;</span><br><span class="line">args.b = <span class="number">20</span>;</span><br><span class="line">rc = pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br></pre></td></tr></table></figure>
<h3 id="pthread_join"><a class="markdownIt-Anchor" href="#pthread_join"></a> pthread_join</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">        pthread_join - join with a terminated thread</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">        #include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">        int pthread_join(pthread_t thread, void **retval);</span><br><span class="line"></span><br><span class="line">        compile and link with -pthread</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用于等待线程完成。</p>
<p>该函数有两个参数</p>
<ul>
<li><code>pthread_t</code>类型，指定需要等待的线程。</li>
<li>指针，指向所希望得到的返回值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// has already run pthread_t p</span></span><br><span class="line"><span class="keyword">myret_t</span> *m;</span><br><span class="line">pthread_join(p, (<span class="keyword">void</span> **) &amp;m);</span><br></pre></td></tr></table></figure>
<p>如果线程最终无返回值，则<code>retval</code>传入<code>NULL</code>即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/05/19/study-notes-OSTEP-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/19/study-notes-OSTEP-3/" class="post-title-link" itemprop="url">OSTEP笔记（三）—— 并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-19 21:51:33" itemprop="dateCreated datePublished" datetime="2022-05-19T21:51:33+08:00">2022-05-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-12 14:09:42" itemprop="dateModified" datetime="2022-06-12T14:09:42+08:00">2022-06-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OSTEP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">OSTEP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>Three easy pieces: 虚拟化，并发，持久性</em></p>
<h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1>
<h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2>
<p><strong>特点</strong>：类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。</p>
<p><strong>线程状态</strong>：</p>
<ul>
<li>程序计数器（PC）</li>
<li>寄存器</li>
</ul>
<p>线程切换同样需要上下文切换。对于线程，我们保存上下文在一个或多个线程控制块（Thread Control Block，TCB）。与进程相比，线程在切换上下文时，地址空间不变。</p>
<p>另一个区别在于栈的数量。多线程的程序中，每个线程独立运行，每个线程都有一个栈。所有位于栈上的变量、参数、返回值等将被放在线程本地（thread-local）存储的地方，即相关线程的栈。</p>
<h3 id="可能存在的问题"><a class="markdownIt-Anchor" href="#可能存在的问题"></a> 可能存在的问题</h3>
<ol>
<li>线程执行顺序不确定，取决于调度顺序</li>
<li>出现 <strong>竞争条件（race condition）</strong> ，使得结果不确定。</li>
</ol>
<p>当多个线程处于竞争状态时，称之为 <strong>临界区（critical section）</strong> 。临界区是访问共享资源的代码片段。</p>
<p>我们希望 <strong>互斥（mutual exclusion）</strong> ，这个属性保证了如果一个线程在临界区执行，其他线程将被阻止进入临界区。</p>
<h3 id="原子性愿望"><a class="markdownIt-Anchor" href="#原子性愿望"></a> 原子性愿望</h3>
<p>当指令执行时，它会像期望那样执行更新。它不能在指令中间中断，因为这正是我们从硬件获得的保证：发生中断时，指令根本没有运行，或者运行完成，没有中间状态。</p>
<p>在这里，原子方式的意思是“作为一个单元”，有时我们说“全部或没有”。我们要做的是要求硬件提供一些有用的指令，可以在这些指令上构建一个通用的集合，即所谓的 <strong>同步原语（synchronization primitive）</strong> 。</p>
<h3 id="等待"><a class="markdownIt-Anchor" href="#等待"></a> 等待</h3>
<p>还有另一种常见的交互，即一个线程在继续前必须等待另一个线程完成某些操作。这是在多线程程序中常见的睡眠/唤醒交互机制。</p>
<h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2>
<p>通过在临界区周围加 <strong>锁（lock）</strong> ，保证临界区能够像单条原子指令一样执行。</p>
<h3 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock_t</span> mutex;</span><br><span class="line"><span class="comment">// ···</span></span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>锁是一个变量。这个变量保存了锁在某一时刻的状态，要么是可用的，要么是被占用的，正处于临界区。</p>
<p><code>lock()</code>尝试获取锁。如果另一个线程对相同的锁变量调用<code>lock()</code>，该调用不会返回。</p>
<p>锁的持有者调用<code>unlock()</code> ，锁就变成可用了。如果有等待线程，其中一个接收到了变化，获取该锁，进入临界区。</p>
<p>评价锁的效果，有一些标准：</p>
<ol>
<li>
<p>锁能否实现互斥性。</p>
</li>
<li>
<p>公平性。是否每一个竞争线程有公平的机会抢到锁。</p>
</li>
<li>
<p>性能。使用锁之后增加的时间开销。包括单个线程，一个CPU多个线程，多个CPU多个线程。</p>
</li>
</ol>
<h3 id="控制中断"><a class="markdownIt-Anchor" href="#控制中断"></a> 控制中断</h3>
<p>在代码进入临界区前关闭中断可以保证临界区的代码不会中断执行。</p>
<p>但是缺点很多</p>
<ul>
<li>一个贪婪的程序可能在一开始时就调用<code>lock()</code>，独占处理器，甚至直接进入死循环。</li>
<li>不支持多处理器。即使关闭了中断，其他线程也可以运行在其他处理器上。</li>
<li>中断丢失可能导致严重的系统问题。</li>
<li>效率低。</li>
</ul>
<p>只有在某些非常有限的情况下，用关闭中断来实现互斥原语，比如操作系统内部。</p>
<h3 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h3>
<h4 id="测试并设置指令原子交换"><a class="markdownIt-Anchor" href="#测试并设置指令原子交换"></a> 测试并设置指令（原子交换）</h4>
<p><strong>测试并设置指令（test-and-set instruction）</strong>，或称之 <strong>原子交换（atomic exchange）</strong> 。</p>
<p>常用实现锁的一种技术为 <strong>自旋等待（spin-waiting）</strong> ，不停检查标志的值。为了防止中断打断检查，我们需要硬件支持的原子指令，其中一种就是设置并测试指令。</p>
<p>用C代码表示该指令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *old_ptr;</span><br><span class="line">    *old_ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin-wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即返回旧值，同时将旧值设置为新值，这是一个原子（atomically）指令。</p>
<p>工作原理：</p>
<ul>
<li>假设一个线程调用<code>lock()</code>，没有其他线程持有锁。调用<code>TestAndSet(&amp;flag, 1)</code>，返回 <code>0</code> ，线程跳出 <code>while</code> 循环，获取锁，同时也会原子地设置<code>flag</code>为 <code>1</code> ，标志锁已经被持有。</li>
<li>当某一个线程已经持有锁，本线程调用<code>lock()</code>，然后调用<code>TestAndSet(&amp;flag, 1)</code>，这次返回 <code>1</code>。只要另一个线程一直持有锁，其便会重复返回 <code>1</code> ，线程将一直自旋。</li>
</ul>
<p>这种锁就是 <strong>自旋锁（spin lock）</strong>，一直自旋，利用CPU周期。</p>
<p>在单处理器上，需要抢占式的调度器，否则自旋锁在单CPU上无法使用，因为一个自旋的线程永远不会放弃CPU。</p>
<p>基于原子交换的自旋锁，是正确的锁，但是不提供公平性保证。自旋的锁可能会永远自旋。单CPU上，自旋锁性能开销相当大。但是多CPU上，性能较好。</p>
<h4 id="比较并交换指令"><a class="markdownIt-Anchor" href="#比较并交换指令"></a> 比较并交换指令</h4>
<p>某些系统提供另一个原语，比较并交换（compare-and-swap in SPARC, compare-and-exchange in x86）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (actual == expected)</span><br><span class="line">        *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该指令测试<code>ptr</code>指向的值是否和<code>expected</code>相等；如果是，更新<code>ptr</code>所指的值为新值。否则，什么也不做。无论哪种情况，都返回该内存地址的实际值。</p>
<p>若使用该原语，则<code>lock()</code>函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查标志是否为 <code>0</code>。如果是，原子地交换为 <code>1</code> 。</p>
<h4 id="链接的加载和条件式存储指令"><a class="markdownIt-Anchor" href="#链接的加载和条件式存储指令"></a> 链接的加载和条件式存储指令</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StoreCondition</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no one has update *ptr since the LoadLinked to <span class="keyword">this</span> address)</span><br><span class="line">    &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接的加载指令和典型加载指令类似。区别在于 <strong>条件式存储（store-conditional）</strong> 指令，只有上一次加载的地址在期间没有更新时，才会成功。成功时返回<code>1</code>并将<code>ptr</code>指向的值更新为<code>value</code>，否则返回<code>0</code>。</p>
<p>用其实现的自旋锁如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(LoadLinked(&amp;lock-&gt;flag) == <span class="number">1</span>)</span><br><span class="line">            ;       <span class="comment">// spin until it&#x27;s zero</span></span><br><span class="line">        <span class="keyword">if</span> (StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// if set-it-to-1 was success: all done</span></span><br><span class="line">                    <span class="comment">// otherwise: try it all over again </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock函数：一个线程自选等待标志被设置为0。一旦如此，线程尝试通过条件存储获取锁，如果成功，则线程自动将标志值设置为1，从而可以进入临界区。</p>
<h4 id="获取并增加指令"><a class="markdownIt-Anchor" href="#获取并增加指令"></a> 获取并增加指令</h4>
<p>该指令原子地返回特定地址的旧值，并让该值自增<code>1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ticket;</span><br><span class="line">    <span class="keyword">int</span> turn;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn   = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(*lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn)</span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lock</code>时，对一个锁的<code>ticket</code>值获取并增加，同时旧值赋值给<code>myturn</code>。若<code>myturn == lock-&gt;turn</code>则进入临界区。<code>unlock</code>时，直接增加<code>turn</code>。</p>
<h3 id="自旋锁的缺点和改进方式"><a class="markdownIt-Anchor" href="#自旋锁的缺点和改进方式"></a> 自旋锁的缺点和改进方式</h3>
<p>某些方案下自旋锁效率极低。单处理器双线程时，一个线程获取了锁，另一个线程去获取锁时便陷入不断的自旋中，浪费了所有时间片。这需要操作系统进行改进。</p>
<h4 id="休眠"><a class="markdownIt-Anchor" href="#休眠"></a> 休眠</h4>
<p>一种简单的方法是，在要自旋的时候，放弃CPU。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        yield(); <span class="comment">// give up the CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假定操作系统提供原语<code>yield()</code> ，线程可以调用它主动放弃CPU。<code>yield()</code>调用让运行态（running）变为就绪态（ready）。</p>
<p>在单CPU双线程的情况下，表现显然很好。但考虑多CPU反复竞争一把锁的情况，其他CPU会处于运行——让出这种模式。并且，一个线程可能一直处于让出的循环，造成饥饿问题。</p>
<h4 id="队列休眠"><a class="markdownIt-Anchor" href="#队列休眠"></a> 队列：休眠</h4>
<p>我们必须显式控制锁释放时，谁能抢到锁。我们需要操作系统更多的支持，并需要一个队列来保存等待锁的线程。</p>
<p>考虑两个调用：<code>park()</code>与<code>unpark(threadId)</code>。前者让线程休眠，后者则会唤醒<code>threadID</code>标识的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> guard;</span><br><span class="line">    <span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>; <span class="comment">//lock is acquired</span></span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q));</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h2>
<p>在很多情况下，线程需要检查某一条件是否满足后，才会继续运行，例如<code>join()</code>，例如父线程使用<code>wait()</code>等待子线程。</p>
<p>线程可以使用 <strong>条件变量（condition variable）</strong> 来等待一个条件变成真。条件变量是一个显式队列，当某些条件不满足时，线程可以把自己加入队列，等待该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或多个等待线程。</p>
<p>条件变量有两种操作：<code>wait()</code>和<code>signal()</code>。线程要睡眠的时候，调用<code>wait()</code>。当线程想唤醒等待在某个条件变量上的睡眠线程时，调用<code>signal()</code>，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    done = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;c);</span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    thr_exit();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_join</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    <span class="keyword">while</span> (done == <span class="number">0</span>)</span><br><span class="line">        pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> p;</span><br><span class="line">    pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    thr_join();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wait()</code>调用中互斥量的作用是，假定调用<code>wait()</code>时已经是上锁状态。<code>wait()</code>的职责是释放锁，并让调用线程休眠（原子地）。当线程被唤醒时，重新获取锁，并返回调用者。</p>
<p>上述代码可能有两种情况</p>
<ol>
<li>父线程创建子线程，但自己先运行，然后调用<code>thr_join</code>等待子线程。它会获取锁后释放并休眠，接下来子线程运行并发出信号唤醒父线程，最后释放锁。父线程被唤醒后会重新上锁并直接释放锁。</li>
<li>子线程先运行，设置变量<code>done</code>为<code>1</code>，<code>signal()</code>实际上无作用，打印后直接结束。父线程调用<code>thr_join</code>，由于<code>done</code>为<code>1</code>，直接返回。</li>
</ol>
<p>非常有必要发发信号时总是持有锁。</p>
<h3 id="生产者消费者问题"><a class="markdownIt-Anchor" href="#生产者消费者问题"></a> 生产者/消费者问题</h3>
<p><strong>生产者/消费者（producer/consumer）问题</strong>，也叫作 <strong>有界缓冲区（bounded buffer）</strong> 问题。</p>
<p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区，消费者从缓冲区取走消费。</p>
<p>因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞态条件，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(count = <span class="number">0</span>);</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    buffer = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(count == <span class="number">1</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅当缓冲器为空，即<code>count==0</code>时放入数据，反之时取出数据。我们假设有一个生产者放数据，一个消费者取数据。使用条件变量和锁来防止竞争。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond_t</span> cond;</span><br><span class="line"><span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> loops = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一程序仅当单生产者单消费者时成立。例如有两个消费者时，第一个消费者首先休眠，当生产者唤醒第一个消费者时，可能与第二个消费者形成竞争，使得其中一个消费者事实上无法获取缓冲区数据。</p>
<p>故更优的写法是用<code>while</code>代替<code>if</code>，但是这仍有问题，考虑多个消费者的情况，消费者在消费之后，有可能唤醒另一个消费者，形成无效的唤醒。</p>
<p>终极的解决方案是，使用两个条件变量，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond_t</span> empty, fill;</span><br><span class="line"><span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">1</span>)</span><br><span class="line">            pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line">        put(i);</span><br><span class="line">        pthread_cond_signal(&amp;fill);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">1</span>)</span><br><span class="line">            pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        pthread_cond_signal(&amp;empty);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样避免了一个问题：消费者再也不会唤醒消费者，生产者同理，这并不难理解，因为使用了两个条件变量，使得生产者、消费者的等待队列分离了。</p>
<h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2>
<p>信号量是有一个整数值的对象。初始化信号量函数为<code>int sem_init(sem_t *sem, int pshared, unsigned int value)</code>，<code>pshared</code>赋值0表示仅单进程使用。在POSIX标准中由两个函数操控。</p>
<ul>
<li><code>int sem_wait(sem_t *sem)</code>，减少信号量，如果信号量是负值则等待</li>
<li><code>int sem_post(sem_t *sem)</code>，增加信号量，如果由进程等待，则唤醒其中之一</li>
</ul>
<p>要注意的是，<code>sem_wait</code>会先减少再考虑是否等待。<code>sem_post</code>不需要任何条件而直接自增。同时，当信号量的值为负数时，这个值就是等待进程的数量。</p>
<h3 id="二值信号量锁"><a class="markdownIt-Anchor" href="#二值信号量锁"></a> 二值信号量（锁）</h3>
<p>信号量可以作为锁来使用。</p>
<p>为信号量赋初值为1，<code>sem_init(&amp;s, 0, 1)</code>。假设有两个线程，第一个线程调用<code>sem_wait()</code>使信号量为0，若有其他线程调用<code>sem_wait()</code>，则信号量变为-1，进入等待队列。直到原线程调用<code>sem_post</code>，使其变为0值并唤醒休眠线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>
<h3 id="信号量用作条件变量"><a class="markdownIt-Anchor" href="#信号量用作条件变量"></a> 信号量用作条件变量</h3>
<p>类似上文中父子进程案例，信号量赋初值为0.</p>
<p>当创建子线程后，父线程调用<code>sem_wait()</code>并在子线程中使用<code>sem_post</code>，同样只有两种情况，先运行父线程时，由于信号量变为负，休眠父线程并等待子线程。若先运行子线程，则按原顺序进行。</p>
<p>注意到<code>sem_wait()</code>并没有释放锁的功能，所以绝不能认为其类似于<code>wait()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sem_init(&amp;s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> c;</span><br><span class="line">    pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line">    sem_wait(&amp;s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产者消费者问题-2"><a class="markdownIt-Anchor" href="#生产者消费者问题-2"></a> 生产者/消费者问题</h3>
<p>直接使用信号量代替锁和条件变量，可以得到上文中解决方案的一个代替。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> empty;</span><br><span class="line"><span class="keyword">sem_t</span> full;</span><br><span class="line"><span class="keyword">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        put(i);</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loops; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        <span class="keyword">int</span> tmp = get();</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这个解决方案是会导致死锁的。假设一个消费者先行上锁，并发现没有缓存后，等待。由于信号量的等待不会像条件变量一样让出锁，所以，此时若另一个生产者进行生产，则不能获取锁。</p>
<p>解决这一问题，只需要减少锁的作用域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;full);</span><br><span class="line">sem_wait(&amp;mutex);</span><br><span class="line"><span class="keyword">int</span> tmp = get();</span><br><span class="line">sem_post(&amp;mutex);</span><br><span class="line">sem_post(&amp;empty);</span><br><span class="line"><span class="comment">// 生产者同理</span></span><br></pre></td></tr></table></figure>
<p>也就是，先确定缓存区是否可用，再对数据上锁。</p>
<h3 id="读者-写者锁"><a class="markdownIt-Anchor" href="#读者-写者锁"></a> 读者-写者锁</h3>
<p>读者-写者锁（reader-writer lock）认为不同数据访问需要不同类型的锁，写数据时，需要锁定临界区，但是读数据时应当允许并行访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">sem_t</span> lock;</span><br><span class="line">    <span class="keyword">sem_t</span> writelock;</span><br><span class="line">    <span class="keyword">int</span> readers;</span><br><span class="line">&#125; <span class="keyword">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_init</span><span class="params">(rwlock *rw)</span> </span>&#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_readlock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        sem_post(&amp;rw-&gt;writelock);</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_acquire_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rwlock_release_writelock</span><span class="params">(<span class="keyword">rwlock_t</span> *rw)</span> </span>&#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说，更新数据结构时，只有一个写者能获得锁并进入临界区。</p>
<p>而获取读锁时，对于第一个读者，其同时获取写锁。可以有许多读者获取读锁，通过一个数值记录读者的数量。若想获取写锁，需要等待所有读者释放读锁。</p>
<h3 id="哲学家就餐问题"><a class="markdownIt-Anchor" href="#哲学家就餐问题"></a> 哲学家就餐问题</h3>
<p>略过大部分内容。简单地说，五个哲学家会随机拿取左右手的叉子进食，但叉子只有五把。在最极端情况下，所有哲学家都拿起了左手（或右手边）的叉子，便会直接引起死锁。故直接提出解答：假定序号最大的哲学家取餐叉的顺序不同，便不会造成死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getforks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">4</span>) &#123;</span><br><span class="line">        sem_wait(forks[right(p)]);</span><br><span class="line">        sem_wait(forks[left(p)]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sem_wait(forks[left(p)]);</span><br><span class="line">        sem_wait(forks[right(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，从最后一个哲学家向前，所有哲学家都会逐渐拿到叉子。</p>
<h2 id="常见并发问题"><a class="markdownIt-Anchor" href="#常见并发问题"></a> 常见并发问题</h2>
<h3 id="非死锁缺陷"><a class="markdownIt-Anchor" href="#非死锁缺陷"></a> 非死锁缺陷</h3>
<p>基本由两类缺陷组成：<strong>违反原子性（atomicity violation）</strong>、<strong>错误顺序（order violation）</strong> 。</p>
<h4 id="违反原子性"><a class="markdownIt-Anchor" href="#违反原子性"></a> 违反原子性</h4>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>::</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">fputs</span>(thd-&gt;proc_info,...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>::</span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>假如第一个线程检查后发生中断，被第二个线程置<code>NULL</code>，便会发生错误。修复其很简单，只需要使用锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> proc_info_lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span>::</span><br><span class="line">pthread_mutex_lock(&amp;proc_info_lock);</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;proc_info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">fputs</span>(thd-&gt;proc_info, ...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;proc_info_lock);</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>::</span><br><span class="line">pthread_mutex_lock(&amp;proc_info_lock);</span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;proc_info_lock);</span><br></pre></td></tr></table></figure>
<h4 id="违反顺序缺陷"><a class="markdownIt-Anchor" href="#违反顺序缺陷"></a> 违反顺序缺陷</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>::</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mThread = PR_CreateThread(mMain, ...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>::</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个线程假定<code>mThread</code>已被初始化，但是不可知的。显然，解决这一问题的办法就是条件变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mtLock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> mtCond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">int</span> mtInit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span>::</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mThread = PR_CreateThread(mMain, ...);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    mtInit = <span class="number">1</span>;</span><br><span class="line">    pthread_cond_signal(&amp;mtCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>::</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pthread_mutex_lock(&amp;mtLock);</span><br><span class="line">    <span class="keyword">while</span>(mtInit == <span class="number">0</span>)</span><br><span class="line">        pthread_cond_wait(&amp;mtCond, &amp;mtLock);</span><br><span class="line">    pthread_mutex_unlock(&amp;mtLock);</span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁缺陷"><a class="markdownIt-Anchor" href="#死锁缺陷"></a> 死锁缺陷</h3>
<p><strong>死锁（deadlock）</strong> 是一个经典问题。例如，线程1持有锁1，等待锁2，线程2持有锁2，等待锁1。</p>
<h4 id="产生死锁的条件"><a class="markdownIt-Anchor" href="#产生死锁的条件"></a> 产生死锁的条件</h4>
<ul>
<li>互斥：线程对于需要的资源进行互斥的访问。</li>
<li>持有并等待：线程持有了资源，同时又在等待其他资源。</li>
<li>非抢占：线程获得的资源不能被抢占</li>
<li>循环等待：线程之间存在环路，每个线程持有一个资源，这个资源又是下一个线程要申请的。</li>
</ul>
<p>最实用的预防技术就是不让代码产生循环等待。使用<strong>全序（total ordering）</strong>，也就是安排好线程顺序是一个方法。但更使用的是<strong>偏序（partial ordering）</strong> 可能更加有用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/05/17/study-notes-CSAPP-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/17/study-notes-CSAPP-2/" class="post-title-link" itemprop="url">CSAPP笔记（二）—— 程序的机器级表示</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-17 12:45:59" itemprop="dateCreated datePublished" datetime="2022-05-17T12:45:59+08:00">2022-05-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-14 16:04:45" itemprop="dateModified" datetime="2022-06-14T16:04:45+08:00">2022-06-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="程序编码"><a class="markdownIt-Anchor" href="#程序编码"></a> 程序编码</h2>
<p>对于如下编译指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<p>首先，<strong>C预处理器</strong>扩展源代码，插入所有用<code>#include</code>命令指定的<strong>文件</strong>，并扩展所有用<code>#define</code>声明指定的<strong>宏</strong>。</p>
<p>其次，<strong>编译器</strong>产生两个源文件的<strong>汇编代码</strong>，名字分别为<code>p1.s</code> 和 <code>p2.s</code>。接下来，<strong>汇编器</strong>会将汇编代码转化成二进制<strong>目标代码</strong>文件<code>p1.o</code>和<code>p2.o</code>。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，<strong>链接器</strong>将两个目标代码文件与实现库函数（例如<code>printf</code>）的代码合并，并产生最终的<strong>可执行文件</strong><code>p</code>。</p>
<h3 id="机器级代码"><a class="markdownIt-Anchor" href="#机器级代码"></a> 机器级代码</h3>
<p>机器级编程着重于两种抽象：</p>
<ol>
<li>由 <strong>指令集架构（Instruction Set Architecture, ISA）</strong> 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数ISA指令为顺序执行，但实际上由CPU并发执行。</li>
<li>机器级程序使用的内存地址是 <strong>虚拟地址</strong>，提供的内存模型看上去是一个非常大的字节数组。</li>
</ol>
<p>汇编代码用可读性更好的文本格式表示机器级代码。一些隐藏的处理器状态对于汇编代码是可见的：</p>
<ul>
<li><strong>程序计数器（Program Counter，PC，%rip in x86_64）</strong> 给出将要执行的下一条指令在内存中的地址。</li>
<li><strong>整数寄存器</strong> 用于存储地址或整数数据、记录程序状态、保存临时数据（例如过程的参数和局部变量，函数的返回值）。</li>
<li><strong>条件码寄存器</strong> 保存最近执行的算数或逻辑指令的状态信息，实现条件变化，如 <code>if</code> 和 <code>while</code>。</li>
<li><strong>向量寄存器</strong>，存放多个整数或浮点数值。</li>
</ul>
<p>机器级代码将内存看为按字节寻址的数组，数据用连续的字节来表示，汇编代码不区分有符号或无符号整数，不区分各类型的指针，也不区分整数和指针。</p>
<p><strong>反汇编器（disassembler）</strong></p>
<p>可以使用例如<code>objdump</code>的反汇编器来获取机器代码文件的内容。（举例略）</p>
<p>反汇编的特性：</p>
<ul>
<li>x86_64的指令长度从1到15个字节不等。</li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如只有<code>pushq %rbx</code>是以字节值 53 开头的。</li>
<li>反汇编器不需要访问该程序的源代码或汇编代码。</li>
<li>反汇编器与GCC生成的汇编代码有些微差异。</li>
</ul>
<p>在汇编代码中，部分以<code>.</code>开头的代码为指导汇编器和链接器工作的伪指令，可以暂时忽略。</p>
<h2 id="数据格式"><a class="markdownIt-Anchor" href="#数据格式"></a> 数据格式</h2>
<p>Intel用术语 <strong>字(word)</strong> 表示16位数据类型，称32位数为 <strong>双字(double words)</strong>，称64位数为 <strong>四字(quad words)</strong> 。</p>
<table>
<thead>
<tr>
<th style="text-align:center">C声明</th>
<th style="text-align:center">Intel数据类型</th>
<th style="text-align:center">汇编代码后缀</th>
<th style="text-align:center">大小（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">字节</td>
<td style="text-align:center">b</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">字</td>
<td style="text-align:center">w</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">双字</td>
<td style="text-align:center">l</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">四字</td>
<td style="text-align:center">q</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">char*</td>
<td style="text-align:center">四字</td>
<td style="text-align:center">q</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度</td>
<td style="text-align:center">s</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度</td>
<td style="text-align:center">l</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：<code>movb</code>、<code>movw</code>、<code>movl</code>、<code>movq</code>。</p>
<h2 id="访问信息"><a class="markdownIt-Anchor" href="#访问信息"></a> 访问信息</h2>
<p>一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的 <strong>通用目的寄存器</strong> 。这些寄存器用来存储整数数据和指针。</p>
<table>
<thead>
<tr>
<th>63</th>
<th>31</th>
<th>15</th>
<th>7</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>%eax</td>
<td>%ax</td>
<td>%al</td>
<td>返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td>%ebx</td>
<td>%bx</td>
<td>%bl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>%ecx</td>
<td>%cx</td>
<td>%cl</td>
<td>第4个参数</td>
</tr>
<tr>
<td>%rdx</td>
<td>%edx</td>
<td>%dx</td>
<td>%dl</td>
<td>第3个参数</td>
</tr>
<tr>
<td>%rsi</td>
<td>%esi</td>
<td>%si</td>
<td>%sil</td>
<td>第2个参数</td>
</tr>
<tr>
<td>%rdi</td>
<td>%edi</td>
<td>%di</td>
<td>%dil</td>
<td>第1个参数</td>
</tr>
<tr>
<td>%rbp</td>
<td>%ebp</td>
<td>%bp</td>
<td>%bpl</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>%esp</td>
<td>%sp</td>
<td>%spl</td>
<td>栈指针</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td>%r8b</td>
<td>第5个参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td>%r9b</td>
<td>第6个参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td>%r10b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td>%r11b</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td>%r12b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td>%r13b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td>%r14b</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td>%r15b</td>
<td>被调用者保存</td>
</tr>
</tbody>
</table>
<p>其中最特别的是栈指针，用来指明运行时栈的结束位置。</p>
<h3 id="操作数指示符"><a class="markdownIt-Anchor" href="#操作数指示符"></a> 操作数指示符</h3>
<p>大多数指令有一个或多个 <strong>操作数(operand)</strong>，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或从寄存器或内存中读出。结果可以存放在寄存器或内存中。</p>
<p>各种不同的操作数可以分为三种类型：</p>
<ol>
<li><strong>立即数(immediate)</strong>，用来表示常数值，如<code>$0x1F</code>。</li>
<li><strong>寄存器(register)</strong>，表示某个寄存器的内容。我们用符号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">r_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示任意寄存器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，用引用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[r_a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 来表示它的值，这是将寄存器集合看成一个数组，用寄存器标识符作为索引。</li>
<li><strong>内存引用</strong>，我们用符号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mi>b</mi></msub><mo stretchy="false">[</mo><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M_b[Addr]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 来表示对存储在内存中从地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Addr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 开始的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个字节值的引用，为了简便，通常省去下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 。</li>
</ol>
<p>有多种不同的 <strong>寻址模式</strong>，允许不同形式的的内存引用。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mi mathvariant="normal">，</mi><msub><mi>r</mi><mi>i</mi></msub><mi mathvariant="normal">，</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b，r_i，s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 表示的是最常用的形式：立即数偏移地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Imm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span></span></span></span>，基址寄存器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">r_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，变址寄存器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和一个比例因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">s \in \{1, 2, 4, 8\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">}</span></span></span></span> 。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">操作数值</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即数</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">$</mi><mi>I</mi><mi>m</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">\$Imm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">$</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Imm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span></span></span></span></td>
<td style="text-align:center">立即数寻址</td>
</tr>
<tr>
<td style="text-align:center">寄存器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">r_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[r_a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">寄存器寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">Imm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">绝对寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[R[r_a]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">间接寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[r_b]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">（基址+偏移量）寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_b,r_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[R[r_b]+R[r_i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b, r_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[b]+R[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[R[r_b]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[r_b]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_b,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mo stretchy="false">[</mo><msub><mi>R</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[[R_i]+R[r_b]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[r_b]+R[r_i]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
</tbody>
</table>
<h3 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h3>
<p>数据传输指令将数据从一个位置传送到另一个位置。典型为MOV类，把数据从源位置移动到目的位置，不做任何变化。MOV类指令由四条指令组成：<code>movb</code>、<code>movw</code>、<code>movl</code>和<code>movq</code>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果     </th>
<th>描述   </th>
</tr>
</thead>
<tbody>
<tr>
<td>MOV      S, D</td>
<td> S-&gt;D </td>
<td>传送</td>
</tr>
<tr>
<td><code>movb</code><br><code>movw</code><br><code>movl</code><br><code>movq</code><br><code>movabsq</code>     I, R</td>
<td><br><br><br><br> I-&gt;R </td>
<td>传送字节<br>传送字<br>传送双字<br>传送四字<br>传送绝对的四字</td>
</tr>
</tbody>
</table>
<p>源操作数指定的值是一个立即数，存储在寄存器或内存中。目的操作数指定一个位置，寄存器或内存地址。x86_64中不允许两个操作数都指向内存位置。</p>
<p>MOVZ类中的指令把目的中剩余的字节填充为<code>0</code>，而MOVS类中的指令通过符号扩展来填充，把源操作数的最高位进行复制。指令名字最后两个字符，第一个指示源的大小，第二个指示目的的大小，只考虑目的大于等于原的情况。</p>
<p>特别的，<code>cltq</code>指令没有操作数，总是以<code>%eax</code>作为源，<code>%rax</code>作为符号扩展结果，等价于<code>movslq %eax, %rax</code>。</p>
<p><code>push</code>用于把数据压入栈，而<code>pop</code>从栈中弹出数据。弹出的值永远最近被压入且仍然在栈中的值。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pushq    S</td>
<td>R[%rsp] &lt;- R[%rsp] - 8;<br>M[R[%rsp]] &lt;- S</td>
<td>将四字压入栈</td>
</tr>
<tr>
<td>popq     D</td>
<td>D&lt;-M[R[%rsp]];<br>R[%rsp]&lt;-R[%rsp]+8</td>
<td>将四字弹出栈</td>
</tr>
</tbody>
</table>
<p>基本上来说，<code>pushq %rbp</code>（一般使用rbp作为帧指针）的行为等价于</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $<span class="number">8</span>,%rsp</span><br><span class="line">movq %rbp,(%rsp)</span><br></pre></td></tr></table></figure>
<p>也就是让栈指针下降，并用帧指针的值更新栈指针指向的虚拟内存位置，使得当时栈指针指向的内存处，存放帧指针的值。前者明显节约了指令字节数。</p>
<p>而<code>popq %rax</code>（一般用rax作为存储返回值的寄存器）基本等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp),%rax</span><br><span class="line">addq $8,%rsp</span><br></pre></td></tr></table></figure>
<p>也就是，将当时栈指针指向的内存的值传送给%rax，并将栈指针归位。</p>
<h2 id="算数和逻辑操作"><a class="markdownIt-Anchor" href="#算数和逻辑操作"></a> 算数和逻辑操作</h2>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>leaq</code>    S, D</td>
<td>D &lt;- &amp;S </td>
<td>加载有效地址</td>
</tr>
<tr>
<td><code>INC</code>    D<br><code>DEC</code>    D<br><code>NEG</code>    D<br><code>NOT</code>    D<br></td>
<td>D &lt;- D + 1<br>D &lt;- D - 1<br>D &lt;- -D<br>D &lt;- ~D</td>
<td>加1<br>减1<br>取负<br>取补</td>
</tr>
<tr>
<td><code>ADD</code>    S, D<br><code>SUB</code>    S, D<br><code>IMUL</code>    S, D<br><code>XOR</code>    S, D<br><code>OR</code>      S, D<br><code>AND</code>    S, D</td>
<td>D &lt;- D + S<br>D &lt;- D - S<br>D &lt;- D * S<br>D &lt;- D ^ S<br>D &lt;- D | S<br>D &lt;- D &amp; S</td>
<td>加<br>减<br>乘<br>异或<br>或<br>与</td>
</tr>
<tr>
<td><code>SAL</code>    k, D<br><code>SHL</code>    k, D<br><code>SAR</code>    k, D<br><code>SHR</code>    k, D<br></td>
<td>D &lt;- D &lt;&lt; k<br>D &lt;- D &lt;&lt; k<br>D &lt;- D &gt;&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">_{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.47833099999999995em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> k<br>D &lt;- D &gt;&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow></mrow><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">_{L}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.47833099999999995em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> k</td>
<td>左移<br>左移（等同于SAL）<br>算术右移<br>逻辑右移</td>
</tr>
</tbody>
</table>
<h3 id="加载有效地址"><a class="markdownIt-Anchor" href="#加载有效地址"></a> 加载有效地址</h3>
<p><strong>加载有效地址（load effective address）</strong> 指令<code>leaq</code>从内存读数据到寄存器，将有效地址写入到目的操作数，对于源操作数，等价于<code>&amp;S</code>。可用于描述普通的算术操作，例如<code>leaq 7(%rdx, %rdx, 4), %rax</code> ，若记<code>%rdx</code>值为<code>x</code>，有<code>%rax</code>的值为<code>5 * x + 7</code>。</p>
<h3 id="一元操作和二元操作"><a class="markdownIt-Anchor" href="#一元操作和二元操作"></a> 一元操作和二元操作</h3>
<p>第二组的操作是一元操作，只有一个操作数，既是源又是目的。可以是一个寄存器，也可以是一个内存位置，类似于<code>++</code>。</p>
<p>第三组是二元操作，其中第二个数既是源又是目的，类似于<code>+=</code>。第一个操作数可以是立即数、寄存器或内存位置。</p>
<h3 id="移位操作"><a class="markdownIt-Anchor" href="#移位操作"></a> 移位操作</h3>
<p>移位量可以是一个立即数，或放且只放在单字节寄存器<code>%cl</code>中。移位操作对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 位长的数据值进行操作，移位量由<code>%cl</code>寄存器的低 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 位决定，这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">2^m=w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 。高位会被忽略 。例如，当<code>%cl</code>值为<code>0xFF</code>时，指令<code>salb</code>会移<code>7</code>位，<code>salw</code>会移<code>15</code>位，<code>sall</code>会移<code>31</code>位，而<code>salq</code>会移<code>63</code>位。</p>
<p>左移的两个指令，效果是一样的。而<code>SAR</code>执行算术移位（填上符号位），<code>SHR</code>执行逻辑移位（填上<code>0</code>）。移位操作的目的操作数可以是一个寄存器或是一个内存位置。</p>
<p>大多数指令是无符号、有符号数通用的，只有右移指令需要做出区分。</p>
<h3 id="特殊的算数操作"><a class="markdownIt-Anchor" href="#特殊的算数操作"></a> 特殊的算数操作</h3>
<p>首先，两个64位无符号或有符号乘法，需要128位来表示。x86_64指令集对128位数的操作提供有限支持。Intel把16字节的数称作八字（oct word）。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>imulq    S<br>mulq     S</td>
<td>R[%rdx]：R[%rax]&lt;-S × R[%rax]<br>R[%rdx]：R[%rax]&lt;-S × R[%rax]</td>
<td>有符号全乘法<br>无符号全乘法</td>
</tr>
<tr>
<td>clto</td>
<td>R[%rdx]：R[%rax]&lt;-符号扩展（R[%rax]）</td>
<td>转换为八字</td>
</tr>
<tr>
<td>idivq    S</td>
<td>R[%rdx]&lt;-R[%rdx]：R[%rax] mod S<br>R[%rdx]&lt;-R[%rdx]：R[%rax] ÷ S</td>
<td>有符号除法</td>
</tr>
<tr>
<td>divq    S</td>
<td>R[%rdx]&lt;-R[%rdx]：R[%rax] mod S<br>R[%rdx]&lt;-R[%rdx]：R[%rax] ÷ S</td>
<td>无符号除法</td>
</tr>
</tbody>
</table>
<p>在上文中有<code>imul S, D</code>，这种形式的指令是一个双操作数乘法指令。但这里的<code>imulq</code>与<code>mulq</code>，作为单操作数指令，可以计算两个64位的全128位乘积。</p>
<p>这两个指令要求一个参数必须在寄存器<code>%rax</code>中，而另一个作为源操作数。然后乘积存放在<code>%rdx</code>（高64位）和<code>%rax</code>（低64位）中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int128 <span class="keyword">uint128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store_uprod</span><span class="params">(<span class="keyword">uint128_t</span> *dest, <span class="keyword">uint64_t</span> x, <span class="keyword">uint64_t</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *dest = x * (<span class="keyword">uint128_t</span>) y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># void store_uprod</span><br><span class="line"># dest int %rdi, x in %rsi, y in %rdx</span><br><span class="line">store_uprod:</span><br><span class="line">    movq    %rsi, %rax      # Copy x to multiplicand</span><br><span class="line">    mulq    %rdx            # Multiply by y</span><br><span class="line">    movq    %rax, (%rdi)    # Store lower 8 bytes at dest</span><br><span class="line">    movq    %rdx, 8(%rdi)   # Store upper 8 bytes at dest+8</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>除法和取模操作是由单操作数指令提供的。有符号除法指令<code>idivl</code>将寄存器<code>%rdx</code>（高64位）和<code>%rax</code>（低64位）中的128位数作为被除数，而除数作为指令的操作数。指令将商存储在寄存器<code>%rax</code>中，将余数存储在寄存器<code>%rdx</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remdiv</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> *qp, <span class="keyword">long</span> *rp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> q = x / y;</span><br><span class="line">    <span class="keyword">long</span> r = x % y;</span><br><span class="line">    *qp = q;</span><br><span class="line">    *rp = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># remdiv</span><br><span class="line"># x in %rdi, y in %rsi, qp in %rdx, rp in %rcx</span><br><span class="line">remdiv:</span><br><span class="line">    movq    %rdx, %r8       # Copy qp</span><br><span class="line">    movq    %rdi, %rax      # Move x to lower 8 bytes of dividend </span><br><span class="line">    cqto                    # Sign-extend to upper 8 bytes of dividend</span><br><span class="line">    idivq   %rsi            # Divide by y</span><br><span class="line">    movq    %rax, (%r8)     # Store quotient at qp</span><br><span class="line">    movq    %rdx, (%rcx)    # Store remainder at rp</span><br></pre></td></tr></table></figure>
<h2 id="控制"><a class="markdownIt-Anchor" href="#控制"></a> 控制</h2>
<p>与数据相关的控制流是hi先有条件行为的常见方法。</p>
<h3 id="条件码"><a class="markdownIt-Anchor" href="#条件码"></a> 条件码</h3>
<ul>
<li>CF: 进位标志。最近的操作使得最高位产生了进位。可用来检查无符号操作的溢出。</li>
<li>ZF：零标志。最近的操作得出的结果为 0 。</li>
<li>SF：符号标志。最近的操作得到的结果为负数。</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。</li>
</ul>
<p>假设<code>t=a+b</code>，数值对应条件码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CF  (unsigned) t &lt; (unsigned) a     无符号溢出</span><br><span class="line">ZF  (t == 0)                        零</span><br><span class="line">SF  (t &lt; 0)                         负数</span><br><span class="line">OF  (a&lt;0==b&lt;0) &amp;&amp; (t&lt;0!=a&lt;0)        有符号溢出                </span><br></pre></td></tr></table></figure>
<p><code>leaq</code>指令不改变条件码。因为它是用来进行地址计算的。除此之外的算数和逻辑操作均可能设置条件码。对于逻辑操作，例如<code>XOR</code>，进位标志和溢出标志会被设置为0。对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0。<code>INC</code>和<code>DEC</code>指令会设置溢出和零标志，但是不会改变进位标志。</p>
<p>两类指令，<code>cmp</code> 与 <code>test</code> 会设置条件码，且不改变任何其他寄存器。<code>cmp</code>类似于<code>sub</code>，而<code>test</code>类似于<code>AND</code>，其后缀同样有<code>bwlq</code>之分。例如，用<code>cmpq %rsi, %rdi</code>，计算<code>%rdi - %rsi</code>，若<code>%rdi &lt; %rsi</code>，则SF为1。</p>
<h3 id="访问条件码"><a class="markdownIt-Anchor" href="#访问条件码"></a> 访问条件码</h3>
<p>条件码的常见使用方法有三种</p>
<ol>
<li>根据条件码的某种组合，将一个字节设置为0或1</li>
<li>条件跳转</li>
<li>有条件地传输数据</li>
</ol>
<p>对于第一种情况，有<code>SET</code>指令。其后缀与操作数大小无关，而是考虑不同组合。一条<code>SET</code>指令的目的操作数是低位单字节寄存器元素之一，或单字节内存位置。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>同义名</th>
<th>效果</th>
<th>设置条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sete</code>   D<br><code>setne</code>  D</td>
<td><code>setz</code><br><code>setnz</code></td>
<td>D&lt;-ZF<br>D&lt;- -ZF</td>
<td>相等/零<br>不相等/非零</td>
</tr>
<tr>
<td><code>sets</code>    D<br><code>setns</code>   D</td>
<td><code>sets</code><br><code>setns</code></td>
<td>D&lt;-SF<br>D&lt;- -SF</td>
<td>负数<br>非负数</td>
</tr>
<tr>
<td><code>setg</code>    D<br><code>setge</code>  D<br><code>setl</code>    D<br><code>setle</code>  D</td>
<td><code>setnle</code><br><code>setnl</code><br><code>setnge</code><br><code>setng</code></td>
<td>D&lt;- ~(SF ^ OF) &amp; -ZF<br>D&lt;- ~(SF ^ OF)<br>D&lt;- SF ^ OF<br>D&lt;- (SF ^ OF) | ZF</td>
<td>大于（有符号&gt;）<br> 大于等于（有符号 ≥）<br>小于（有符号&lt;）<br> 小于等于（有符号 ≤）</td>
</tr>
<tr>
<td><code>seta</code>    D<br><code>setae</code>  D<br><code>setb</code>     D<br><code>setbe</code>  D</td>
<td><code>setnbe</code><br><code>setnb</code><br><code>setnae</code><br><code>setna</code></td>
<td>D&lt;- ~CF &amp; ~ZF<br>D&lt;- ~CF<br>D&lt;- CF<br>D&lt;- CF | ZF</td>
<td>超过（无符号&gt;）<br>超过或相等（无符号 ≥）<br>低于（无符号&lt;）<br>低于或相等（无符号≤）</td>
</tr>
</tbody>
</table>
<p>如下演示了 <code>a &lt; b</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># a in %rdi, b in %rsi</span><br><span class="line">comp:</span><br><span class="line">    cmpq    %rsi, %rdi</span><br><span class="line">    setl    %al</span><br><span class="line">    movzbl  %al, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h3 id="跳转指令"><a class="markdownIt-Anchor" href="#跳转指令"></a> 跳转指令</h3>
<p>跳转（jump）指令改变程序执行的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    movq    $0, %rax</span><br><span class="line">    jmp     .L1</span><br><span class="line">    movq    (%rax), %rdx</span><br><span class="line">.L1</span><br><span class="line">    popq    %rdx</span><br></pre></td></tr></table></figure>
<p>指令<code>jmp .L1</code>会跳转到标号<code>.L1</code>处继续执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将<strong>跳转目标</strong>（目的指令地址）编码为跳转指令的一部分。</p>
<p>跳转可以是<strong>直接跳转</strong>，即跳转目标是作为指令一部分编码；也可以是<strong>间接跳转</strong>，即跳转目标是从寄存器或内存位置中读出的。直接跳转以标号，例如<code>.L1</code>为目标跳转。而间接跳转使用<code>*</code>+操作数指示符作为目标，例如<code>jmp %rax</code>将寄存器<code>%rax</code>的值作为目标，<code>jmp (%rax)</code>将地址<code>(%rax)</code>作为目标。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>同义名</th>
<th>跳转条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jmp</code>  Label<br><code>jmp</code>  *Operand</td>
<td></td>
<td>1<br>1</td>
<td>直接跳转<br>间接跳转</td>
</tr>
<tr>
<td><code>je</code>   Label<br><code>jne</code>  Label</td>
<td><code>jz</code><br><code>jnz</code></td>
<td>ZF<br>~ZF</td>
<td>相等/零<br>不相等/非零</td>
</tr>
<tr>
<td><code>js</code>   Label<br><code>jns</code>  Label</td>
<td></td>
<td>SF<br>~SF</td>
<td>负数<br>非负数</td>
</tr>
<tr>
<td><code>jg</code>   Label<br><code>jge</code>  Label<br><code>jl</code>   Label<br><code>jle</code>  Label</td>
<td><code>jnle</code><br><code>jnl</code><br><code>jnge</code><br><code>jng</code></td>
<td>~(SF ^ OF) &amp; ~ZF<br> ~(SF ^ OF)<br> SF ^ OF<br>(SF ^ OF) | ZF</td>
<td>大于（有符号&gt;）<br>大于或等于（有符号 ≥）<br> 小于（有符号）<br> 小于或等于（有符号≤）</td>
</tr>
<tr>
<td><code>ja</code>    Label<br><code>jae</code>  Label<br><code>jb</code>    Label<br><code>jbe</code>   Label</td>
<td><code>jnbe</code><br><code>jnb</code><br><code>jnae</code><br><code>jna</code></td>
<td>~CF &amp; ~ZF<br> ~CF<br>CF <br>CF | ZF</td>
<td>超过（无符号 &gt;）<br>超过或相等（无符号 ≥）<br>低于（无符号&lt;）<br>低于或相等（无符号 ≤）</td>
</tr>
</tbody>
</table>
<p>这些跳转条件与<code>SET</code>指令的名字和设置条件是相匹配的，而条件跳转只能是直接跳转。</p>
<p>跳转基于相对寻址。它们会将目标指令的地址与紧跟在跳转指令后面的那条指令的地址之间的差作为编码。</p>
<p>如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    movq    %rdi, %rax</span><br><span class="line">    jmp     .L2</span><br><span class="line">.L3:</span><br><span class="line">    sarq    %rax</span><br><span class="line">.L2:</span><br><span class="line">    testq   %rax, %rax</span><br><span class="line">    jg      .L3</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure>
<p>汇编器产生的反汇编版本为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:  48 89 f8        mov     %rdi, %rax</span><br><span class="line">3:  eb 03           jmp     8 &lt;loop+0x8&gt;    # 注意到jmp指令后操作数为0x03</span><br><span class="line">5:  48 d1 f8        sar     %rax</span><br><span class="line">8:  48 85 c0        test    %rax, %rax</span><br><span class="line">b:  7f f8           jg      5 &lt;loop+0x5&gt;    # 注意到jmp指令后操作数为0xf8 = -8</span><br><span class="line">d:  f3 c3           repz retq</span><br></pre></td></tr></table></figure>
<p>注意到<code>0x8=0x3+0x5</code>且<code>0x-8+0xd=0x5</code>，得到结论：相对寻址时，PC的值是跳转指令后面那条指令的值，加上操作数得到跳转地址。</p>
<h3 id="用条件控制实现条件分支"><a class="markdownIt-Anchor" href="#用条件控制实现条件分支"></a> 用条件控制实现条件分支</h3>
<p>例如基于此实现一个取绝对值的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># long absdiff(long x, y)</span><br><span class="line"># x in %rdi, y in %rsi</span><br><span class="line">absdiff:</span><br><span class="line">    cmpq    %rsi, %rdi      # Compare x:y</span><br><span class="line">    jge     .L2             # If &gt;= goto x_ge_y</span><br><span class="line">    movq    %rsi, %rax</span><br><span class="line">    subq    %rdi, %rax      # result = y - x</span><br><span class="line">    ret</span><br><span class="line">.L2:</span><br><span class="line">    movq    %rdi, %rax</span><br><span class="line">    subq    %rsi, %rax      # result = x - y</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>对于C中的<code>if-else</code>语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (test-expr)</span><br><span class="line">    then-statement</span><br><span class="line">else</span><br><span class="line">    else-statement</span><br></pre></td></tr></table></figure>
<p>汇编实现类似于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    t = test-expr;</span><br><span class="line">    if (!t)</span><br><span class="line">        goto false;</span><br><span class="line">    then-statement</span><br><span class="line">    goto done;</span><br><span class="line">false:</span><br><span class="line">    else-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<h3 id="用条件传送实现条件分支"><a class="markdownIt-Anchor" href="#用条件传送实现条件分支"></a> 用条件传送实现条件分支</h3>
<p>上一条方法在现代处理器上可能会略显低效。使用条件传送指令可以实现如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># long absdiff(long x, y)</span><br><span class="line"># x in %rdi, y in %rsi</span><br><span class="line">absdiff:</span><br><span class="line">    movq    %rsi, %rax</span><br><span class="line">    subq    %rdi, %rax</span><br><span class="line">    movq    %rdi, %rdx</span><br><span class="line">    subq    %rsi, %rdx</span><br><span class="line">    cmpq    %rsi, %rdi</span><br><span class="line">    cmovge  %rdx, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p><code>CMOV</code>类指令类似于<code>SET</code>与<code>JMP</code>，后缀字母同样表示条件。<code>CMOV S, R</code>表示满足条件的情况下，使得<code>S -&gt; R</code>。</p>
<p>对于下式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = test-expr ? then-expr : else-expr;</span><br></pre></td></tr></table></figure>
<p>条件控制转移的方法，编译为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    if (!test-expr)</span><br><span class="line">        goto false;</span><br><span class="line">    v = then-expr;</span><br><span class="line">    goto done;</span><br><span class="line">false:</span><br><span class="line">    v = else-expr;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>而条件跳转类似于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = then-expr;</span><br><span class="line">ve = else-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line">if (!t) v = ve;</span><br></pre></td></tr></table></figure>
<p>但是条件跳转是具有限制的，具体略。</p>
<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<p>C语言提供了三种循环结构，<code>do-while</code>、<code>while</code>、<code>for</code>。</p>
<h4 id="do-while"><a class="markdownIt-Anchor" href="#do-while"></a> do-while</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-<span class="function">statement</span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(test-expr)</span></span></span><br></pre></td></tr></table></figure>
<p>显然可以用<code>goto</code>表示为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br></pre></td></tr></table></figure>
<p>例如，使用汇编编写一段求阶乘的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># long fact_do(long n)</span><br><span class="line"># n in %rdi</span><br><span class="line">fact_do:</span><br><span class="line">    movl    $1, eax     # set result = 1</span><br><span class="line">.L2:</span><br><span class="line">    imulq   %rdi, %rax  # Compute result *= n;</span><br><span class="line">    subq    $1, %rdi    # Decrement n</span><br><span class="line">    cmpq    $1, %rdi    # Compare n:1</span><br><span class="line">    jg      .L2         # If n &gt; 1, back to loop</span><br><span class="line">    rep; ret</span><br></pre></td></tr></table></figure>
<h4 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h4>
<p><code>while</code>是一种较为简单的循环语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">    body-statement</span><br></pre></td></tr></table></figure>
<p>与<code>do-while</code>的不同之处在于，在第一次<code>body-statement</code>之前，会对<code>test-expr</code>求值。有两种方法编译<code>while</code>，第一种是 <strong>跳转到中间（jump to middle）</strong> ，执行一个无条件跳转到循坏结尾，以执行初始的测试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">test:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    <span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>依旧编写一个阶乘函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># long fact(long n)</span><br><span class="line"># n in %rdi</span><br><span class="line">fact:</span><br><span class="line">    movl    $1, %eax    # set result = 1</span><br><span class="line">    jmp     .L5         # goto test</span><br><span class="line">.L6                     # loop:</span><br><span class="line">    imulq   %rdi, %rax  # compute result *= n</span><br><span class="line">    subq    $1, %rdi    # decrement n</span><br><span class="line">.L5                     # test:</span><br><span class="line">    cmpq    $1, %rdi    # compare n:1</span><br><span class="line">    jg      .L6         # if &gt;, goto loop</span><br><span class="line">    rep; ret            # return</span><br></pre></td></tr></table></figure>
<p>第二种方法为<strong>guarded-do</strong>，首先使用条件分支，如果不成立就更换为<code>do-while</code>循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># long fact(long n)</span><br><span class="line">fact:</span><br><span class="line">    cmpq    $1, %rdi    #compare n:1</span><br><span class="line">    jle     .L7         # if &lt;=, goto done</span><br><span class="line">    movl    $1, %eax    # set result = 1</span><br><span class="line">.L6                     # loop:</span><br><span class="line">    imulq   %rdi, %rax  # compute result *= n</span><br><span class="line">    subq    $1, %rdi    # decrement n</span><br><span class="line">    cmpq    $1, %rdi    # compare n:1</span><br><span class="line">    jne     .L6         # if !=, goto loop</span><br><span class="line">    rep; ret            # return</span><br><span class="line">.L7                     # done:</span><br><span class="line">    movl    $1, %eax    # compute result = 1</span><br><span class="line">    ret                 # return</span><br></pre></td></tr></table></figure>
<h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-expr; test-expr; update-expr)</span><br><span class="line">    body-statement</span><br></pre></td></tr></table></figure>
<p>转化为<code>while</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">&#123;</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下同<code>while</code>。</p>
<h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h3>
<p><code>switch</code>语句可以进行多重分支（multiway branching），且使用 <strong>跳转表（jump table）</strong> 提升效率。</p>
<h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2>
<p>过程在不同的编程语言中可以是 <strong>函数（function）</strong>、<strong>方法（method）</strong>、<strong>子例程（subroutine）</strong>、<strong>处理函数（handler）</strong> 。</p>
<p>假设过程P调用过程Q，Q执行后返回到P，这些动作包括下面一个或多个机制。</p>
<ul>
<li><em>传递控制</em>。在进入过程Q的时候，PC必须被设置为Q的代码的起始地址，然后返回时，要把PC设置为P中调用Q后面那条指令的地址。</li>
<li><em>传递数据</em>。P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。</li>
<li><em>分配和释放内存</em>。在开始时，Q可能需要为局部变量分配空间，而在返回时前，又必须释放这些存储空间。</li>
</ul>
<h3 id="运行时栈"><a class="markdownIt-Anchor" href="#运行时栈"></a> 运行时栈</h3>
<p>在过程P调用Q时，P以及向上的所有调用链都被暂时挂起。当Q运行时，只需要为局部变量分配新的存储空间。当Q返回时，所有栈上空间都被释放。</p>
<p>x86-64的栈向低地址方向增长。而栈指针<code>%rsp</code>指向栈顶元素。用<code>pushq</code>和<code>popq</code>指令将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似地，可以通过增加栈指针来释放空间。</p>
<p>当x86-64过程所需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的<strong>栈帧（stack frame）</strong>。<br />
<img src="https://s2.loli.net/2022/05/29/5NIPuQAy9Xwao7W.png" alt="stack.png" /></p>
<p>当P调用Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关的状态。Q的代码会扩展当前栈的边界。大多数栈帧是定长的。有一些简单函数（有时称为叶子过程）不需要栈帧。</p>
<h3 id="转移控制"><a class="markdownIt-Anchor" href="#转移控制"></a> 转移控制</h3>
<p>将控制从P转移到Q只需要把PC设置为Q代码的起始位置。但当Q返回时，CPU必须记录好需要继续执行的P的代码的位置。</p>
<p><code>call Q</code>指令记录该地址。该指令将地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>call</code>     Label</td>
<td>过程调用</td>
</tr>
<tr>
<td><code>call</code>     *Operand</td>
<td>过程调用</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>从过程调用中返回</td>
</tr>
</tbody>
</table>
<p><code>call</code>指令的操作数为被调用过程起始的指令地址。<code>ret</code>指令返回这次调用后面的那条指令。</p>
<h3 id="数据传送"><a class="markdownIt-Anchor" href="#数据传送"></a> 数据传送</h3>
<p>x86-64中，大部分过程间的数据传送是通过寄存器实现的。当P调用Q时，P的代码必须首先把参数复制到适当的寄存器中。类似地，当Q返回P时，P的代码可以访问<code>%rax</code>的返回值。</p>
<p>x86-64中，可以通过寄存器最多传送6个整型参数。如果函数有大于六个参数，超出部分就需要通过栈来传递。通过栈传递参数时，所有数据大小都向8的倍数对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># void proc(a1, a1p, a2, a2p, a3, a3p, a4, a4p)</span><br><span class="line"># argument passed as follows:</span><br><span class="line">#   a1  in %rdi</span><br><span class="line">#   a1p in %rsi</span><br><span class="line">#   a2  in %edx</span><br><span class="line">#   a2p in %rcx</span><br><span class="line">#   a3  in %r8w</span><br><span class="line">#   a3p in %r9</span><br><span class="line">#   a4  at %rsp+8</span><br><span class="line">#   a4p at %rsp+16</span><br></pre></td></tr></table></figure>
<h3 id="栈上的局部存储"><a class="markdownIt-Anchor" href="#栈上的局部存储"></a> 栈上的局部存储</h3>
<p>有些时候，数据必须存放在栈上</p>
<ul>
<li>寄存器不足够存放所有的本地数据</li>
<li>对一个局部变量使用地址运算符<code>&amp;</code>，因此必须能够为它产生一个地址</li>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。</li>
</ul>
<p>以两个函数为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">swap_add</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = *xp;</span><br><span class="line">    <span class="keyword">long</span> y = *yp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    *yp = x;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">caller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> arg1 = <span class="number">534</span>;</span><br><span class="line">    <span class="keyword">long</span> arg2 = <span class="number">1057</span>;</span><br><span class="line">    <span class="keyword">long</span> sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">    <span class="keyword">long</span> diff = arg1 - arg2;</span><br><span class="line">    <span class="keyword">return</span> sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">    subq    $16, %rsp       # allocate 16 bytes for stack frame</span><br><span class="line">    movq    $534, (%rsp)    # store 534 in arg1</span><br><span class="line">    movq    $1057, 8(%rsp)  # store 1057 in arg2</span><br><span class="line">    leaq    8(%rsp), %rsi   # compute &amp;arg2 as second argument</span><br><span class="line">    movq    %rsp, %rdi      # compute &amp;arg1 as first argument</span><br><span class="line">    call    swap_add        # call swap_add(&amp;arg1, &amp;arg2)</span><br><span class="line">    movq    (%rsp), %rdx    # get arg1</span><br><span class="line">    subq    8(%rsp), %rdx   # compute diff = arg1 - arg2</span><br><span class="line">    imulq   %rdx, %rax      # compute sum * diff</span><br><span class="line">    addq    $16, %rsp       # deallocate stack frame</span><br><span class="line">    ret                     # return</span><br></pre></td></tr></table></figure>
<h3 id="递归过程"><a class="markdownIt-Anchor" href="#递归过程"></a> 递归过程</h3>
<p>以阶乘为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># long rfact(long n)</span><br><span class="line"># n in %rdi</span><br><span class="line">rfact:</span><br><span class="line">    pushq   %rbx</span><br><span class="line">    movq    %rdi, %rbx</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    cmpq    $1, %rdi</span><br><span class="line">    jle     .L35</span><br><span class="line">    leaq    -1(%rdi), %rdi</span><br><span class="line">    call    rfact</span><br><span class="line">    imulq   %rbx, %rax</span><br><span class="line">.L35</span><br><span class="line">    popq    %rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h2 id="数组分配和访问"><a class="markdownIt-Anchor" href="#数组分配和访问"></a> 数组分配和访问</h2>
<p>C语言实现数组的方式很简单。对于<code>T A[N]</code>，它在内存中分配一个L × N字节的连续区域。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>    A[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">char</span>   *B[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span>     C[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">double</span> *D[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>即为</p>
<table>
<thead>
<tr>
<th style="text-align:center">数组</th>
<th style="text-align:center">元素大小</th>
<th style="text-align:center">总的大小</th>
<th style="text-align:center">起始地址</th>
<th style="text-align:center">元素i</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A<br>B<br>C<br>D</td>
<td style="text-align:center">1<br>8<br>4<br>8</td>
<td style="text-align:center">12<br>64<br>24<br>40</td>
<td style="text-align:center">x<sub>A</sub><br>x<sub>B</sub><br>x<sub>C</sub><br>x<sub>D</sub></td>
<td style="text-align:center">x<sub>A</sub>+i<br>x<sub>B</sub>+8i<br>x<sub>C</sub>+4i<br>x<sub>D</sub>+8i</td>
</tr>
</tbody>
</table>
<p>x86-64的内存引用指令可以用来简化数组访问。例如获取int数组第i个地址，为<code>movl (%rdx, rcx, 4), %eax</code>，其中<code>%rdx</code>为首地址，<code>rcx</code>为<code>i</code>。</p>
<p>同时，在C语言中，可以直接通过指针访问数组元素。<code>A[i]</code>等价于<code>*(A + i)</code>。对于嵌套数组或二维数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mtext>  </mtext><mi>D</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>C</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T \ \ D[R][C]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">]</span></span></span></span>，取值方式为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&amp;</mi><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>x</mi><mi>A</mi></msub><mo>+</mo><mi>L</mi><mo stretchy="false">(</mo><mi>C</mi><mo>×</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\&amp;A[i][j]=x_A+L(C \times i + j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">&amp;</span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>。</p>
<p>GCC对于定长数组有很多优化，而变长数组需要额外性能开销。</p>
<h2 id="异质数据结构"><a class="markdownIt-Anchor" href="#异质数据结构"></a> 异质数据结构</h2>
<p>主要为<code>struct</code>和<code>union</code>。</p>
<p><strong>struct</strong><br />
结构允许不同类型对象的聚合，其内存模型是连续的。指向结构的指针就是结构第一个字节的地址。编译器通过对应的字节偏移获取元素内容。</p>
<p><strong>union</strong><br />
联合允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，但它们是用不同的字段来引用相同的内存块。</p>
<h3 id="数据对齐"><a class="markdownIt-Anchor" href="#数据对齐"></a> 数据对齐</h3>
<p>许多计算机系统要求某种类型的地址必须是某个值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">K \in \{2, 4, 8\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">}</span></span></span></span> 的倍数。无论是否对齐，x86-64都能工作，但是对齐后性能更好。</p>
<p>例如汇编声明中的<code>.align 8</code>命令要求后面的数据起始地址是8的倍数。对于包含结构的代码，编译器可能会在字段的分配中插入间隙，以保证每个元素都满足它的对齐要求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adamska</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.2/dist/mermaid.min.js","integrity":"sha256-UIQPVkGifpwMvDH5yGgORJ9sSTDq38zz6BGU6dNaKhM="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha256-M6KFoDq9eUpmogkDgw6+3R3ZgUPSuFXnQyr8tskSfQs=" crossorigin="anonymous">



</body>
</html>
