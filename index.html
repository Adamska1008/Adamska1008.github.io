<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"adamska1008.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Adamska&#39;s Blog">
<meta property="og:url" content="https://adamska1008.github.io/index.html">
<meta property="og:site_name" content="Adamska&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adamska">
<meta property="article:tag" content="算法竞赛, Modern C++, JVM, Kotlin, GoLang, Rust, Basic CS knowledge">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://adamska1008.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Adamska's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Adamska's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adamska</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/30/algorithm-dynamic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/30/algorithm-dynamic-programming/" class="post-title-link" itemprop="url">算法-DP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-30 19:54:04 / 修改时间：20:00:22" itemprop="dateCreated datePublished" datetime="2022-06-30T19:54:04+08:00">2022-06-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>包括了一些DP的常见题型的应对方法。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/30/algorithm-dynamic-programming/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/22/study-notes-Computer-Network-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/22/study-notes-Computer-Network-1/" class="post-title-link" itemprop="url">计算机网络笔记（一）-计算机网络概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-22 23:42:04" itemprop="dateCreated datePublished" datetime="2022-06-22T23:42:04+08:00">2022-06-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-28 19:37:09" itemprop="dateModified" datetime="2022-06-28T19:37:09+08:00">2022-06-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">《计算机网络：自顶向下方法》学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第一章：计算机网络概述</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/22/study-notes-Computer-Network-1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/22/algorithm-graph-practise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/22/algorithm-graph-practise/" class="post-title-link" itemprop="url">算法-图论-专题练习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-22 10:36:54" itemprop="dateCreated datePublished" datetime="2022-06-22T10:36:54+08:00">2022-06-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-28 19:52:22" itemprop="dateModified" datetime="2022-06-28T19:52:22+08:00">2022-06-28</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>目前共计 6 道题。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/22/algorithm-graph-practise/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/21/algorithm-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/21/algorithm-graph/" class="post-title-link" itemprop="url">算法-图论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-21 21:03:11" itemprop="dateCreated datePublished" datetime="2022-06-21T21:03:11+08:00">2022-06-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-30 21:51:01" itemprop="dateModified" datetime="2022-06-30T21:51:01+08:00">2022-06-30</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>包括了图论的一些常用算法的定义、说明、代码实现。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/21/algorithm-graph/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/06/study-notes-CSAPP-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/06/study-notes-CSAPP-8/" class="post-title-link" itemprop="url">CSAPP笔记（八）—— 虚拟内存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-06 17:29:52 / 修改时间：17:30:31" itemprop="dateCreated datePublished" datetime="2022-06-06T17:29:52+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/04/study-notes-OSTEP-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/04/study-notes-OSTEP-4/" class="post-title-link" itemprop="url">OSTEP笔记（四）—— 持久性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-04 15:17:31" itemprop="dateCreated datePublished" datetime="2022-06-04T15:17:31+08:00">2022-06-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-28 10:21:40" itemprop="dateModified" datetime="2022-06-28T10:21:40+08:00">2022-06-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OSTEP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">OSTEP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><em>Three easy pieces: 虚拟化，并发，持久性</em></p>
<p>本段内容包括I/O结构，磁盘结构，RAID，文件结构的实现与崩溃恢复。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/04/study-notes-OSTEP-4/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/03/study-notes-CSAPP-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/study-notes-CSAPP-7/" class="post-title-link" itemprop="url">CSAPP笔记（七）—— 异常控制流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 20:54:27" itemprop="dateCreated datePublished" datetime="2022-06-03T20:54:27+08:00">2022-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-06 17:17:41" itemprop="dateModified" datetime="2022-06-06T17:17:41+08:00">2022-06-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序计数器假设一个值的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_0, a_1, ··· ,a_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6527810000000001em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 其中，每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是某个相应的指令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">I_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的地址，每次从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 的过渡称为<strong>控制转移（control transfer）</strong>，这样的控制转移序列叫作处理器的<strong>控制流(control flow)</strong>。</p>
<p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。现代系统通过使控制流发生突变来对这些情况作出反应。一般而言，称之为<strong>异常控制流（Exceptional Control Flow, ECF）</strong> 。</p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<p><strong>异常（exception）</strong> 就是控制流中的突变。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件（event）</strong> 。</p>
<p>任何情况下，当处理器检测到有事件发生时，它就会通过<strong>异常表（exception table）</strong> 的跳转表进行一个间接过程调用，到<strong>异常处理程序（exception handler）</strong> 处理这些异常。当异常处理完之后，可能发生以下情况：</p>
<ol>
<li>将控制返回给指令 I<sub>curr</sub>。</li>
<li>将控制返回给 I<sub>next</sub>。</li>
<li>处理程序终止被中断的程序。</li>
</ol>
<h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3>
<p>系统中可能的异常都被分配了<strong>异常号（exception number）</strong> ，一些由处理器设计，一些由操作系统设计。</p>
<p>在系统启动时，初始化一场表，对于检测的事件，通过异常表跳转到相应的处理程序。</p>
<p>异常处理与过程调用的不同：</p>
<ul>
<li>返回地址</li>
<li>压入额外状态，如EFFLAGS寄存器</li>
<li>如果控制转移到内核，则所有项目都被压到内核栈中</li>
<li>异常处理程序运行在内核模式下</li>
</ul>
<p>通过从中断返回指令，就可以返回到程序中。如果异常中断了用户程序，就返回到用户态。</p>
<h3 id="异常的类别"><a class="markdownIt-Anchor" href="#异常的类别"></a> 异常的类别</h3>
<p>分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自I/O设备的信号</td>
<td>异步</td>
<td>总是返回到下一步指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一步指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
<h4 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h4>
<p>中断是来自I/O设备信号的结果，它是异步发生的。</p>
<h4 id="陷阱"><a class="markdownIt-Anchor" href="#陷阱"></a> 陷阱</h4>
<p>陷阱是有意的异常。陷阱最重要的作用是提供系统调用。当用户程序需要请求系统调用时，执行<code>syscall</code>，导致一个陷阱。通过陷阱，用户可以使用内核模式。</p>
<h4 id="故障"><a class="markdownIt-Anchor" href="#故障"></a> 故障</h4>
<p>故障由错误引起，但是可能被故障处理程序修正。如果能修正，就将控制返回，并重新执行，否则返回到<code>abort</code>进程。例如缺页异常。</p>
<h4 id="终止"><a class="markdownIt-Anchor" href="#终止"></a> 终止</h4>
<p>例如SRAM或DRAM损坏发生的奇偶错误，无法恢复。</p>
<h2 id="故障-2"><a class="markdownIt-Anchor" href="#故障-2"></a> 故障</h2>
<p>异常允许提供<strong>进程（process）<strong>概念。系统中的每个程序都运行在某个进程的</strong>上下文（context）</strong> 中。上下文是由程序正确运行所需的状态组成的。进程提供了两个假象：</p>
<ul>
<li>一个独立的逻辑控制流</li>
<li>一个私有的地址空间</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/03/study-notes-CSAPP-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/study-notes-CSAPP-6/" class="post-title-link" itemprop="url">CSAPP笔记（六）—— 链接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 15:39:35" itemprop="dateCreated datePublished" datetime="2022-06-03T15:39:35+08:00">2022-06-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-14 13:24:01" itemprop="dateModified" datetime="2022-06-14T13:24:01+08:00">2022-06-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>链接（linking）</strong> 将各种代码和数据片段收集并组合为一个单一文件。这个文件可以被加载到内存并执行。链接可以执行于编译时（compile time），加载时（load time）甚至运行时（run time）。</p>
<h2 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h2>
<p><strong>静态连接器（static linker）</strong> 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件为输出。输入的可重定位目标文件由各种不同的代码和数据节（section）构成。</p>
<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li><strong>符号解析（symbol resolution）</strong>。目标文件定义和引用符号，每个符号对应一个函数、全局变量或静态变量。符号解析将每个符号引用和符号定义关联起来。</li>
<li><strong>重定位（relocation）</strong>。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，而重定位这些节，然后修改符号引用，使得它们指向这个内存位置。</li>
</ul>
<h2 id="目标文件"><a class="markdownIt-Anchor" href="#目标文件"></a> 目标文件</h2>
<p>目标文件有三种形式</p>
<ul>
<li><strong>可重定位目标文件</strong>。</li>
<li><strong>可执行目标文件</strong>。</li>
<li><strong>共享目标文件</strong>。较为特殊，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件与共享目标文件，链接器生成可执行目标文件。一个<strong>目标模块（object module）</strong> 就是一个字节序列，而一个<strong>目标文件（object file）</strong> 就是一个以文件形式存放在磁盘中的目标模块。x86-64 Linux和Unix使用<strong>可执行可链接格式（Executable and Linkable Format, ELF）</strong> 。</p>
<h3 id="可重定位目标文件"><a class="markdownIt-Anchor" href="#可重定位目标文件"></a> 可重定位目标文件</h3>
<p><img src="https://s2.loli.net/2022/06/03/abRD7xsMc9HQzlp.png" alt="7-3.png" /></p>
<p>ELF头以一个16字节的序列开始，描述了生成该文件的操作系统的字的大小和字节顺序。剩下的部分包括ELF头的大小、目标文件的类型、机器类型、节头部表和文件偏移。夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包括：</p>
<ul>
<li><code>.text</code>：已编译程序的机器代码</li>
<li><code>.rodata</code>：只读数据，比如<code>printf</code>语句中的格式串和开关语句的跳转表</li>
<li><code>.data</code>：已初始化的全局和静态C变量。</li>
<li><code>.bss</code>：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中，这个节仅仅是一个占位符，不占据实际的空间。区分是否初始化，是为了空间效率。</li>
<li><code>.symtab</code>：一个符号表，存放程序中定义和引用的函数和全局变量的信息。</li>
<li><code>.rel.text</code>：一个<code>.text</code>节中，位置的列表。当链接器把这个目标文件和其他文件组合时，需要修改这些位置。可执行目标文件中并不需要，因此通常省略。</li>
<li><code>.rel.data</code>：被模块引用或定义的所有全局变量的重定位信息。</li>
<li><code>.debug</code>：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量以及原始的C源文件。必须使用<code>-g</code>编译才会有。</li>
<li><code>.line</code>：原始C源代码中的行号和<code>.text</code>机器指令之间的映射。必须使用<code>-g</code>编译才会有。</li>
<li><code>.strtab</code>：字符串表。</li>
</ul>
<h2 id="符号和符号表"><a class="markdownIt-Anchor" href="#符号和符号表"></a> 符号和符号表</h2>
<p>在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由模块m定义并能被其他模块引用的全局符号。</li>
<li>由其他模块定义并被模块m引用的全局符号。</li>
<li>只被模块m定义和引用的局部符号。</li>
</ul>
<p>带有<code>static</code>属性的本地过程变量不在栈中管理，而处于<code>.data</code>或<code>.bss</code>中，并在符号表中创建一个有唯一名字的本地链接器符号。</p>
<h2 id="符号解析"><a class="markdownIt-Anchor" href="#符号解析"></a> 符号解析</h2>
<p>链接器解析符号引用时，将每个引用与它输入的ELF中的符号表的一个确定的符号定义关联起来。对于引用和定义在相同模块里的局部符号的引用，比较容易。</p>
<p>但全局符号不同。当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他模块中定义的，生成一个链接器符号表条目，并交给链接器处理。如果在任何输入模块中都找不到，则报错。</p>
<h3 id="解析多重定义的全局符号"><a class="markdownIt-Anchor" href="#解析多重定义的全局符号"></a> 解析多重定义的全局符号</h3>
<p>如果多个模块定义同名的全局符号，则针对符号的强弱性质（强：函数或初始化变量；弱：未初始化变量），有下面的规则：</p>
<ul>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号</li>
<li>如果有多个弱符号同名，则任意选择。</li>
</ul>
<h3 id="与静态库链接"><a class="markdownIt-Anchor" href="#与静态库链接"></a> 与静态库链接</h3>
<p>将所有相关的目标模块打包成为一个单独的文件，称为<strong>静态库（static library）</strong> 。</p>
<p>在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小，也方便程序员包含库文件。在Linux系统中，静态库作为**存档（archive）**文件存放在磁盘中。</p>
<h3 id="静态库解析引用"><a class="markdownIt-Anchor" href="#静态库解析引用"></a> 静态库解析引用</h3>
<p>在符号解析阶段，链接器逐个解析目标文件或存档文件。</p>
<p>记一个可重定位目标文件集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，未解析符号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>，以及已定义符号集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>。在扫描过程中：</p>
<ul>
<li>对每个输入文件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>，链接器判断其为目标文件还是存档文件。目标文件则添加至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，修改<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>。</li>
<li>如果是存档文件，则尝试匹配<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>中未解析符号。如果某个存档文件成员<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>定义了对应符号，则将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>并修改<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>。</li>
<li>如果最后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>非空，则报错并终止。</li>
</ul>
<p>在这种算法下，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析。</p>
<h2 id="重定位"><a class="markdownIt-Anchor" href="#重定位"></a> 重定位</h2>
<p>一旦链接器完成了符号解析，就可以开始重定位。重定位由两部分组成：</p>
<ul>
<li><em>重定位节和符号定义</em>。 链接器将所有相同类型的节合并为同一类型的新的聚合节，例如合并所有的<code>.data</code>。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节和符号。</li>
<li><em>重定位节中的符号引用</em>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。这依赖于<strong>重定位条目（relocation entry）</strong> 。</li>
</ul>
<h3 id="重定位条目"><a class="markdownIt-Anchor" href="#重定位条目"></a> 重定位条目</h3>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。当汇编器遇到位置的目标引用，就会生成重定位条目，存放在<code>.rel.text</code>和<code>.rel.data</code>中。</p>
<p>重定位条目的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;        <span class="comment">// Offset of the reference to relocate</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>,       <span class="comment">// Relocation type</span></span><br><span class="line">         symbol:<span class="number">32</span>;     <span class="comment">// Symbol table index</span></span><br><span class="line">    <span class="keyword">long</span> addend;        <span class="comment">// Constant part of relocation expression</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p><code>Offset</code>是需要被修改的节引用偏移量，<code>symbol</code>表示被修改引用应该指向的符号，<code>type</code>告知链接器如何修改新的引用，一些类型的重定位使用<code>addend</code>对被修改引用的值作偏移调整。</p>
<p>有两种最基本的重定位类型：</p>
<ul>
<li><code>R_X86_64_PC32</code>：重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距PC的当前运行值的偏移量。CPU用指令中编码的32位值加上PC的值，得到有效地址。</li>
<li><code>R_x86_64_32</code>：绝对地址。不需要修改。</li>
</ul>
<h3 id="重定位符号引用"><a class="markdownIt-Anchor" href="#重定位符号引用"></a> 重定位符号引用</h3>
<p>假设每个节为<code>s</code>，每个节相关联的重定位条目为<code>r</code>，重定位算法可以用伪代码表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">    foreach relocation entry r &#123;</span><br><span class="line">        refptr = s + r.offset; // ptr to reference to be relocated</span><br><span class="line"></span><br><span class="line">        if (r.type == R_X86_64_PC32) &#123;</span><br><span class="line">            refaddr = ADDR(s) + r.offset;</span><br><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (r.type == R_X86_64_32)</span><br><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如如下反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">    0:  48 83 ec 08             sub     $0x8, %rsp</span><br><span class="line">    4:  be 02 00 00 00          mov     $0x2, %esi</span><br><span class="line">    9:  bf 00 00 00 00          mov     $0x0, %edi          %edi = &amp;array</span><br><span class="line">                        a: R_X86_64_32 array                Relocation entry</span><br><span class="line"></span><br><span class="line">    e:  e8 00 00 00 00          callq 13&lt;main+0x13&gt;         sum()</span><br><span class="line">                        f: R_X86_64_PC32 sum-0x4            Relocation entry</span><br><span class="line">    13: 48 83 c4 08             add     $0x8, %rsp</span><br><span class="line">    17: c3                      retq</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数引用了两个全局符号：<code>array</code>和<code>sum</code>。为每个引用，汇编器产生一个重定位条目，显示在引用后面的一行上。</p>
<h4 id="重定位pc相对引用"><a class="markdownIt-Anchor" href="#重定位pc相对引用"></a> 重定位PC相对引用</h4>
<p>以<code>sum</code>为例，相对应的重定位条目<code>r</code>为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span></span><br><span class="line">r.symbol = sum</span><br><span class="line">r.type = R_x86_64_PC32</span><br><span class="line">r.addend = <span class="number">-4</span></span><br></pre></td></tr></table></figure>
<p><code>call</code>指令开始于节偏移<code>0xe</code>的地方，这些字段告诉链接器修改位于<code>0xf</code>处的32位PC相对引用。假设有<code>ADDR(s) = ADDR(.text) = 0x4004d0</code>，重定位后代码段的实际地址是<code>0x4004d0</code> 和 <code>ADDR(r.symbol) = ADDR(sum) = 0x4004e8</code>，需要调用的<code>sum</code>地址是<code>0x400e8</code></p>
<p>根据算法，首先算出引用的运行时地址，显然是<code>0x4004df</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refaddr = ADDR(s) + r.offset</span><br><span class="line">        = <span class="number">0x4004d0</span> + <span class="number">0xf</span></span><br><span class="line">        = <span class="number">0x4004df</span></span><br></pre></td></tr></table></figure>
<p>然后，更新该引用，使得它在运行时指向sum程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr = (<span class="keyword">unsigned</span>)(ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x4004e8</span>       + (<span class="number">-4</span>)     - <span class="number">0x4004df</span>)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x5</span>)</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4004de:     e8 05 00 00 00          callq   4004e8 &lt;sum&gt; </span><br></pre></td></tr></table></figure>
<p>执行<code>call</code>指令时，PC为<code>0x4004e3</code>，先把PC压入栈中，随后相对寻址PC = PC + 0x5，得到<code>sum</code>第一条指令的地址。</p>
<h4 id="重定位绝对引用"><a class="markdownIt-Anchor" href="#重定位绝对引用"></a> 重定位绝对引用</h4>
<p>以<code>array</code>为例，<code>mov</code>指令开始于<code>0x9</code>，对应重定位条目<code>r</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xa</span></span><br><span class="line">r.symbol = <span class="built_in">array</span></span><br><span class="line">r.type   = R_X86_64_32</span><br><span class="line">r.addend = <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p>假设有<code>ADDR(r.symbol) = ADDR(array) = 0x601018</code>，则直接修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr = (<span class="keyword">unsigned</span>)(ADDR(r.symbol) + r.addend)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x601018</span>       + <span class="number">0</span>)</span><br><span class="line">        = (<span class="keyword">unsigned</span>)(<span class="number">0x601018</span>)</span><br></pre></td></tr></table></figure>
<p>故原指令重定位为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4004</span>d9:     bf <span class="number">18</span> <span class="number">10</span> <span class="number">60</span> <span class="number">00</span>          mov     $<span class="number">0x601018</span>, %edi</span><br></pre></td></tr></table></figure>
<h2 id="可执行目标文件"><a class="markdownIt-Anchor" href="#可执行目标文件"></a> 可执行目标文件</h2>
<p><img src="https://s2.loli.net/2022/06/05/ZxtY869l7IHJaG1.png" alt="7-13.png" /></p>
<p>相较于可重定位目标文件，ELF头中包含了程序的<em>入口点（entry point）</em>，不需要<code>.rel</code>节，</p>
<p>要加载可执行目标文件，可以直接运行。通过<strong>加载器（loader）</strong> 可以运行程序。使用<code>execve</code>等函数可以调用加载器。将程序复制到内存并运行，称作加载。</p>
<p>每个程序都有运行时内存映像。</p>
<h2 id="动态共享链接库"><a class="markdownIt-Anchor" href="#动态共享链接库"></a> 动态共享链接库</h2>
<p><strong>共享库（shared library）</strong> 是一个目标模块，在运行或加载时，可以加载到任意内存地址，并和一个在内存中的程序链接。这个过程称为<strong>动态链接（dynamic linking）</strong> ，是由<strong>动态链接器（dynamic linker）</strong> 来执行的。</p>
<p><img src="https://s2.loli.net/2022/06/03/HlouNzSfXPjQdhI.png" alt="7-16.png" /></p>
<p>共享库以两种不同方式来共享。所有引用共享库的可执行目标文件共享一个动态链接库文件。在内存中，一个库的<code>.text</code>节可以被不同进程共享。动态链接器完成以下链接任务：</p>
<ul>
<li>重定位<code>.so</code>的文本和数据到某个内存段</li>
<li>重定位程序中对<code>.so</code>定义的符号引用</li>
</ul>
<p>当程序中主动调用动态链接库时，引入代码段和数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/02/study-notes-CSAPP-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/02/study-notes-CSAPP-5/" class="post-title-link" itemprop="url">CSAPP笔记（五）—— 存储器层次结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-02 19:41:56" itemprop="dateCreated datePublished" datetime="2022-06-02T19:41:56+08:00">2022-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-03 15:39:40" itemprop="dateModified" datetime="2022-06-03T15:39:40+08:00">2022-06-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>存储器系统（memory system）</strong> 是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。靠近CPU的<strong>高速缓存存储器（cache memory）</strong> 作为一部分存储在相对慢速的<strong>主存储器（main memory）</strong> 中数据和指令的缓冲区域。主存缓存磁盘上的数据。</p>
<p>计算机程序有称为<strong>局部性（locality）</strong> 的属性。具有良好局部性的程序倾向于访问邻近的数据项集合。</p>
<h2 id="存储技术"><a class="markdownIt-Anchor" href="#存储技术"></a> 存储技术</h2>
<h3 id="随机访问存储器random-access-memory"><a class="markdownIt-Anchor" href="#随机访问存储器random-access-memory"></a> 随机访问存储器（Random-Access Memory）</h3>
<p>随机访问存储器分为两类：静态的（SRAM）和动态(DRAM)的。</p>
<ul>
<li>SRAM将每个位存储在一个<strong>双稳态的（bistable）</strong> 存储器单元里。这个电路可以无限期地保持在两个不同的电压配置或状态之一。其他任何状态都是不稳定的。</li>
<li>DRAM将每个位存储为对一个电容的充电。与SRAM不同，DRAM对干扰非常敏感。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">每位晶体管数</th>
<th style="text-align:center">相对访问时间</th>
<th style="text-align:center">持续的？</th>
<th style="text-align:center">敏感的？</th>
<th style="text-align:center">相对花费</th>
<th style="text-align:center">应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SRAM</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1×</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">1000×</td>
<td style="text-align:center">高速缓存存储器</td>
</tr>
<tr>
<td style="text-align:center">DRAM</td>
<td style="text-align:center">1</td>
<td style="text-align:center">10×</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">1×</td>
<td style="text-align:center">主存，帧缓冲区</td>
</tr>
</tbody>
</table>
<h4 id="传统的dram"><a class="markdownIt-Anchor" href="#传统的dram"></a> 传统的DRAM</h4>
<p>DRAM芯片中的单元（位）被分成了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 个<strong>超单元（supercell）</strong> ，每个超单元都由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 个DRAM单元组成。一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>×</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">d \times w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的DRAM总共存储了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">dw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位信息。超单元被组织成一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 列的长方形阵列，这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>c</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">rc=d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 。每个超单元有形如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的地址。这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 表示行，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 表示列。</p>
<p><img src="https://s2.loli.net/2022/06/03/mf1cZe6LCxIMXz5.png" alt="6-1.png" /></p>
<p>信息通过称为<strong>引脚（pin）</strong> 的外部连接器流入和流出芯片。每个引脚携带一个1位的信号。每个DRAM芯片被连接到<strong>内存控制器（memory controller）</strong> 电路。这个电路可以一次传送 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位到每个DRAM芯片或一次从每个DRAM芯片传出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位。</p>
<p>为了读出超单元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的内容，内存控制器将行地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，列地址<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>逐次发给DRAM。DRAM把超单元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的内容发回给控制器作为响应。行地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 称为<strong>RAS(Row Access Strobe，行访问选通脉冲)</strong> 请求。列地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 称为<strong>CAS（Column Access Strobe，列访问选通脉冲）</strong> 请求。二者共享相同的DRAM地址引脚。</p>
<p>DRAM在响应时，首先根据RAS将整行内容复制到内部行缓冲区，然后根据CAS选取对应的超单元，并将其发送到内存控制器。</p>
<p>通过将DRAM组织成二维阵列而不是线性数组，可以降低芯片上地址引脚的数量。</p>
<h4 id="内存模块"><a class="markdownIt-Anchor" href="#内存模块"></a> 内存模块</h4>
<p>DRAM芯片封装在<strong>内存模块（memory module）</strong> 中。</p>
<p><img src="https://s2.loli.net/2022/06/03/osT6pDy8a2lxh7d.png" alt="6-2.png" /></p>
<p>图中，用相应超单元地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的8个超单元来表示主存中字节地址A处的64位字。要取出数据，内存控制器将A转换成一个超单元地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，并将它发送到内存模块，然后内存模块再将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 广播到每个DRAM。作为响应，每个DRAM输出它对应超单元的8位内容，模块中的电路手机输出并合成64位字。</p>
<h4 id="增强的dram"><a class="markdownIt-Anchor" href="#增强的dram"></a> 增强的DRAM</h4>
<p>略</p>
<h4 id="非易失性存储器"><a class="markdownIt-Anchor" href="#非易失性存储器"></a> 非易失性存储器</h4>
<p>如果断电，DRAM和SRAM会丢失它们的信息，所以它们是 <strong>易失的（volatile）</strong> 。另一方面，非易失性存储器（nonvolatile memory）即使是在关电后，仍然保存信息。由于历史原因，被称为<strong>只读存储器（Read-Only Memory, ROM）</strong>，常见如下：</p>
<ul>
<li>PROM(Programmable ROM，可编程ROM)只能被编程一次。</li>
<li>可擦写可编程ROM(Erasable Programmable ROM)。</li>
<li>闪存(flash memory)。</li>
</ul>
<p>存储在ROM设备中的程序通常被称为固件(firmware)，如BIOS。</p>
<h4 id="访问主存"><a class="markdownIt-Anchor" href="#访问主存"></a> 访问主存</h4>
<p>数据流通过<strong>总线(bus)</strong> 的共享电子电路在处理器和DRAM主存之间来来回回。每次数据传送通过一系列步骤完成，称为<strong>总线事务（bus transaction）</strong>，包括<strong>读事务（read transaction）</strong> 和 <strong>写事务（write transaction）</strong> 。</p>
<p>总线是一组并行的导线，能携带地址、数据和控制信号。</p>
<p><img src="https://s2.loli.net/2022/06/03/S1oW9HZTmEIcMPB.png" alt="6-3.png" /></p>
<p>在如上计算机系统中，有CPU芯片、I/O桥、主存三部分。这些部件由一对总线连接起来。考虑当CPU执行指令<code>movq A, %rax</code>时，CPU芯片上的<strong>总线接口（bus interface）</strong> 发起读事务，这分为三部分：</p>
<ol>
<li>CPU将地址A放到系统总线上，I/O桥将信号传递到内存总线。</li>
<li>主存从总线读出A，从DRAM读出数据字，并写入内存总线，I/O桥将内存总线信号翻译为系统总线信号</li>
<li>CPU从总线上读数据，复制到寄存器%rax。</li>
</ol>
<h3 id="磁盘存储"><a class="markdownIt-Anchor" href="#磁盘存储"></a> 磁盘存储</h3>
<p>磁盘速度远慢于主存。</p>
<h4 id="磁盘构造"><a class="markdownIt-Anchor" href="#磁盘构造"></a> 磁盘构造</h4>
<p>磁盘由<strong>盘片（platter）</strong> 构成，每个盘片有两面（surface）。盘片中央有一个可旋转的<strong>主轴（spindle）</strong> ，使得盘片旋转，通常为5400~15000转每分钟。</p>
<p><img src="https://s2.loli.net/2022/06/03/9qGzwx4PADmOEju.png" alt="6-4.png" /></p>
<p>每个表面由一组称为<strong>磁道(track)</strong> 的同心圆组成。每个磁道被划分为一组<strong>扇区(sector)</strong>，每个扇区包含相等数量的数据为（通常是512字节）。间隙存储用来表示扇区的格式化位。</p>
<p>磁盘是由一个或多个叠放在一起的盘片组成的。整个装置通常被称为<strong>磁盘驱动器（disk driver）</strong>，简称为<strong>磁盘（disk）</strong> 。</p>
<p>术语<strong>柱面（cylinder）</strong> 是所有盘片表面上到注重中心举例相等的磁道的集合。</p>
<h4 id="磁盘容量"><a class="markdownIt-Anchor" href="#磁盘容量"></a> 磁盘容量</h4>
<p>一个磁盘上可以记录的最大位数称为它的<em>最大容量</em>，或简称为<em>容量</em>。这由许多技术因素决定。简单地说，磁盘容量可以由以下公式计算：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">盘</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">量</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">平</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">面</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">表</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">盘</mi><mi mathvariant="normal">片</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi mathvariant="normal">盘</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">数</mi></mrow><mrow><mi mathvariant="normal">磁</mi><mi mathvariant="normal">盘</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">磁盘容量=\cfrac{字节数}{扇区}\times \cfrac{平均扇区数}{磁道}\times \cfrac{磁道数}{表面}\times \cfrac{表面数}{盘片}\times \cfrac{盘片数}{磁盘}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">面</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">片</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">盘</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">片</span><span class="mord cjk_fallback">数</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<h4 id="磁盘操作"><a class="markdownIt-Anchor" href="#磁盘操作"></a> 磁盘操作</h4>
<p>磁盘用<strong>读/写头（read/write head）</strong> 来读写存储在磁性表面上的位。读写头连接到一个传动臂一端，定位到磁盘的任何磁道上，这样的机械运动被称为<strong>寻道(seek)</strong> 。其极为精细，故为避免读写头冲撞灰尘，磁盘总是密封包装的。</p>
<p>磁盘以扇区大小的块来读写数据。对扇区的<strong>访问时间（access time）</strong> 有三个主要的部分：<strong>寻道时间（seek time）</strong>、<strong>旋转时间（rotational latency）</strong>、<strong>传送时间（transfer time）</strong> 。</p>
<ul>
<li>寻道时间：传动臂首先将读/写头定位到包含目标扇区的磁道上。移动传动臂所需要的时间称为寻道时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{seek}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。通常一次3~9ms。</li>
<li>旋转时间：一旦读/写头定位到了期望的磁道，驱动器等待目标山区的第一个位旋转到读/写头下，这个步骤时间依赖于盘面位置和旋转速度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mtext> </mtext><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mrow><mi>R</mi><mi>P</mi><mi>M</mi></mrow></mfrac></mstyle><mo>×</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mn>60</mn><mi>s</mi></mrow><mrow><mn>1</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">T_{max \ rotation}=\cfrac{1}{RPM} \times \cfrac{60s}{1min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></li>
<li>最后，驱动器开始读或写内容。传送时间依赖于旋转速度和每条磁道的扇区数目，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mrow><mi>R</mi><mi>P</mi><mi>M</mi></mrow></mfrac></mstyle><mo>×</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">平</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi><mo stretchy="false">)</mo></mrow></mfrac></mstyle><mo>×</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mn>60</mn><mi>s</mi></mrow><mrow><mn>1</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">T_{avg \ transfer}=\cfrac{1}{RPM} \times \cfrac{1}{(平均扇区数/磁道)}\times \cfrac{60s}{1min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.526em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">数</span><span class="mord">/</span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></li>
</ul>
<p>考虑如下磁盘：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">旋转速率<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>s</mi><mi>e</mi><mi>e</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{avg \ seek}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><br>每条磁道的平均扇区数</td>
<td style="text-align:left">7200RPM<br>9 ms<br>400</td>
</tr>
</tbody>
</table>
<p>对于这个磁盘</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>×</mo><msub><mi>T</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mtext> </mtext><mi>r</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mn>60</mn><mi>s</mi><mi mathvariant="normal">/</mi><mn>7200</mn><mi>R</mi><mi>P</mi><mi>M</mi><mo stretchy="false">)</mo><mo>×</mo><mn>1000</mn><mi>m</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo>≈</mo><mn>4</mn><mi>m</mi><mi>s</mi><mspace linebreak="newline"></mspace><msub><mi>T</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi></mrow></msub><mo>=</mo><mn>60</mn><mi mathvariant="normal">/</mi><mn>7200</mn><mi>R</mi><mi>P</mi><mi>M</mi><mo>×</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>400</mn><mo stretchy="false">(</mo><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">磁</mi><mi mathvariant="normal">道</mi><mo stretchy="false">)</mo><mo>×</mo><mn>1000</mn><mi>m</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>m</mi><mi>s</mi><mo>≈</mo><mn>0.02</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T_{avg \ rotation}=1/2 \times T_{max \ rotation}=1/2 \times (60s/7200 RPM) \times 1000ms/s \approx 4ms \\
T_{avg \ transfer}=60/7200 RPM \times 1/400 (扇区/磁道) \times 1000ms/ms \approx 0.02ms
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord">7</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">/</span><span class="mord">7</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mord">/</span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">道</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<ul>
<li>访问一个扇区的主要时间是寻道时间和旋转延迟</li>
<li>因为寻道时间和旋转延迟大致相同，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的方法。</li>
<li>对存储在SRAM中的一个64位字的访问时间大约是4ms，对DRAM的访问时间是60ns。磁盘访问时间大约是10ms。</li>
</ul>
<h4 id="逻辑磁盘块"><a class="markdownIt-Anchor" href="#逻辑磁盘块"></a> 逻辑磁盘块</h4>
<p>为了对操作系统隐藏磁盘的复杂性，现代磁盘将它们的构造呈现为一个简单的视图：一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 个扇区大小的<em>逻辑块</em>的序列，编号为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><mi>B</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0, 1, ···, B-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。磁盘中封装有<em>磁盘控制器</em>，维护者逻辑块号和实际磁盘扇区之间的映射关系。</p>
<p>一个逻辑块号经由固件翻译为一个<code>(盘面, 磁道, 扇区)</code>的三元组。这个三元组唯一地标识了对应的物理扇区。控制器上的硬件会解释这个三元组。</p>
<h4 id="连接io设备"><a class="markdownIt-Anchor" href="#连接io设备"></a> 连接I/O设备</h4>
<p>例如图形卡、监视器、鼠标、键盘和磁盘的I/O设备都是通过<strong>I/O总线</strong> 连接到CPU和主存的。虽然I/O总线比系统总线和内存总线慢，但是它可以容纳大量第三方I/O设备。</p>
<p><img src="https://s2.loli.net/2022/06/03/Pmp2aGb9VIBgqMn.png" alt="6-5.png" /></p>
<h4 id="访问磁盘"><a class="markdownIt-Anchor" href="#访问磁盘"></a> 访问磁盘</h4>
<p>CPU使用一种称为<strong>内存映射I/O（memory-mapped I/O）</strong> 的技术来向I/O设备发射命令，地址空间中有一块地址是为与I/O设备通信而保留的。这样的地址称为<strong>I/O端口（I/O port）</strong> 。</p>
<p>在磁盘控制器收到来自CPU的读命令后，将逻辑块号翻译成一个扇区地址，读取内容并传送到主存，不需要CPU的干涉，这称为<strong>直接内存访问（Direct Memory Access, DMA）</strong>。这种数据传送称为<strong>DMA传送(DMA transfer)</strong> 。</p>
<h4 id="固态硬盘"><a class="markdownIt-Anchor" href="#固态硬盘"></a> 固态硬盘</h4>
<p>固态硬盘（Solid State Dist, SSD）是一种基于闪存的存储技术。</p>
<ul>
<li>闪存芯片：相对于机械驱动器</li>
<li>闪存翻译层：相对于磁盘控制器</li>
</ul>
<p>一个闪存由<strong>B个块</strong>的序列组成，每个块由<strong>P个页</strong>组成，页的大小通常是512字节 ~ 4K字节，块是由32 ~ 128页组成，块的大小为16K字节 ~ 512K字节。数据以页为单位进行读写。一个块被擦除后，才能写这个块中的页。块的寿命一般为100,000次写。</p>
<h4 id="存储技术趋势"><a class="markdownIt-Anchor" href="#存储技术趋势"></a> 存储技术趋势</h4>
<ul>
<li>不同的存储技术有不同的价格和性能折中</li>
<li>不同的存储技术的价格和性能以不同的速率变化</li>
<li>DRAM和磁盘的性能提升滞后于CPU性能的提升</li>
</ul>
<h2 id="局部性"><a class="markdownIt-Anchor" href="#局部性"></a> 局部性</h2>
<p>编写良好的程序倾向于引用邻近于其他最近引用过的数据项的数据项，或最近引用过的数据项本身。这种倾向性为称为<strong>局部性原理（principle of locality）</strong>。</p>
<p>局部性有两种不同的形式：<strong>时间局部性（temporal locality）</strong> 和 <strong>空间局部性（spatial locality）</strong> 。有良好局部性的程序运行地更快。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">        <span class="comment">// visit a[i][j];</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="comment">// visit a[i][j];</span></span><br></pre></td></tr></table></figure>
<p>前者具有更好的空间局部性。</p>
<h2 id="存储器层次结构"><a class="markdownIt-Anchor" href="#存储器层次结构"></a> 存储器层次结构</h2>
<ul>
<li>存储技术：不同存储技术的访问时间差异很大。</li>
<li>计算机软件：一个编写良好的程序倾向于展示出良好的局部性。</li>
</ul>
<p>因此使用一种称为<strong>存储器层次结构（memory hierarchy）</strong> 的方法组织存储器系统。从高层往底层走，存储设备变得更慢、更便宜和更大。</p>
<p><img src="https://s2.loli.net/2022/06/03/dqwyA8MXpYuCS3Q.png" alt="6-21.jpg" /></p>
<h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3>
<p><strong>高速缓存（cache）</strong> 是一个小而快的存储设备。使用高速缓存的过程称为<strong>缓存（caching）</strong> 。</p>
<p>存储器层次结构的中心思想是，对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。</p>
<p>第k+1层的存储器被划分为连续的数据对象组成块（chunk），简记为块（block）。每个块都有一个唯一的地址或名字。</p>
<p><img src="https://s2.loli.net/2022/06/03/nVkey9PcK6x2XNl.jpg" alt="6-22.jpg" /></p>
<p>数据总是以块大小位<strong>传送单元（transfer unit）</strong> 在第k层和第k+1层之间来回复制的。</p>
<h4 id="缓存命中"><a class="markdownIt-Anchor" href="#缓存命中"></a> 缓存命中</h4>
<p>当程序需要第k+1层某个数据对象d时，首先在第k层的一个块中查找d。如果d刚好缓存在第k层中，就是<strong>缓存命中（cache hit）</strong> 。该程序直接从第k层读取d。</p>
<h4 id="缓存不命中"><a class="markdownIt-Anchor" href="#缓存不命中"></a> 缓存不命中</h4>
<p>如果第k层没有缓存数据对象d，那么就是<strong>缓存不命中（cache miss）</strong> 。此时，从k+1层中取出包含d的块放在k层。如果k层已满，可能覆盖现存的一个块。</p>
<p>如果第k层的缓存是空的，那么任何访问都不命中，这称之为<strong>冷缓存（cold cache）</strong> ，此类不命中称之为<strong>强制性不命中</strong> 或<strong>冷不命中</strong> 。</p>
<p>只要发生了不命中，第k层缓存就必须执行某个<strong>放置策略（placement policy）</strong> 。对于严格的放置策略，可能限制放置的位置，有可能导致<strong>冲突不命中（conflict miss）</strong> 。</p>
<p>当工作集大小超过缓存大小时，会经历<strong>容量不命中（capacity miss）</strong>。</p>
<h2 id="高速缓存存储器"><a class="markdownIt-Anchor" href="#高速缓存存储器"></a> 高速缓存存储器</h2>
<p>由于CPU和主存之间的速度差距，系统设计这被迫在CPU寄存器和主存中插入了小的SRAM高速缓存存储器，称为<em>L1高速缓存（一级缓存）</em> 。随后也出现了L2高速缓存和L3高速缓存。</p>
<p><img src="https://s2.loli.net/2022/06/03/ZBmJsQ7zSWfuVIy.png" alt="6-24.png" /></p>
<h3 id="通用高速缓存存储器组织结构"><a class="markdownIt-Anchor" href="#通用高速缓存存储器组织结构"></a> 通用高速缓存存储器组织结构</h3>
<p>假设每个内存地址为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>位。高速缓存被组织成一个有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">S=2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span>个<strong>高速缓存组（cache set）</strong> 的数组。每个组包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>个<strong>高速缓存行（cache line）</strong> 。每行包括：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B=2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span>字节的数据块</li>
<li>一个<strong>有效位（valid bit）</strong>。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mi>m</mi><mo>−</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t=m-(b+s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>个<strong>标记位（tag bit）</strong> 。</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/03/RcBEVJ5xGwhlH2U.png" alt="6-25.png" /></p>
<p>一般而言，高速缓存的结构可以用元组<code>(S, E, B, m)</code>来描述。高速缓存的大小C指所有块大小的和，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>S</mi><mo>×</mo><mi>E</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C=S \times E \times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>。</p>
<h3 id="直接映射高速缓存"><a class="markdownIt-Anchor" href="#直接映射高速缓存"></a> 直接映射高速缓存</h3>
<p>根据每个组的高速缓存行数E，高速缓存被分为不同的类。每个组只有一行（E=1）的高速缓存称为<strong>直接映射高速缓存（direct-mapped cache）</strong>。</p>
<p>当CPU执行一条读内存字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的指令，它向高速缓存L1请求这个字。如果L1高速缓存有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 的一个缓存的副本，那么就得到L1高速缓存命中。高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：</p>
<ol>
<li>组选择，高速缓存从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的地址中间抽取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个组索引位，类似于数组索引。</li>
<li>行匹配，确定是否有字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的一个副本在组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>包含的一个高速缓存行中。在直接映射高速缓存中，组只有一行，故直接检查标记位是否匹配之后返回值就行了。</li>
<li>字抽取，最后一步确定所需要的字在块中是从那里开始的。块偏移位提供了这个值。</li>
</ol>
<p><img src="https://s2.loli.net/2022/06/03/CKNr8vxUG4i2wZt.png" alt="6-29.png" /></p>
<p>不命中时，用新取出的行替换当前的行。</p>
<h3 id="组相联高速缓存"><a class="markdownIt-Anchor" href="#组相联高速缓存"></a> 组相联高速缓存</h3>
<p>直接映射高速缓存由于每个组只有一行，可能造成冲突不命中。<strong>组相联高速缓存（set associative cache）</strong> 中每个组保存有多于一个的高速缓存行。一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>E</mi><mo>&lt;</mo><mi>C</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1 &lt; E &lt; C/B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的高速缓存通常称为E路组相联高速缓存。</p>
<ol>
<li>组选择，与直接映射高速缓存没有区别。</li>
<li>行匹配，需要检查多行。<em>相联存储器</em>是一个<code>(key, value)</code>对的数组，我们可以把每个组看成一个小的相联存储器，key是标记和有效位，value是块的内容。高速缓存必须搜索组中的每一行，其标记与地址中的标记相匹配。</li>
<li>字抽取，与前者相同。</li>
</ol>
<h3 id="全相联高速缓存"><a class="markdownIt-Anchor" href="#全相联高速缓存"></a> 全相联高速缓存</h3>
<p>是由一个包含所有高速缓存行的组（E=C/B）组成的。</p>
<ol>
<li>组选择，只有一个组</li>
<li>行选择，与组相联高速缓存一样，但是更大，可能需要TLB。</li>
<li>字抽取，与前者相同。</li>
</ol>
<h3 id="写操作"><a class="markdownIt-Anchor" href="#写操作"></a> 写操作</h3>
<p>如果写一个已经缓存了的字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，即<strong>写命中（write hit）</strong> 。在高速缓存更新后，同时要更新低一层次的副本。</p>
<ul>
<li><strong>直写（write-through）</strong> 立即将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的高速缓存块写回到第一层中，简单，但是每次写都会引起总线流量。</li>
<li><strong>写回（write-back）</strong> 尽可能地推迟更新。只有替换算法驱逐这个块时，才写到低层中，但是需要为每一个高速缓存行维护一个修改为（dirty bit）。</li>
</ul>
<p>写不命中时，也有两种处理方法</p>
<ul>
<li><strong>写分配（write-allowance）</strong>，加载相应低层中的块到高层中并更新，缺点是每次不命中都会导致数据传输。</li>
<li><strong>非写分配（not-write-allowance）</strong>，直接写到低层中。</li>
</ul>
<p>直写通常搭配写分配，写回通常搭配非写分配。</p>
<h3 id="高速缓存参数的性能影响"><a class="markdownIt-Anchor" href="#高速缓存参数的性能影响"></a> 高速缓存参数的性能影响</h3>
<ul>
<li><strong>不命中率（miss rate）</strong>，不命中数量/引用数量。</li>
<li><strong>命中率（hit rate）</strong>，1-不命中率。</li>
<li><strong>命中时间（hit time）</strong>，从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。</li>
<li><strong>不命中处罚（miss penalty）</strong>。由于不命中所需要的额外时间，L1不命中需要从L2得到服务，这就是不命中处罚。</li>
</ul>
<p><strong>高速缓存大小的影响</strong><br />
较大的缓存可能会提高命中率，同时可能会增加命中时间。</p>
<p><strong>块大小的影响</strong><br />
较大的块可以利用空间局部性。但块越大意味着高速缓存行数越小，会损害时间局部性。块越大，传送时间也越长。<br />
<strong>相联度的影响</strong><br />
参数E选择的影响。较高的相联度降低了冲突不命中造成抖动的可能性，但是成本高，且会增加命中时间，增加不命中处罚。最终变成命中时间和不命中处罚之间的折中。<br />
<strong>写策略的影响</strong><br />
一般而言，高速缓存越下层，越可能使用写回而不是直写。</p>
<h2 id="编写高速缓存友好的代码"><a class="markdownIt-Anchor" href="#编写高速缓存友好的代码"></a> 编写高速缓存友好的代码</h2>
<ol>
<li>让最常见的情况运行地最快。</li>
<li>减小每个循环内部的缓存不命中数量，例如：
<ul>
<li>对局部变量的反复引用是好的，因为编译器能将它们缓存在寄存器中（时间局部性）。</li>
<li>步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。</li>
</ul>
</li>
</ol>
<p>在多维数组中，空间局部性尤其重要。</p>
<h2 id="高速缓存对程序性能的影响"><a class="markdownIt-Anchor" href="#高速缓存对程序性能的影响"></a> 高速缓存对程序性能的影响</h2>
<p>一个程序从存储系统中读数据的速率称为<strong>读吞吐量（read throughput）</strong> 或<strong>读带宽（read bandwidth）</strong>。如果程序在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>秒内读<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>字节，那么读吞吐量就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">n/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2022/06/02/study-notes-CSAPP-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/02/study-notes-CSAPP-4/" class="post-title-link" itemprop="url">CSAPP笔记（四）—— 优化程序性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-02 14:27:04 / 修改时间：19:40:39" itemprop="dateCreated datePublished" datetime="2022-06-02T14:27:04+08:00">2022-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CSAPP学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>编写高效程序需要做到三点：</p>
<ol>
<li>选择适当的算法和数据结构。</li>
<li>编写出编译器能够有效转化的代码。</li>
<li>在多核多线程处理器上并行地计算。</li>
</ol>
<h2 id="优化编译器的能力和局限性"><a class="markdownIt-Anchor" href="#优化编译器的能力和局限性"></a> 优化编译器的能力和局限性</h2>
<p>现代编译器会尽可能地化简表达式。GCC使用<code>-Ox</code>表示优化等级。但是，编译器必须小心地只进行 <em>安全的优化</em> 。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在大部分情况下，两函数等效。显然，前者读内存6次，后者读内存3次，后者效率高。但考虑到 <code>xp == yp</code> 的情况，此时前者使得值变化为4倍，后者值变化为3倍。故不能直接用后者代替前者。这体现了优化的局限性。</p>
<p>两个指针可能指向同一个内存位置的情况称为 <strong>内存别名使用（memory aliasing）</strong> 。在执行安全优化中，编译器必须假设不同的指针可能会指向内存中的同一个位置。</p>
<p>再例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1000</span>; y = <span class="number">3000</span>;</span><br><span class="line">*q = y; *p = x;</span><br><span class="line">t1 = *q;</span><br></pre></td></tr></table></figure>
<p><code>t1</code>的值依赖于<code>p</code>和<code>q</code>是否指向同一个位置。如果不是，<code>t1 = 3000</code>，否则<code>t1 = 1000</code>。</p>
<p>第二个可能妨碍优化的因素是函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> counter++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f() + f() + f() + f(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span> * f(); &#125;</span><br></pre></td></tr></table></figure>
<p>考虑到修改了<code>counter</code>的影响，<code>func1()</code>返回<code>0</code>，而<code>func2()</code>返回<code>6</code>。由于大多数编译器不会判断一个函数是否有副作用，其假设最糟糕的情况，并保持所有函数调用不变。</p>
<h2 id="表示程序性能"><a class="markdownIt-Anchor" href="#表示程序性能"></a> 表示程序性能</h2>
<p>引入度量标准 <strong>每元素的周期数（Cycles Per Element, CPE）</strong> 。</p>
<p>处理器活动的顺序由时钟控制。时钟频率通常由<em>千兆赫兹（GHz）</em>，十亿周期每秒来表示。时钟周期为频率的倒数，例如 4GHz 时钟频率的时钟周期为 0.25 纳秒。</p>
<p>以两个不同的前缀和算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compute prefix sum of vector a */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psum1</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">float</span> p[], <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psum2</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">float</span> p[], <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    p[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> mid_val = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        p[i]     = mid_val;</span><br><span class="line">        p[i + <span class="number">1</span>] = mid_val + a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For even n, finish remaining element</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个函数每次迭代两个元素（循环展开）。两个函数的处理时间与元素数量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 有关，此例中为线性关系。</p>
<p><img src="https://s2.loli.net/2022/06/02/RW31AUSs5ulQ8Fb.png" alt="5-2.png" /></p>
<p>两者运行时间近似于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>368</mn><mo>+</mo><mn>9.0</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">368 + 9.0n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">.</span><span class="mord">0</span><span class="mord mathdefault">n</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>368</mn><mo>+</mo><mn>6.0</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">368 + 6.0n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span><span class="mord mathdefault">n</span></span></span></span> 。两个等式表明对代码计时和初始化过程、准备循环以及完成过程的开销为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>368</mn></mrow><annotation encoding="application/x-tex">368</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span></span></span></span> 个周期加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6.0</mn></mrow><annotation encoding="application/x-tex">6.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9.0</mn></mrow><annotation encoding="application/x-tex">9.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">.</span><span class="mord">0</span></span></span></span> 周期的线性因子。</p>
<p>这些项的系数称为每元素的周期数（CPE）的有效值。我们更愿意使用每元素的周期数而不是每循环的周期数。前者CPE为6.0，后者CPE为9.0。</p>
<h2 id="基础优化方法"><a class="markdownIt-Anchor" href="#基础优化方法"></a> 基础优化方法</h2>
<h3 id="代码移动code-motion"><a class="markdownIt-Anchor" href="#代码移动code-motion"></a> 代码移动（code motion）</h3>
<p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_func</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            compute</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记字符串长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> ，每次循环中调用<code>strlen(s)</code>，其本身需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，完整的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。</p>
<p>通过简单的代码移动，提前计算<code>len</code>就可以优化至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_func</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            compute</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="减少过程调用"><a class="markdownIt-Anchor" href="#减少过程调用"></a> 减少过程调用</h3>
<p>过程调用本身会对性能造成影响。但是区别很小。</p>
<h3 id="消除不必要的内存引用"><a class="markdownIt-Anchor" href="#消除不必要的内存引用"></a> 消除不必要的内存引用</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data_t</span> * dest;</span><br><span class="line"><span class="keyword">data_t</span> data[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* loop conditions */</span>)</span><br><span class="line">    *dest = *dest OP data[i];</span><br></pre></td></tr></table></figure>
<p>以上程序中，每一次循环内部均引用一次堆内存，其会造成性能影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data_t</span> *dest;</span><br><span class="line"><span class="keyword">data_t</span> data[N];</span><br><span class="line"><span class="keyword">data_t</span> acc = *dest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* loop conditions */</span>)</span><br><span class="line">    acc = acc OP data[i];</span><br><span class="line">*dest = acc;</span><br></pre></td></tr></table></figure>
<p>即可大量减少堆内存引用。</p>
<h2 id="理解现代处理器"><a class="markdownIt-Anchor" href="#理解现代处理器"></a> 理解现代处理器</h2>
<p>当一系列操作必须严格按顺序执行时，就会遇到 <strong>延迟界限（latency bound）</strong> ，因为在下一条指令开始之前，上一条指令必须结束。<strong>吞吐量界限（throughput bound）</strong> 刻画了处理器功能单元的原始计算能力。</p>
<h3 id="整体操作"><a class="markdownIt-Anchor" href="#整体操作"></a> 整体操作</h3>
<p>现代微处理器在工业界称为 <strong>超标量（superscalar）</strong>，意思是一个时钟周期可以执行多个指令，而且是 <strong>乱序的（out-of-order）</strong> 。</p>
<p>整个设计有两个主要部分：</p>
<ol>
<li>
<p><strong>指令控制单元（Instruction Control Unit, ICU）</strong>，负责从内存中读出指令序列，并根据其生成针对程序数据的基本操作。</p>
</li>
<li>
<p><strong>执行单元（Execution Unit, EU）</strong>，执行ISA产生的操作。</p>
</li>
</ol>
<p>乱序处理器需要更大、更复杂的硬件，但是它们能更好地到达更高的指令级并行度。</p>
<p><img src="https://s2.loli.net/2022/06/02/RyBF4HJUPuxnZKt.png" alt="5-12.png" /></p>
<p>ICU从<strong>指令高速缓存（instruction cache）</strong> 中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。</p>
<p>当程序遇到分支时，程序有两个可能的前进方向。现代处理器采用了一种<strong>分支预测（branch prediction）</strong> 技术，处理器会猜测是否选择分支，同时还猜测分支的目标地址。</p>
<p>使用<strong>投机执行（speculative execution）</strong> 技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并译码，甚至执行。如果过后确定分支预测错误，会将状态重新设置到分支点的状态。这部分被包含在<em>取指控制</em>之中。</p>
<p><em>指令译码</em>逻辑接收实际的逻辑指令，并将它们转换成一组基本操作（微操作）。对于具有复杂指令的机器，如x86，一条指令可以被译码成多个操作。例如<code>add %rax, %rax</code>只被转化成一个操作，但<code>addq %rax, 8(%rdx)</code>会把内存引用和算术运算分开。这条指令会被译码为三个操作：从内存中加载值、相加、将值存回内存。</p>
<p>EU接收来自取指单元的操作。通常，每个时钟周期会接收多个操作。这些操作会被分派到一组<em>功能单元</em>中，它们会执行实际的操作。</p>
<h3 id="处理器操作的抽象模型"><a class="markdownIt-Anchor" href="#处理器操作的抽象模型"></a> 处理器操作的抽象模型</h3>
<p><strong>数据流（data-flow）</strong> 是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了图中的<strong>关键路径（critical path）</strong> 。</p>
<p>例如</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># acc in %xmm0, data+i in %rdx, data+length in %rax</span></span><br><span class="line">.L25</span><br><span class="line">    vmulsd  (%rdx), %xmm0, %xmm0    # Multiply acc by data[i]</span><br><span class="line">    addq    $8, %rdx                <span class="comment"># Increment data+i</span></span><br><span class="line">    cmpq    %rax, %rdx              <span class="comment"># Compare to data+length</span></span><br><span class="line">    jne     .L25                    <span class="comment"># If !=, goto loop</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/06/02/GQ2FOkgUy9bj6JL.png" alt="5.13.png" /><br />
如图所示，指令译码器把这4条指令扩展成为一系列的5个操作。</p>
<p>我们可以把访问到的寄存器分为四类：</p>
<ul>
<li>只读，不会被修改</li>
<li>只写，作为数据传送的目的</li>
<li>局部，只在单次循环内部被使用</li>
<li>循环：一次迭代中产生的值会在另一次迭代中用到</li>
</ul>
<p>循环寄存器之间的操作链决定了限制性能的数据相关。进一步对数据流图进行优化，消除不直接影响数据流的操作（即cmp和jne）以及循环寄存器后有</p>
<p><img src="https://willendless.github.io/assets/images/csapp/5-17.png" alt="5.14.png" /></p>
<p><img src="https://willendless.github.io/assets/images/csapp/5-18.png" alt="5.15.png" /></p>
<p>在单精度浮点乘法条件下，由于mul操作的执行需要5个时钟周期，而数据依赖的情况下迭代n次就需要5n个时钟周期。加法操作需要1个时钟周期，因此n次迭代整体仅需要n个时钟周期。所以关键路径为mul操作的数据依赖。</p>
<h2 id="循环展开"><a class="markdownIt-Anchor" href="#循环展开"></a> 循环展开</h2>
<p>循环展开通过增加每次迭代计算的元素数量，减少循环的迭代次数。循环展开能从两个方面改善程序性能：</p>
<ol>
<li>减少了循环索引计算、条件分支等不直接有助于结果的操作数量。</li>
<li>提供了一些方法可以进一步减少关键路径上的操作数量。</li>
</ol>
<p>对一个循环按任意因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 展开，由此产生 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 循环展开。这种变换为“<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 循环展开”。这种循环展开不能将性能改进到超过延迟界限，因为关键路径不随着迭代次数的减小而改变。</p>
<h2 id="提高并行性"><a class="markdownIt-Anchor" href="#提高并行性"></a> 提高并行性</h2>
<p>我们将累积值放在一个单独的变量之中，会使得前面的计算完成前都不能计算新值。</p>
<h3 id="多个累积变量"><a class="markdownIt-Anchor" href="#多个累积变量"></a> 多个累积变量</h3>
<p>例如，分别计算奇、偶的和或积，就能获得极大的性能改进，且打破延迟界限。它既使用了两次循环展开，又使用了两路并行，我们将其称为“ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 循环展开” 。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adamska</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.2/dist/mermaid.min.js","integrity":"sha256-UIQPVkGifpwMvDH5yGgORJ9sSTDq38zz6BGU6dNaKhM="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha256-M6KFoDq9eUpmogkDgw6+3R3ZgUPSuFXnQyr8tskSfQs=" crossorigin="anonymous">



</body>
</html>
