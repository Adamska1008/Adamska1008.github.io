<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"adamska1008.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="软件工程导论课程笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程导论笔记">
<meta property="og:url" content="https://adamska1008.github.io/2023/01/29/study-notes-software-engineering/index.html">
<meta property="og:site_name" content="Adamska&#39;s Blog">
<meta property="og:description" content="软件工程导论课程笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.rkpass.cn/ruankao_work_version_0103/content_image/14/9787302368779_0236_0078.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190726073429663.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1251433/202002/1251433-20200202155213931-163511787.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1251433/202002/1251433-20200202152401910-1394571829.png">
<meta property="og:image" content="https://web-static.wrike.com/cdn-cgi/image/format=auto,quality=80,width=1208,dpr=1/tp/storage/uploads/92025823-45d4-4b1c-bcef-6dffd4727344/scrum-cycle-resized.png">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/SampleBurndownChart.svg/1920px-SampleBurndownChart.svg.png">
<meta property="og:image" content="https://www.mindcrafts.ch/emi2020/wp-content/uploads/2020/07/RUP-Phase-Model-1.png">
<meta property="article:published_time" content="2023-01-29T08:44:36.000Z">
<meta property="article:modified_time" content="2023-02-18T09:32:08.186Z">
<meta property="article:author" content="Adamska">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.rkpass.cn/ruankao_work_version_0103/content_image/14/9787302368779_0236_0078.jpg">


<link rel="canonical" href="https://adamska1008.github.io/2023/01/29/study-notes-software-engineering/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://adamska1008.github.io/2023/01/29/study-notes-software-engineering/","path":"2023/01/29/study-notes-software-engineering/","title":"软件工程导论笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>软件工程导论笔记 | Adamska's Blog</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Adamska's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text"> 软件工程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">1.1.</span> <span class="nav-text"> 软件的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text"> 发展过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text"> 软件过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 软件过程模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%81%93%E5%BE%B7%E8%A7%84%E8%8C%83"><span class="nav-number">1.4.</span> <span class="nav-text"> *软件工程师道德规范</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text"> 需求工程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text"> 需求工程概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E7%9A%84%E5%B1%82%E6%AC%A1%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">2.1.1.</span> <span class="nav-text"> 需求的层次与分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text"> 需求工程过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text"> 需求获取与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%E4%B8%8E%E6%8C%91%E6%88%98"><span class="nav-number">2.2.1.</span> <span class="nav-text"> 特点与挑战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text"> 需求获取与分析方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99"><span class="nav-number">2.3.</span> <span class="nav-text"> 需求文档编写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8Esrssoftware-requirement-specification%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E8%A6%81%E6%B1%82"><span class="nav-number">2.3.1.</span> <span class="nav-text"> 需求规格说明（SRS，Software Requirement Specification）的作用与要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#srs%E7%9A%84%E6%92%B0%E5%86%99%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.2.</span> <span class="nav-text"> SRS的撰写方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%8F%98%E6%9B%B4"><span class="nav-number">2.4.</span> <span class="nav-text"> 需求验证与变更</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E9%AA%8C%E8%AF%81"><span class="nav-number">2.4.1.</span> <span class="nav-text"> 需求验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E7%AD%BE%E7%BA%A6"><span class="nav-number">2.4.2.</span> <span class="nav-text"> 需求签约</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%8F%E6%8D%B7%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text"> 敏捷过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%8F%E6%8D%B7%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text"> 敏捷过程概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%8F%E6%8D%B7%E8%BF%87%E7%A8%8B%E7%9A%84%E4%BB%B7%E5%80%BC%E8%A7%82%E4%B8%8E%E5%8E%9F%E5%88%99"><span class="nav-number">3.2.</span> <span class="nav-text"> 敏捷过程的价值观与原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8Bextreme-programming"><span class="nav-number">3.3.</span> <span class="nav-text"> 极限编程（extreme programming）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scrum"><span class="nav-number">3.4.</span> <span class="nav-text"> SCRUM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B-rup"><span class="nav-number">4.</span> <span class="nav-text"> 统一过程 RUP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rup%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text"> RUP概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rup%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text"> RUP的软件过程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%B5%E8%BD%B4%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.1.</span> <span class="nav-text"> 纵轴元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%AA%E8%BD%B4%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.2.</span> <span class="nav-text"> 横轴元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uml"><span class="nav-number">5.</span> <span class="nav-text"> UML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text"> 面向对象概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uml%E6%A6%82%E8%BF%B0"><span class="nav-number">5.2.</span> <span class="nav-text"> UML概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BE%8B"><span class="nav-number">5.3.</span> <span class="nav-text"> 用例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BE%8B%E6%96%87%E6%A1%A3"><span class="nav-number">5.3.1.</span> <span class="nav-text"> 用例文档</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%9B%BE%E5%92%8C%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="nav-number">5.4.</span> <span class="nav-text"> 状态图和活动图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9B%BE%E5%92%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="nav-number">5.5.</span> <span class="nav-text"> 类图和顺序图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text"> 软件设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">6.1.</span> <span class="nav-text"> 软件设计基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">6.1.1.</span> <span class="nav-text"> 软件设计过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5%E5%8E%9F%E5%88%99"><span class="nav-number">6.1.2.</span> <span class="nav-text"> 常用设计概念（原则）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="nav-number">6.1.3.</span> <span class="nav-text"> 面向对象软件设计方法学</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AF%84%E5%AE%A1"><span class="nav-number">6.1.4.</span> <span class="nav-text"> 软件评审</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.2.</span> <span class="nav-text"> 软件体系结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E9%A3%8E%E6%A0%BC"><span class="nav-number">6.2.1.</span> <span class="nav-text"> 软件体系风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">6.2.2.</span> <span class="nav-text"> 软件体系结构设计的任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.3.</span> <span class="nav-text"> 软件详细设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">6.3.1.</span> <span class="nav-text"> 面向对象的设计原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.3.2.</span> <span class="nav-text"> 软件设计模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="nav-number">6.4.</span> <span class="nav-text"> 软件测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BE%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-number">6.5.</span> <span class="nav-text"> 放在最后</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E4%B8%8E%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">6.5.1.</span> <span class="nav-text"> 用户体验与可用性</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adamska</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://adamska1008.github.io/2023/01/29/study-notes-software-engineering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adamska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adamska's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="软件工程导论笔记 | Adamska's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          软件工程导论笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-29 16:44:36" itemprop="dateCreated datePublished" datetime="2023-01-29T16:44:36+08:00">2023-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-18 17:32:08" itemprop="dateModified" datetime="2023-02-18T17:32:08+08:00">2023-02-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>软件工程导论课程笔记。</p>
<span id="more"></span>
<h2 id="软件工程概述"><a class="markdownIt-Anchor" href="#软件工程概述"></a> 软件工程概述</h2>
<h3 id="软件的本质"><a class="markdownIt-Anchor" href="#软件的本质"></a> 软件的本质</h3>
<p><strong>定义</strong></p>
<ul>
<li>存在形式：程序+数据+文档</li>
<li>实质内容：以计算为核心手段实现应用目标的解决方案</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>不可见无磨损</li>
<li>一致性：不能独立存在，依附于环境</li>
<li>持续变更：易拷贝，易修改</li>
<li>日趋复杂</li>
</ul>
<h3 id="发展过程"><a class="markdownIt-Anchor" href="#发展过程"></a> 发展过程</h3>
<p>第一阶段：程序设计阶段</p>
<ul>
<li>时间：第一台计算机诞生后</li>
<li>特点：
<ul>
<li>软件工作：代码编写</li>
<li>软件评估：程序设计=数据结构+算法，编程技巧</li>
</ul>
</li>
</ul>
<p>第二阶段：软件工程阶段</p>
<ul>
<li>时间：大容量，高速度计算机的出现</li>
<li>特点：
<ul>
<li>软件危机：规模变大，复杂程度变高，导致开发<strong>进度</strong>失控，<strong>费用</strong>失控，<strong>可靠性</strong>、<strong>维护性</strong>差</li>
<li>工程化方法应用于软件：需求分析，测试，维护</li>
<li>软件评估：可读性、可理解性、可测试性、易修改性</li>
</ul>
</li>
</ul>
<h3 id="软件过程"><a class="markdownIt-Anchor" href="#软件过程"></a> 软件过程</h3>
<p>软件过程阶段是软件发展的第三阶段</p>
<ul>
<li>时间：互联网广泛应用后</li>
<li>特点：快速变化的需求、技术和市场
<ul>
<li>软件工作：<br>
流程活动（时序逻辑关系）+流程活动各要素（人员、方法、产品）</li>
<li>软件评估<br>
多目标函数（软件质量、开发效率、开发成本）</li>
</ul>
</li>
</ul>
<p><strong>定义</strong>：<br>
<strong>软件过程</strong>是从软件项目需求定义开始直至软件经使用后废弃为止的跨越软件整个生存期内的系统开发、运行和维护等全部活动及相关项的总和。</p>
<p><strong>软件过程框架</strong>：四项基本活动</p>
<ul>
<li>软件规格说明<br>
客户和工程师定义所要开发的软件以及对其运行的约束</li>
<li>软件开发<br>
对软件进行设计和编程实现</li>
<li>软件确认<br>
对软件进行检查一确保它是客户所需要的</li>
<li>软件演化<br>
对软件进行修改以反应客户和市场需求的变化</li>
</ul>
<h4 id="软件过程模型"><a class="markdownIt-Anchor" href="#软件过程模型"></a> 软件过程模型</h4>
<p><strong>瀑布模型</strong></p>
<ul>
<li>内容：各阶段活动</li>
<li>特征：
<ul>
<li>瀑布状：<br>
自上而下，相互衔接</li>
<li>各阶段及其活动 ：<br>
多种模型的基本细粒度元素</li>
</ul>
</li>
<li>适用范围<br>
需求较明确、且较稳定</li>
</ul>
<p><img src="http://www.rkpass.cn/ruankao_work_version_0103/content_image/14/9787302368779_0236_0078.jpg" alt></p>
<p><strong>原型模型</strong></p>
<ul>
<li>内容：
<ul>
<li>第一步：原型<br>
弄清需求并探索可行性</li>
<li>第二步：开发产品</li>
</ul>
</li>
<li>特征及适用范围：减少了需求不明确带来的风险<br>
<img src="https://img-blog.csdnimg.cn/20190726073429663.png" alt></li>
</ul>
<p><strong>螺旋模型</strong></p>
<ul>
<li>内容：<br>
螺线旋转一圈(笛卡儿坐标四个象限) → 一个原型</li>
<li>特征
<ul>
<li>加入风险分析</li>
<li>迭代演化<br>
识别每个演化层的风险</li>
<li>自上而下</li>
</ul>
</li>
<li>适用范围<br>
需求不太明确且不太稳定<br>
<img src="https://img2018.cnblogs.com/i-beta/1251433/202002/1251433-20200202155213931-163511787.png" alt></li>
</ul>
<p><strong>增量模型</strong></p>
<ul>
<li>内容：<br>
线性过程流 + 并行过程流</li>
<li>特征：
<ul>
<li>增量交付<br>
第一个增量往往是核心产品</li>
<li>并行化，交付效率提升</li>
</ul>
</li>
<li>适用范围<br>
需求较不稳定、强调快速交付</li>
</ul>
<p><img src="https://img2018.cnblogs.com/i-beta/1251433/202002/1251433-20200202152401910-1394571829.png" alt></p>
<h3 id="软件工程师道德规范"><a class="markdownIt-Anchor" href="#软件工程师道德规范"></a> *软件工程师道德规范</h3>
<ol>
<li>公众感——软件工程师应当始终如一地与公众利益保持一致；</li>
<li>客户和雇主——软件工程师应在保持与公众利益一致的原则下，保证客户和雇主的利益最大化；</li>
<li>产品——软件工程师应当确保他们的产品和相关的改进达到最高专业标准；</li>
<li>判断力——软件工程师应该具备公正和独立的职业判断力；</li>
<li>管理 – 软件工程的管理和领导人员在软件开发和维护的过程中，应自觉遵守、应用并推动合乎道德规范的管理方法；</li>
<li>职业感 –在尊重社会公众利益原则下，软件工程师应当保证职业的诚信和声誉，尊重社会公众利益；</li>
<li>同事 – 软件工程师应该公平地对待和支持每一位同事；</li>
<li>自身 – 软件工程师应终生不断地学习和实践其专业知识，并在学习和实践的过程中不断提高自身的道德规范素养。</li>
</ol>
<h2 id="需求工程"><a class="markdownIt-Anchor" href="#需求工程"></a> 需求工程</h2>
<h3 id="需求工程概述"><a class="markdownIt-Anchor" href="#需求工程概述"></a> 需求工程概述</h3>
<p><strong>定义</strong><br>
需求就是以一种清晰、简洁、一致且无二义性的方式， 对一个待开发软件系统中各个有意义功能和性能等方面的<strong>陈述的集合</strong>。</p>
<p><strong>意义</strong><br>
需求是软件项目和产品的<strong>根源</strong>，是后续设计、实现、测试、维护等所有活动的<strong>依据</strong>。体现软件价值，决定软件命运。</p>
<h4 id="需求的层次与分类"><a class="markdownIt-Anchor" href="#需求的层次与分类"></a> 需求的层次与分类</h4>
<p><strong>层次</strong></p>
<ol>
<li>业务需求<br>
反映客户组织/用户对系统和产品高层次的业务目标需求。<br>
通过<strong>项目前景与范围文档</strong>予以陈述。</li>
<li>用户需求<br>
站在用户角度描述的产品功能和性能的概要<br>
通过<strong>用例文档</strong>予以陈述。</li>
<li>系统需求<br>
站在软件开发和测试人员角度产品应当做什么的详细描述。<br>
通过<strong>系统需求规格说明</strong>予以陈述。</li>
</ol>
<p><strong>作用</strong>：体现了从问题空间到求解空间的自然转化过程。给出了准确完整获取需求的有效路径。</p>
<p><strong>分类</strong></p>
<ul>
<li>功能性需求：
<ul>
<li>是对系统应该提供的服务、系统应该如何响应特定的输入、系统在特定的情形中应该如何表现等的陈述</li>
<li>在某些情况下，功能性需求还可以明确的陈述系统“不应该做什么”</li>
</ul>
</li>
<li>非功能需求：
<ul>
<li>业务规则<br>
包括公司政策、政府法规、工业标准</li>
<li>质量属性
<ul>
<li>可靠性</li>
<li>易用性</li>
<li>效率</li>
<li>可维护性</li>
<li>可移植性</li>
</ul>
</li>
<li>外部接口<br>
系统与之交互的硬件、软件或数据库</li>
<li>设计约束</li>
</ul>
</li>
</ul>
<h4 id="需求工程过程"><a class="markdownIt-Anchor" href="#需求工程过程"></a> 需求工程过程</h4>
<p>需求工程分为两个部分：</p>
<ul>
<li>需求开发
<ul>
<li>需求获取</li>
<li>需求分析</li>
<li>需求描述</li>
<li>需求验证</li>
</ul>
</li>
<li>需求管理
<ul>
<li>版本控制</li>
<li>变更控制</li>
<li>需求跟踪</li>
<li>状态跟踪</li>
</ul>
</li>
</ul>
<h3 id="需求获取与分析"><a class="markdownIt-Anchor" href="#需求获取与分析"></a> 需求获取与分析</h3>
<p>来源：</p>
<ul>
<li>利益相关者</li>
<li>业务流程数据</li>
<li>相关产品</li>
<li>重要文档</li>
<li>相关标准和法规</li>
</ul>
<p>需求获取与分析过程-四项基础活动：</p>
<ol>
<li>需求发现和理解</li>
<li>需求分类和组织</li>
<li>需求优先级排序和协商</li>
<li>需求文档化</li>
</ol>
<h4 id="特点与挑战"><a class="markdownIt-Anchor" href="#特点与挑战"></a> 特点与挑战</h4>
<ul>
<li>模糊性和隐蔽性
<ul>
<li>模糊性：不知道要什么</li>
<li>隐蔽性：不会向陌生人揭露</li>
<li>解决模糊性：设计原型</li>
<li>解决隐蔽性：深入调查和挖掘（黄金圈模型）</li>
</ul>
</li>
<li>多样性
<ul>
<li>不同用户有不同需求</li>
<li>使用用例综合分析需求</li>
</ul>
</li>
<li>领域专业性</li>
<li>易变性
<ul>
<li>项目开展、环境变化</li>
<li>过程迭代（螺旋模型，敏捷开发）</li>
</ul>
</li>
</ul>
<h4 id="需求获取与分析方法"><a class="markdownIt-Anchor" href="#需求获取与分析方法"></a> 需求获取与分析方法</h4>
<ol>
<li>引导性用户调研：解决模糊性
<ul>
<li>用户访谈</li>
<li>调查问卷</li>
<li>用户反馈</li>
<li><strong>原型法</strong>
<ul>
<li>提供交互媒介，使新产品实在化，消除人们在需求理解上的差异带来的风险</li>
<li>开发商：通过原型获得用户的信任和理解</li>
<li>客户：通过原型了解、确定实现目标</li>
</ul>
</li>
</ul>
</li>
<li>深入观察与挖掘：解决隐蔽性
<ul>
<li>现场观察与挖掘</li>
<li>数据分析</li>
<li>市场行业分析</li>
<li>竞品分析</li>
<li>头脑风暴</li>
<li>群体化方法</li>
<li><strong>扎根蘑菇群</strong></li>
<li><strong>黄金圈法则（what how why）</strong></li>
</ul>
</li>
<li>用例：解决多样性
<ul>
<li>每个用户只知道自己如何使用系统，系统应该为每个用户的需求进行评判</li>
<li>User分类</li>
<li>Case构建</li>
<li>汇总</li>
<li>协商、确定优先级</li>
</ul>
</li>
</ol>
<h3 id="需求文档编写"><a class="markdownIt-Anchor" href="#需求文档编写"></a> 需求文档编写</h3>
<h4 id="需求规格说明srssoftware-requirement-specification的作用与要求"><a class="markdownIt-Anchor" href="#需求规格说明srssoftware-requirement-specification的作用与要求"></a> 需求规格说明（SRS，Software Requirement Specification）的作用与要求</h4>
<p>三个层次：业务、用户、系统</p>
<p><strong>作用</strong></p>
<ol>
<li>记录共识</li>
<li>确认共识</li>
<li>完整地传递共识给开发人员</li>
</ol>
<p><strong>要求</strong></p>
<ul>
<li>完整性：涵盖三个层次，两个类型</li>
<li>一致性：三个层次的需求不能矛盾，不同用户需求不能矛盾</li>
<li>可阅读性：便于开发者和用户阅读理解</li>
<li>无二义性：文字表述没有多重的理解方式</li>
<li>可修改性：每项需求独立标记，有目录、索引、参照列表</li>
<li>可跟踪性：在设计、源代码、测试用例之间建立连接链</li>
<li>可测试性：能够根据需求设计测试</li>
<li>可维护性：类似于可修改</li>
</ul>
<h4 id="srs的撰写方法"><a class="markdownIt-Anchor" href="#srs的撰写方法"></a> SRS的撰写方法</h4>
<p><em>套用模板法</em>：</p>
<ol>
<li>选择文档模板</li>
<li>裁剪文档模板</li>
<li>选择文档语言，进行文档写作
<ul>
<li>描述语言包括：自然语言、结构化自然语言、图形化的建模语言</li>
</ul>
</li>
</ol>
<p><strong>用例（User case）</strong><br>
每个用例流程描述：由若干条事件组成</p>
<ul>
<li>User与系统的交互</li>
<li>通过交互，系统为用户实现的功能/价值</li>
<li>不涉及内部具体实现</li>
</ul>
<p>粒度控制适中。</p>
<h3 id="需求验证与变更"><a class="markdownIt-Anchor" href="#需求验证与变更"></a> 需求验证与变更</h3>
<h4 id="需求验证"><a class="markdownIt-Anchor" href="#需求验证"></a> 需求验证</h4>
<p>需求验证的意义：需求问题引起的变更成本远小于后期变更。</p>
<p>需求验证的任务：</p>
<ol>
<li>有效性检查</li>
<li>一致性检查：不能有冲突</li>
<li>完备性检查：包括所有用户想要的功能和约束</li>
<li>现实性检查：能够实现</li>
</ol>
<p>需求验证的方法：</p>
<ol>
<li>需求评审
<ul>
<li>分为正式/非正式</li>
<li>参与评审的人员包括用户、开发人员、测试人员、文档编写人员和项目经理</li>
</ul>
</li>
<li>原型法</li>
<li>需求验证漏斗
<ul>
<li>从上到下：what, how, why</li>
</ul>
</li>
<li>需求强度评估
<ul>
<li>潜在用户数+使用频率</li>
</ul>
</li>
<li>编写测试用例</li>
<li>编写用户手册</li>
<li>自动的一致性分析</li>
</ol>
<h4 id="需求签约"><a class="markdownIt-Anchor" href="#需求签约"></a> 需求签约</h4>
<p>需求签约主要解决需求的<strong>易变性</strong></p>
<ul>
<li>对需求分析不断沟通完善的<strong>过程</strong>和过程产生的<strong>结果</strong>SRS的<strong>确认</strong>。<br>
签约一旦生效，至少表明：
<ul>
<li>我们同意这份文档反应了我们此刻对项目需求的最佳理解，它描述的系统能够满足我们的要求。</li>
<li>软件需求的签约，是权利、义务和责任的体现。它表明需求开发阶段结束，被确认的SRS是软件需求的基线、是后续软件开发和验收的依据。</li>
</ul>
</li>
<li>对未来可能出现的需求变化的应对<strong>指南</strong>
<ul>
<li>进一步的变更将在此基线的基础上，依照项目的变更过程进行。</li>
<li>我知道变更被批准后，我们可能要重新协商对项目成本、资源和进度的约定</li>
</ul>
</li>
</ul>
<h2 id="敏捷过程"><a class="markdownIt-Anchor" href="#敏捷过程"></a> 敏捷过程</h2>
<h3 id="敏捷过程概述"><a class="markdownIt-Anchor" href="#敏捷过程概述"></a> 敏捷过程概述</h3>
<p>敏捷过程(Agile Process, AP)。</p>
<p>AP内容及特点:</p>
<ul>
<li>软件开发宣言<br>
软件团队具有快速工作、快速响应变化的能力</li>
<li>4条基本价值观+12条原则<br>
过程模型+人员+方法+产品及关系</li>
</ul>
<h3 id="敏捷过程的价值观与原则"><a class="markdownIt-Anchor" href="#敏捷过程的价值观与原则"></a> 敏捷过程的价值观与原则</h3>
<p>十二条原则：</p>
<ol>
<li>最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意</li>
<li>即使到了开发的后期，也欢迎改变需求，敏捷过程利用变化来为客户创造竞争优势</li>
<li>经常性交付可以工作的软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好</li>
<li>在整个项目开发期间，商务人员和开发人员必须天天都工作在一起</li>
<li>围绕被激励起来的个体来构建项目，给他们提供所需的环境和支持，并且信任他们能够完成工作</li>
<li>在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈</li>
<li>工作的软件是首要的进度度量标准</li>
<li>敏捷过程提倡可持续的开发速度，责任人、开发者和用户应该能够保持一个长期、恒定的开发速度</li>
<li>不断地关注优秀设计的技能和好的设计会增强敏捷能力</li>
<li>简单——使未完成的工作最大化的艺术——是根本的</li>
<li>最好的构架、需求和设计出自于自组织的团队</li>
<li>每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应对自己的行为进行调整</li>
</ol>
<p>四条价值观：</p>
<ol>
<li>个体和交互胜过过程和工具</li>
<li>可以工作的软件胜过面面俱到的文档</li>
<li>客户合作胜过合同谈判</li>
<li>响应变化胜过遵循计划</li>
</ol>
<h3 id="极限编程extreme-programming"><a class="markdownIt-Anchor" href="#极限编程extreme-programming"></a> 极限编程（extreme programming）</h3>
<p>极限编程提出了十四项最佳实践</p>
<ol>
<li>客户作为团队成员</li>
<li>用户故事</li>
<li>短交付周期</li>
<li>验收测试</li>
<li>结对编程</li>
<li>测试驱动开发</li>
<li>集体所有权</li>
<li>持续集成</li>
<li>可持续的开发速度</li>
<li>开放的工作空间</li>
<li>计划游戏</li>
<li>简单的设计</li>
<li>重构</li>
<li>隐喻</li>
</ol>
<h3 id="scrum"><a class="markdownIt-Anchor" href="#scrum"></a> SCRUM</h3>
<p>SCRUM是一个包括预定义<strong>角色</strong>和一系列<strong>实践</strong>的<strong>迭代式增量</strong>过程框架，整个生命周期在固定的时间段完成，称为Sprint，通常需要2-4周。</p>
<p><img src="https://web-static.wrike.com/cdn-cgi/image/format=auto,quality=80,width=1208,dpr=1/tp/storage/uploads/92025823-45d4-4b1c-bcef-6dffd4727344/scrum-cycle-resized.png" alt><br>
过程模型（迭代式增量）：</p>
<ol>
<li>
<p>Product Backlog（计划和体系结构设计）<br>
按照优先级形成Product Backlog列表，为急待完成的系列任务；建立系统体系结构并分解Product Backlog。</p>
</li>
<li>
<p>Sprint<br>
由若干个快速迭代的Sprint组成。一个Sprint限定周期为2-4周；一个Sprint由开发（设计、开发、实施、测试、文档化）、打包(Wrap)、评审（Review）、调整（Adjust）组成；每个 SCRUM 小组并行开发且同步完成。</p>
</li>
<li>
<p>交付和巩固<br>
类似传统方法中的维护和改善，包括组装、系统测试和回归测试等</p>
</li>
</ol>
<p>过程可视化：<br>
每日会议+燃尽图<br>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/SampleBurndownChart.svg/1920px-SampleBurndownChart.svg.png" alt></p>
<p>SCRUM的三个过程特点：<br>
<strong>应用工业过程控制概念</strong>，过程包括</p>
<ul>
<li><em>确定性过程</em>(Defined Process)<br>
可明确描述的、可预测的过程，因而可重复（Repeatable）执行并能产生预期的结果，并能通过科学理论对其最优化.</li>
<li><em>经验性过程</em>(Empirical Process)<br>
与确定性过程相反，作为一个黑箱（Black box）处理，通过对黑箱的输入输出不断进行度量，在此基础上，结合经验判断对黑箱进行调控，使其不越出设定的边界，从而产生满意的输出。</li>
</ul>
<p>SCRUM<strong>将开发中的分析、设计、实施视为一个Sprint黑箱</strong>，认为应加强黑箱内部的混沌性，使项目组工作在混沌的边沿，充分<strong>发挥人的创造力</strong>。如将经验性过程按确定性过程处理（如瀑布模型），必将使过程缺乏适应变化的能力。</p>
<p>SCRUM角色：</p>
<ul>
<li>“猪”组角色：全身投入项目中，没有退路
<ul>
<li>Product Owner<br>
更新 Product Backlog并按优先级排定</li>
<li>SCRUM Master<br>
领导SRCUM Team, 负责屏蔽外界干扰，确保Scrum过程顺利执行</li>
<li>SCRUM Team<br>
每个Team由5-9名具跨职能技能的设计和开发者等组成,负责交付产品；小组的划分最好是功能导向的（按所分配的问题包或Backlog），也可是系统层次导向（按体系结构中的分层）</li>
</ul>
</li>
<li>“鸡”组角色：参与项目，项目失败损失也不大
<ul>
<li>用户,利益相关者（客户，投资方，供应商）等</li>
<li>给项目提供了反馈，必不可少</li>
</ul>
</li>
</ul>
<h2 id="统一过程-rup"><a class="markdownIt-Anchor" href="#统一过程-rup"></a> 统一过程 RUP</h2>
<h3 id="rup概述"><a class="markdownIt-Anchor" href="#rup概述"></a> RUP概述</h3>
<p>RUP内容及特点:</p>
<ul>
<li>一种典型完整的<strong>软件过程模式</strong><br>
生命周期模型(过程模型)：<strong>迭代且增量</strong><br>
人员：角色≠个体<br>
方法：<strong>用例驱动，以构架为核心</strong><br>
产品：工件</li>
<li>一种软件过程产品
<ul>
<li>Rational/IBM公司开发并维护</li>
<li>与Rational一系列其它软件开发工具集成</li>
</ul>
</li>
</ul>
<h3 id="rup的软件过程模型"><a class="markdownIt-Anchor" href="#rup的软件过程模型"></a> RUP的软件过程模型</h3>
<p><img src="https://www.mindcrafts.ch/emi2020/wp-content/uploads/2020/07/RUP-Phase-Model-1.png" alt></p>
<ul>
<li>横轴：<br>
时间组织<br>
体现动态结构<br>
术语：阶段、里程碑、迭代和增量</li>
<li>纵轴：<br>
内容组织<br>
体现静态结构<br>
术语：工作流程、活动、角色、工件</li>
</ul>
<p>每个循环：交付产品一个版本，包含四个连续阶段<br>
每个阶段： 一次或多次迭代过程，结束于主要里程碑及意义<br>
每次迭代过程：</p>
<ul>
<li>经历的核心工作流程：最多可能9个</li>
<li>工作流程剪裁依据：当前迭代所处的阶段 +上次迭代的结果</li>
<li>工作流程剪裁要求：
<ul>
<li>迭代过程要处理一组用例：<br>
用例合起来能够扩展所开发产品的可用性</li>
</ul>
</li>
<li>迭代过程要解决最突出的风险问题<br>
一次迭代达到的预定目标——原有工件的一个增量，否则试用一种新的方法</li>
</ul>
<h4 id="纵轴元素"><a class="markdownIt-Anchor" href="#纵轴元素"></a> 纵轴元素</h4>
<p>生命周期中的静态结构——九个核心工作流程。工作流程代表了所有角色、活动与工件的逻辑分组情况，即软件过程模式中的三个要素。</p>
<ol>
<li>业务建模（Business Modeling）<br>
原理：描述如何拟定客户组织的前景，并基于该前景来确定该组织在业务用例模型和业务对象模型中的流程、角色以及职责 。
<ul>
<li>涉及的主要角色：业务流程分析员、业务设计员、业务模型复审员</li>
<li>产生的主要工件：<strong>业务模型</strong>（业务用例模型+业务对象模型）<br>
<strong>本质</strong>：业务需求的构建方法——领域工程</li>
<li>意义：
<ul>
<li>打造软件核心竞争力的途径<br>
例：12306，饭店点餐APP</li>
<li>不同的业务建模决定软件不同的命运</li>
</ul>
</li>
<li>启示：业务建模对开发人员提出了更高层次的要求
<ul>
<li>具备不同行业专业领域的专业知识</li>
<li>主动自学习——行业领域的选择与超前规划</li>
</ul>
</li>
</ul>
</li>
<li>需求<br>
目标是描述系统应该做什么，即捕获需求，并使开发人员和用户就这一需求描述达成共识。
<ul>
<li>用例方法<br>
对需要的功能和约束进行提取、组织、文档化，理解系统所解决问题的定义和范围；</li>
<li>涉及的主要角色 ：<br>
系统分析员、用户界面设计员、需求复审员</li>
<li>产生的主要工件 ：<br>
<strong>用例模型</strong>，<strong>用户界面模型</strong></li>
</ul>
</li>
<li>分析设计<br>
将需求转化成未来系统的设计，为系统开发一个健壮的结构并调整设计使其与实现环境相匹配，优化其性能。<br>
以构架设计为中心→产品的适应性、可扩展性
<ul>
<li>涉及的主要角色 ：<br>
构架设计师、构架复审员、设计员、数据库设计、设计复审员</li>
<li>产生的主要工件：
<ul>
<li><strong>一个设计模型</strong><br>
设计类：组织成具有良好接口的设计包（Package）和设计子系统(Subsystem)描述：体现了类的对象如何协同工作实现用例的功能</li>
<li>一个分析模型（可选）</li>
</ul>
</li>
</ul>
</li>
<li>实现<br>
以构件的形式(源文件、二进制文件、可执行文件)实现类和对象并测试；以层次化的子系统形式定义代码的组织结构；将各实施员完成的结果集成到可执行系统中。
<ul>
<li>涉及的主要角色 ：<br>
构架设计员、实施员、集成员、代码复审员</li>
<li>产生的主要工件 ：<br>
<strong>实施模型</strong>（模型元素包括实施子系统和构件）</li>
</ul>
</li>
<li>测试<br>
验证产品的功能和性能，如对象间的交互作用、所有构件是否正确集成、所有的需求是否已被正确的实现，识别确认缺陷并确保在部署前解决之。
<ul>
<li>涉及的主要角色 ：<br>
测试设计员，测试员</li>
<li>产生的主要工件：<br>
<strong>测试模型</strong>（模型元素包括测试用例、测试过程和测试构件）+测试结果</li>
</ul>
</li>
<li>部署<br>
描述了三种产品部署的模式：包括自定义安装、市售和通过Internet使用软件；在每种模式中，都强调要在开发场所对产品进行测试，并在产品最终发布之前进行Beta测试。
<ul>
<li>涉及的主要角色：<br>
部署经理、实施员、技术文档编写员、课程开发员</li>
<li>产生的主要工件：<br>
<strong>产品的一个版本</strong>+<strong>文档培训资料</strong></li>
</ul>
</li>
<li>配置和变更管理<br>
描绘如何在多个成员组成的项目中控制大量的产物，并提供了准则来管理演化系统中的多个变体，跟踪软件创建过程中的版本。
<ul>
<li>涉及的主要角色 ：<br>
配置经理、变更控制经理、集成员</li>
<li>产生的主要工件 ：<br>
配置管理计划、变更请求、项目存储库和工作区</li>
</ul>
</li>
<li>项目管理<br>
平衡竞争的目标、管理风险并克服各种约束，从而成功交付使用户满意的产品，包括为项目的管理提供框架，为计划、人员配备、执行和监控项目提供实用的准则，为管理风险提供框架等。
<ul>
<li>涉及的主要角色 ：<br>
项目经理、项目复审员</li>
<li>产生的主要工件 ：<br>
商业理由、迭代计划、风险管理计划、质量保证计划及相应的评估文档</li>
</ul>
</li>
<li>环境<br>
向软件开发组织提供软件开发的环境，包括过程和工具。
<ul>
<li>涉及的主要角色 ：<br>
过程工程师、工具专家</li>
<li>产生的主要工件 ：<br>
工作流程指南、工具、工具指南</li>
</ul>
</li>
</ol>
<h4 id="横轴元素"><a class="markdownIt-Anchor" href="#横轴元素"></a> 横轴元素</h4>
<p>生命周期中的动态结构——<strong>四个阶段</strong><br>
每个阶段：由一次或多次迭代完成，迭代过程是受控的：</p>
<ul>
<li>项目计划中 ：制定
<ul>
<li>迭代的次数</li>
<li>每次迭代的持续时间</li>
<li>每次迭代的目标</li>
</ul>
</li>
<li>详细迭代计划中 ：制定
<ul>
<li>具体的工作流程</li>
</ul>
</li>
</ul>
<ol>
<li>先启阶段（Inception Phase）</li>
</ol>
<ul>
<li>目标：建立业务用例、确定项目的边界</li>
<li>结束里程碑：生命周期目标里程碑</li>
<li>评审标准
<ul>
<li>规模定义和成本／进度估算中，涉众可并行</li>
<li>对是否已经获得正确的需求集达成一致意见，并且对这些需求的理解是共同的</li>
<li>对成本／进度估算、优先级、风险和开发流程是否合适达成一致意见</li>
<li>已经确定所有风险并有针对每个风险的减轻策略</li>
</ul>
</li>
</ul>
<ol start="2">
<li>精化阶段</li>
</ol>
<ul>
<li>目标：建立稳定的构架、编制项目计划、淘汰项目中最高风险的元素</li>
<li>结束里程碑：生命周期构架里程碑</li>
<li>评审标准
<ul>
<li>产品前景和需求是稳定的</li>
<li>构架是稳定的</li>
<li>可执行原型表明已经找到了主要的风险元素，并且得到妥善解决</li>
<li>构建阶段的迭代计划足够详细和真实，可以保证工作继续进行</li>
<li>构建阶段的迭代计划由可靠的估算支持</li>
<li>所有涉众一致认为，如果在当前构架环境中执行当前计划来开发完整的系统，则当前的前景可以实现</li>
<li>实际的资源耗费与计划的耗费相比是可以接受的</li>
</ul>
</li>
</ul>
<ol start="3">
<li>构建阶段（Construction Phase）</li>
</ol>
<ul>
<li>目标：所有构件和应用程序功能被开发并集成为产品、所有的功能被详尽的测试</li>
<li>结束里程碑：最初操作性能里程碑</li>
<li>评审标准
<ul>
<li>该产品发布版是否足够稳定和成熟，可部署在用户群中？</li>
<li>所有涉众是否已准备好将产品发布到用户群？</li>
<li>实际的资源耗费与计划的相比是否仍可以接受？</li>
</ul>
</li>
</ul>
<ol start="4">
<li>产品化阶段</li>
</ol>
<ul>
<li>目标：将软件产品交付给用户群体</li>
<li>结束里程碑：产品发布里程碑</li>
<li>评审标准
<ul>
<li>用户是否满意？</li>
<li>实际的资源耗费与计划的耗费相比是否可以接受？</li>
</ul>
</li>
</ul>
<h2 id="uml"><a class="markdownIt-Anchor" href="#uml"></a> UML</h2>
<h3 id="面向对象概述"><a class="markdownIt-Anchor" href="#面向对象概述"></a> 面向对象概述</h3>
<ul>
<li>面向对象的含义？
<ul>
<li>软件方法学、从现实世界中客观存在的事物（即对象）出发来构造软件系统。</li>
<li>对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。</li>
</ul>
</li>
<li>对象
<ul>
<li>对象具有行为——刻画对象的静态特征</li>
<li>对象具有属性值——刻画对象的动态特征</li>
<li>对象包含数据和操作该数据的方法</li>
</ul>
</li>
<li>面向对象的三大要素是什么？
<ul>
<li>封装
<ul>
<li>把对象的状态信息隐藏在类的内部，不允许外部程序直接访问</li>
<li>结合性、信息隐蔽性</li>
</ul>
</li>
<li>继承
<ul>
<li>从已知一个类派生出新的类，叫子类。</li>
<li>使子类更加简洁；能够重用和扩展类库；使软件易于维护和修改</li>
</ul>
</li>
<li>多态
<ul>
<li>具有多种表现形态的能力的特征。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="uml概述"><a class="markdownIt-Anchor" href="#uml概述"></a> UML概述</h3>
<ul>
<li>UML是什么？
<ul>
<li>一种标准化的图形建模语言，是面向对象分析与设计的标准表示。</li>
</ul>
</li>
<li>被定为国际标准的UML 版本是什么？
<ul>
<li>2011年8月UML2.4.1，2012年5月ISO/IEC 19505-1:2012，ISO/IEC 19505-2:2012</li>
</ul>
</li>
<li>UML2 版本中的图有那些？
<ul>
<li>静态(7种)：类图、对象图、构件图、部署图、包图、组合结构图、外廓图</li>
<li>动态(7种)：顺序图、通信图、时间图、交互纵览图、活动图、状态机图、用例图</li>
</ul>
</li>
</ul>
<h3 id="用例"><a class="markdownIt-Anchor" href="#用例"></a> 用例</h3>
<p>内容：</p>
<ul>
<li>用例
<ul>
<li>参与者使用系统的<strong>一项功能</strong>的交互过程的描述序列。</li>
<li>特点：
<ul>
<li>可观测：止于系统边界</li>
<li>结果值：是有意义的目标</li>
<li>系统执行：结果由系统生成</li>
<li>由参与者观测：用词是业务语言、用户观点</li>
</ul>
</li>
<li>命名：动词+宾语，慎用弱名词</li>
</ul>
</li>
<li>参与者
<ul>
<li>指<strong>系统之外</strong>、与系统交互的<strong>任何事务</strong></li>
<li>识别参与者：系统由谁使用、谁向系统提供消息、对系统维护、与系统的需求有关联</li>
<li>时间参与者：激活系统定期、自动执行的用例</li>
<li>命名：角色而非具体名称</li>
</ul>
</li>
<li>系统边界</li>
</ul>
<p>用例间的关系：</p>
<ul>
<li>泛化关系</li>
<li>包含关系&lt;&lt;include&gt;&gt;<br>
基本用例包含了包含用例的行为</li>
<li>扩展关系&lt;&lt;extend&gt;&gt;<br>
扩展用例可以增强基本用例的行为</li>
</ul>
<h4 id="用例文档"><a class="markdownIt-Anchor" href="#用例文档"></a> 用例文档</h4>
<p>组织形式：</p>
<ul>
<li>用例</li>
<li>路径</li>
<li>步骤</li>
<li>补充约束</li>
</ul>
<p><em>组成</em>：</p>
<ul>
<li>用例名</li>
<li>参与者</li>
<li>相关用例</li>
<li>前置条件，后置条件
<ul>
<li>前置条件约束在用例开始前系统的状态</li>
<li>后置条件约束用例执行后系统的状态</li>
</ul>
</li>
<li>事件流
<ul>
<li>基本路径</li>
<li>备选路径</li>
</ul>
</li>
<li>补充约束
<ul>
<li>字段列表、业务规则</li>
<li>非功能需求，设计约束</li>
</ul>
</li>
</ul>
<p><em>编写要点</em>：</p>
<ul>
<li>使用自然语言</li>
<li>描述参与者与系统交互</li>
<li>不细化GUI</li>
<li>分支和循环的描述（分支放在备选事件流）</li>
</ul>
<h3 id="状态图和活动图"><a class="markdownIt-Anchor" href="#状态图和活动图"></a> 状态图和活动图</h3>
<p><strong>状态机图</strong>主要用于描述一个对象在其生存期间的<strong>动态行为</strong>，表现一个对象所经历的<strong>状态序列</strong>、引起状态转移的<strong>事件</strong>（event）以及因状态转移而伴随的<strong>动作</strong>（action）。</p>
<p><em>状态图基本概念</em>：</p>
<ul>
<li>事件<br>
可以分为四类：调用事件、变化事件、时间事件、信号事件
<ul>
<li>调用事件：对操作的调度<code>event-name(params)</code></li>
<li>变化事件：满足某种条件时，进行动作<code>when(cond)</code></li>
<li>时间事件：满足某一事件表达式：<code>after(some)</code> <code>when(cond)</code></li>
<li>信号事件：接收到某种信号</li>
</ul>
</li>
<li>状态
<ul>
<li>对象生命周期的一个阶段</li>
<li>初态、终态、中间态、复合状态（可进一步细化的状态）</li>
<li>细化的状态表达：状态名、状态变量、活动</li>
</ul>
</li>
<li>动作
<ul>
<li>可执行的原子计算</li>
<li><code>entry</code>、<code>exit</code>、<code>do</code></li>
</ul>
</li>
<li>转换
<ul>
<li>两个状态之间的关系，满足条件时，一个状态进入第二个状态</li>
<li><code>事件特征表示[监护条件]/动作表达式</code></li>
</ul>
</li>
</ul>
<p><strong>活动图</strong> 用于表达系统<strong>动态特性</strong>，描述系统的<strong>工作流程和并发行为</strong>。活动图可以看作状态图的特殊形式。</p>
<p><em>活动图基本概念</em>：</p>
<ul>
<li>活动：
<ul>
<li>流程中任务的执行</li>
<li>包括初态、终态、判断、同步</li>
<li>无标注表示顺序执行</li>
</ul>
</li>
<li>泳道：
<ul>
<li>根据职责划分活动区域</li>
</ul>
</li>
<li>分支：
<ul>
<li>对于同一个触发事件，根据不同的警戒条件转向不同的活动</li>
</ul>
</li>
<li>分叉：
<ul>
<li>表示并发行为</li>
</ul>
</li>
<li>汇合：
<ul>
<li>表示并发行为</li>
</ul>
</li>
</ul>
<p><em>状态图和活动图的比较</em>：</p>
<ul>
<li>它们都是对系统的<strong>动态行为</strong>建模。</li>
<li>两者描述重点不同。状态图描述的是对象的状态及状态之间的<strong>转移</strong>，活动图描述的是从活动到活动的<strong>控制流</strong>。</li>
<li>两者使用的场合不同。若是为了显示<strong>一个对象</strong>在其生命周期内的行为，则使用状态图较好，若为了分析用例、理解涉及<strong>多个用例</strong>的工作流程或处理多线程应用等，则使用活动图较好。</li>
</ul>
<h3 id="类图和顺序图"><a class="markdownIt-Anchor" href="#类图和顺序图"></a> 类图和顺序图</h3>
<p><strong>类图</strong>显示一组类、接口、写作及它们之间的关系。</p>
<p>类图包含<strong>七个元素</strong>：类、接口、协作、依赖关系、泛化关系、实现关系和关联关系。</p>
<p><em>类</em>：类名+属性+方法</p>
<p>常见的四种关系：</p>
<ul>
<li>依赖关系：
<ul>
<li>使用关系，一个事务的变化影响使用它的事务，反之不然</li>
<li>形式：使用、追踪、精华、实现、派生</li>
<li>虚线箭头</li>
</ul>
</li>
<li>泛化关系（继承关系）：
<ul>
<li>子元素共享父元素的结构和行为</li>
<li>子元素可以替代父元素</li>
<li>空心实线箭头</li>
</ul>
</li>
<li>关联关系：
<ul>
<li>是一种结构关系</li>
<li>聚合关系：整体-部分，两者的生命周期没有关联</li>
<li>组合关系：整体-部分，部分完全依赖于整体</li>
<li>菱形箭头，标有数量关系</li>
</ul>
</li>
<li>实现关系
<ul>
<li>类实现接口</li>
<li>虚线空心箭头</li>
</ul>
</li>
</ul>
<p><em>高级概念</em>：</p>
<ul>
<li>抽象类
<ul>
<li>不可实例化</li>
</ul>
</li>
<li>模板类
<ul>
<li>含有模板——未绑定形参的元素</li>
</ul>
</li>
<li>关联类
<ul>
<li>体现了两种类之间的关联关系</li>
</ul>
</li>
<li>分析类<br>
系统中负责具体职责的类
<ul>
<li>边界类：用于对系统外部环境与其内部运作之间的交互进行建模的类。</li>
<li>控制类：对一个或多个用例所特有的控制行为进行建模的类。</li>
<li>实体类：用于对必须存储的信息和相关行为建模的类。</li>
</ul>
</li>
</ul>
<p><strong>顺序图</strong>是按时间顺序显示对象交互的图，一般用于确认和丰富一个使用情境的逻辑。</p>
<p>顺序图作用：</p>
<ul>
<li>细化用例表达</li>
<li>有效描述类职责的分配，明确对象所属类的职责</li>
<li>丰富系统使用语境的逻辑表达</li>
</ul>
<p>四个元素：</p>
<ul>
<li>对象：类的实例</li>
<li>生命线：表示参与对象的存在，一直可以访问，用<code>X</code>标记生命线的结束</li>
<li>激活：表示对象执行一个动作的时间段</li>
<li>消息：一个对象向另一个对象发送信号
<ul>
<li>类型：简单消息（实线箭头）、调用（实心实线箭头）、返回（空心箭头）</li>
<li>同步消息、异步消息（一半箭头）</li>
</ul>
</li>
</ul>
<p>结构化控制：</p>
<ul>
<li>可选片段：<code>opt</code>，表示单条件分支</li>
<li>条件片段：<code>alt</code>，表示多条件分支</li>
<li>并行片段：<code>par</code>，表示片段内有多个并行子片段</li>
<li>循环片段：<code>loop</code>，表示一个循环</li>
<li>交互片段：<code>ref</code>，表示引用一段交互</li>
</ul>
<h2 id="软件设计"><a class="markdownIt-Anchor" href="#软件设计"></a> 软件设计</h2>
<h3 id="软件设计基础"><a class="markdownIt-Anchor" href="#软件设计基础"></a> 软件设计基础</h3>
<p>何为软件设计？</p>
<ul>
<li>针对软件需求，综合考虑各种制约因素，探究软件实现的解决方案。</li>
<li>设计前提：软件需求</li>
<li>设计考虑：制约因素（资源、技术）</li>
</ul>
<p>软件设计的目标：</p>
<ul>
<li>软件需求和实现代码之间的桥梁</li>
<li>应对软件开发的复杂性挑战</li>
<li>应对软件开发的变化性挑战</li>
</ul>
<p>软件设计的层次：</p>
<ul>
<li>概要设计
<ul>
<li>数据设计</li>
<li>体系结构设计</li>
</ul>
</li>
<li>详细设计
<ul>
<li>组件接口设计</li>
<li>组件级设计</li>
</ul>
</li>
</ul>
<p>软件设计的质量要求：</p>
<ul>
<li>正确性：正确实现软件需求项</li>
<li>充分性：所有设计元素充分细化</li>
<li>优化性：以合理的、充分优化的方式实现软件需求模型</li>
<li>简单性：模型中的模块的功能或职责尽可能简明易懂</li>
</ul>
<h4 id="软件设计过程"><a class="markdownIt-Anchor" href="#软件设计过程"></a> 软件设计过程</h4>
<ul>
<li>体系结构设计→体系结构模型<br>
从全局和宏观视角设计软件系统</li>
<li>用户界面设计→用户界面模型<br>
设计软件对外展示以及与用户进行交互的界面，关注软件如何与用户进行交互</li>
<li>软件详细设计→详细设计模型<br>
对体系结构设计和人机交互设计成果进行细化和精化，获得高质量的、充分细化的软件设计模型</li>
<li>文档化软件设计→软件设计文档</li>
<li>软件设计评审</li>
</ul>
<h4 id="常用设计概念原则"><a class="markdownIt-Anchor" href="#常用设计概念原则"></a> 常用设计概念（原则）</h4>
<ul>
<li>分解（Decomposition）与抽象（Abstraction）<br>
分解：将软件不断分解到更细粒度的代码单元。<br>
抽象：忽略无关细节，只保留与当前问题相关的关键信息。<br>
好的抽象屏蔽底层细节，突出事物本质特征，符合人的思考方式。</li>
<li>关注点分离<br>
关注点：针对概念、任务和目标的某个部分或者侧面的聚焦<br>
关注点分离：将性质不同的关注点分离开来，以便在适当的时间处理不同的关注点，随后整合成局部或全局设计结果<br>
面向切面编程（AOP）封装横切关注点</li>
<li>模块化
<ul>
<li>将整个系统分解为大小合适、相对独立的模块
<ul>
<li>使得各个模块的生产独立进行</li>
<li>易于替换和扩展</li>
</ul>
</li>
</ul>
</li>
<li>衡量模块独立性的内聚度和耦合度<br>
高内聚、低耦合
<ul>
<li>常见内聚：功能内聚、层次内聚、通信内聚、顺序内聚、过程内聚、时间内聚、功用内聚</li>
<li>实现功能内聚：分解</li>
<li>常见耦合：内容耦合、共用耦合、控制耦合、印记耦合、数据耦合</li>
<li>避免内容耦合：信息隐藏；避免控制耦合：多态；避免印记耦合：修改参数</li>
</ul>
</li>
<li>重构<br>
在不改变代码外在行为的前提下，对代码作出修改以改进程序的内部结构<br>
目的：提高软件的可维护性和可扩展性</li>
<li>信息隐藏
<ul>
<li>信息对那些不需要这些信息的模块不可访问</li>
<li>仅仅交换那些为完成系统功能所必需交换的信息</li>
<li>好处：
<ul>
<li>屏蔽细节、暴露接口，降低其他开发者对模块认知的复杂性</li>
<li>降低了内部实现对其他模块的影响</li>
<li>通过受控接口提供访问，实现对内部数据和操作的保护</li>
</ul>
</li>
</ul>
</li>
<li>复用</li>
</ul>
<h4 id="面向对象软件设计方法学"><a class="markdownIt-Anchor" href="#面向对象软件设计方法学"></a> 面向对象软件设计方法学</h4>
<p>针对面向对象的需求分析得到的软件需求模型（用例图、交互图、分析类图等），对其不断<strong>精化</strong>，获得软件系统的各类软件设计元素（子系统、构件、设计类），产生<strong>软件设计模型</strong>，形成软件系统<strong>设计方案</strong>。</p>
<p>包括内容（详细设计）：</p>
<ul>
<li>用例设计</li>
<li>构件/子系统设计</li>
<li>数据设计</li>
<li>类设计</li>
</ul>
<p><em>优势</em>：</p>
<ul>
<li>高层抽象和自然过渡</li>
<li>多种形式和粗粒度的软件重用</li>
<li>系统化的软件设计</li>
<li>支持软件的扩展和变更</li>
</ul>
<h4 id="软件评审"><a class="markdownIt-Anchor" href="#软件评审"></a> 软件评审</h4>
<p><em>作用</em>：发现和纠正软件设计中存在的缺陷</p>
<p><em>输出</em>：</p>
<ul>
<li>软件设计模型</li>
<li>软件设计文档</li>
</ul>
<h3 id="软件体系结构设计"><a class="markdownIt-Anchor" href="#软件体系结构设计"></a> 软件体系结构设计</h3>
<p>定义：是指系统的一个或者多个结构，它包括软件构件、构件的外部可见属性以及它们之间的相互关系。</p>
<p>内容：</p>
<ul>
<li>一组软件组件（构件）</li>
<li>软件组件的外部属性</li>
<li>软件组件之间的关系</li>
<li>全局的实现约定</li>
</ul>
<p>作用：</p>
<ul>
<li>初步确认设计方案是否能有效满足需求</li>
<li>为满足未来演化和复用的需要而做出规划</li>
<li>多种候选技术方案对比选择的依据</li>
<li>识别并降低软件实现的风险</li>
<li>软件开发任务分工协作的基础</li>
<li>相关涉众沟通和交流的基础</li>
</ul>
<p>软件体系结构决策的几个方面：</p>
<ul>
<li>目标与条件</li>
<li>效用函数</li>
<li>约束</li>
</ul>
<p>解决非功能性需求：</p>
<ul>
<li>可维护性、可扩展性：组件粒度小、相对独立、松耦合；避免共享数据</li>
<li>性能：分布式部署、缓存</li>
<li>可靠性、可用性：冗余副本、隔离组件与副本</li>
<li>安全性：身份认证、安全加密与传输</li>
</ul>
<p>设计元素：</p>
<ul>
<li>构件
<ul>
<li>物理模块、具有对外接口</li>
<li>可分离、可替换、可配置、可复用</li>
</ul>
</li>
<li>连接件
<ul>
<li>表示软构件之间的连接和交互关系</li>
<li>过程调用、远程过程调用（RPC）、消息传递等</li>
</ul>
</li>
<li>连接和接口
<ul>
<li>构件通过接口对外提供服务，与其他构件交互</li>
<li>两种接口：供给接口、需求接口</li>
<li>连接端口</li>
</ul>
</li>
<li>约束
<ul>
<li>高层次可以向低层次发送请求，低层次向高层次应答，反之不行</li>
<li>层次是可替换的</li>
</ul>
</li>
</ul>
<p>不同视图：</p>
<ul>
<li>逻辑视图
<ul>
<li>包图：构成关系、依赖关系</li>
<li>构件图</li>
</ul>
</li>
<li>运行视图
<ul>
<li>活动图、对象图</li>
</ul>
</li>
<li>开发视图
<ul>
<li>软件运行时进程、线程的划分，它们之间的并发和同步，它们与逻辑视图和开发视图之间的映射关系</li>
<li>分包、目录结构</li>
</ul>
</li>
<li>物理视图
<ul>
<li>部署视图：物理机器及连接、工件允许情况
<ul>
<li>工件：软件系统中相对独立的物理实现单元</li>
<li>逻辑层面的描述性部署图、物理层面的实例性部署图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="软件体系风格"><a class="markdownIt-Anchor" href="#软件体系风格"></a> 软件体系风格</h4>
<ul>
<li>数据中心体系结构<br>
围绕知识库进行交互
<ul>
<li>优点：实现简单，组件耦合度松</li>
<li>缺点：数据过大时效率低，数据库定义不合适会引起扩展困难</li>
</ul>
</li>
<li>数据流体系结构<br>
“过滤器”进行处理，“管道”表示连接、控制走向
<ul>
<li>优点：适合数据传输与处理为主的系统</li>
<li>缺点：不适合人机交互强的系统</li>
</ul>
</li>
<li>层次体系结构<br>
每个层次都有功能划分，上层依赖于下层，层次接口隔离，体现分解与抽象的原则
<ul>
<li>优点：解耦开发任务、隔离变更的影响、标准化接口提高可移植性</li>
<li>缺点：难以实现清晰的层次，分层过多降低性能，难以针对性定制和优化</li>
</ul>
</li>
<li>面向对象体系结构<br>
将逻辑上的实体和关系映射为对象和关系
<ul>
<li>优点：高度模块化、灵活、易维护</li>
<li>缺点：必须知道一个对象的签名才能调用，提高了对象间的依赖性。</li>
</ul>
</li>
<li>调用和返回体系结构
<ul>
<li>易于修改和扩展</li>
</ul>
</li>
</ul>
<h4 id="软件体系结构设计的任务"><a class="markdownIt-Anchor" href="#软件体系结构设计的任务"></a> 软件体系结构设计的任务</h4>
<p>任务：建立满足软件需求的软件体系结构</p>
<p>具体：</p>
<ul>
<li>明确定义各子系统、构建、关键类的职责划分和协作关系</li>
<li>明确它们在物理运行环境下的部署</li>
</ul>
<p>特点：针对全局给出技术方案、宏观</p>
<p>重要性和关键性：</p>
<ul>
<li>承上启下
<ul>
<li>软件需求 — 详细设计，后续的详细设计和软件实现的主要工作基础</li>
</ul>
</li>
<li>影响深远
<ul>
<li>对性能、灵活性、可修改性、可扩充性等质量需求的影响是决定性的，软件质量的瓶颈</li>
</ul>
</li>
<li>定型质量
<ul>
<li>对软件质量的全局性、决定性影响</li>
</ul>
</li>
</ul>
<p>过程：</p>
<ul>
<li>设计初步的软件体系结构<br>
基于需求，参考已有风格，给出初步和粗糙的架构</li>
<li>重用可用的软件资源</li>
<li>精化软件体系结构
<ul>
<li>确定软件体系结构依赖的公共基础设施</li>
<li>确立设计元素
<ol>
<li>确定子系统及其接口</li>
<li>确定构件及其接口</li>
<li>确定关键设计类及其接口</li>
</ol>
</li>
</ul>
</li>
<li>设计软件部署模型</li>
<li>文档化和评审软件体系结构</li>
</ul>
<h3 id="软件详细设计"><a class="markdownIt-Anchor" href="#软件详细设计"></a> 软件详细设计</h3>
<ul>
<li>面向对象的设计原则
<ul>
<li>是面向对象设计的基本指导思想</li>
<li>是评价面向对象设计的价值观体系</li>
<li>是设计模式的出发点和归宿</li>
</ul>
</li>
<li>面向对象的设计原则是构造高质量软件的出发点</li>
<li>构造出高质量软件，以保持系统稳定
<ul>
<li>设计目标
<ul>
<li>高可用性</li>
<li>高可靠性</li>
<li>高性能</li>
<li>高可支持性</li>
</ul>
</li>
</ul>
</li>
<li>什么是好的设计？
<ul>
<li>容易理解</li>
<li>容易修改和扩展</li>
<li>容易复用</li>
<li>容易实现与应用</li>
<li>简单、紧凑、经济适用</li>
</ul>
</li>
<li>让人工作起来心情愉快的设计</li>
<li>设计原则是提高设计质量的基本原则</li>
</ul>
<h4 id="面向对象的设计原则"><a class="markdownIt-Anchor" href="#面向对象的设计原则"></a> 面向对象的设计原则</h4>
<ul>
<li>LSP（Liskov替换原则）<br>
子类对象必须可以替换基类对象；子类不能添加父类没有的附加约束<br>
解决方法：实现抽象类</li>
<li>OCP（开放-封闭原则）<br>
软件对扩展开放，对更改封闭<br>
解决方法：使用抽象类</li>
<li>SRP（单一职责原则）<br>
就一个类而言，应该仅有一个引起它变化的原因<br>
体现了内聚性</li>
<li>ISP（接口隔离原则）<br>
客户不应该依赖他们用不到的接口（避免肥接口）<br>
使用多重继承（实现）分离接口，一个类实现多个接口，客户仅获知必须的接口</li>
<li>DIP（依赖倒置原则）
<ul>
<li>高层模块不依赖于底层模块，二者都依赖于抽象</li>
<li>抽象不依赖于细节，细节依赖于抽象</li>
<li>针对接口编程，不要针对实现编程</li>
<li>又称控制反转(IoC，Inversion of Control)、依赖注入</li>
</ul>
</li>
<li>LKP（最少知道原则）
<ul>
<li>一个实体应当尽少地与其他实体发生作用</li>
<li>解决办法：通过中间类建立联系</li>
</ul>
</li>
</ul>
<h4 id="软件设计模式"><a class="markdownIt-Anchor" href="#软件设计模式"></a> 软件设计模式</h4>
<ul>
<li>创建型模式
<ul>
<li>工厂方法模式(Factory Method) ----由子类决定要创建的具体类是哪一个</li>
<li>抽象工厂模式(Abstract Factory) ----允许客户创建对象的家族，而无需指定他们的具体类</li>
<li>建造者模式(Builder) ----使用建造者模式封装一个产品的构造过程，并允许按步骤构造</li>
<li>原型模式(Prototype) ----当创建给定类的实例过程很昂贵或很复杂时，就使用原型模式</li>
<li>单例模式(Singleton) ----确保有且只有一个对象被创建</li>
</ul>
</li>
<li>结构型模式
<ul>
<li>适配器模式(Adaper) ----封装对象，并提供不同的接口</li>
<li>桥接模式(Bridge) ----使用桥接模式不只改变你的实现，也改变你的抽象</li>
<li>组合模式(Composite) ----客户用一致的方式处理对象集合和单个对象</li>
<li><strong>装饰模式(Decorator)</strong> ----包装一个对象，以提供新的行为
<ul>
<li>目的：动态地给一个对象添加一些额外的职责</li>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>处理那些可以撤消的职责。</li>
<li>当不能采用生成子类的方法进行扩充时</li>
</ul>
</li>
<li>外观模式(Facade) ----简化一群类的接口</li>
<li>享元模式 (Flyweight) ---- 如果让某个类的一个实例能用来提供许多“虚拟实例”，就使用享元模式</li>
<li>代理模式(Proxy) ----包装对象，以控制对此对象的访问</li>
</ul>
</li>
<li>行为型模式
<ul>
<li>解释器模式(Interpreter) ---- 使用解释器模式为语言创建解释器</li>
<li>模板方法模式(Template Method) ----由子类决定如何实现一个算法中的步骤</li>
<li>职责链模式(Chain of Responsibility) ---- 让一个以上的对象有机会能够处理某个请<br>
求的时候使用</li>
<li>命令模式(Command) ----封装请求成为对象</li>
<li>迭代器模式(Iterator) ----在对象的集合之中游走，而不暴露集合的实现</li>
<li>中介者模式 (Mediator) ---- 使用中介者模式来集中相关对象之间复杂的沟通和控制方式</li>
<li>备忘录模式(Memento) ---- 当你需要让对象返回之前的状态时，就使用备忘录模式</li>
<li>观察者模式(Observer)---- 让对象能够在状态改变时被通知</li>
<li>状态模式(State)---- 封装了基于状态的行为，并使用委托在行为之间切换</li>
<li>策略模式(Strategy)---- 封装可以互换的行为，并使用委托来决定要使用哪一个</li>
<li>访问者模式(Visitor)---- 为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式</li>
</ul>
</li>
</ul>
<p><em>模式思维</em>：</p>
<ul>
<li>根本意图：适应需求变更</li>
<li>核心思维：
<ul>
<li>应对变更的直接手段是封装变更</li>
<li>封装复杂性，多态包容</li>
<li>多态包容：封装抽象基类的引用而不是具体类的引用</li>
</ul>
</li>
<li>实现思路：
<ul>
<li>增加间接层</li>
<li>针对接口编程</li>
<li>优先使用聚合而不是继承</li>
</ul>
</li>
</ul>
<h3 id="软件测试"><a class="markdownIt-Anchor" href="#软件测试"></a> 软件测试</h3>
<p><em>目的</em>：</p>
<ul>
<li><em>验证</em>：确保软件正确实现特定功能的任务集合</li>
<li><em>确认</em>：确保已构建的软件可以追溯到客户的需求</li>
</ul>
<p><em>不同阶段测试</em>：</p>
<ul>
<li><em>单元测试</em>：代码生成
<ul>
<li>编写测试用例（接口、局部数据结构、边界条件、独立路径、错误处理路径）</li>
</ul>
</li>
<li><em>集成测试</em>：设计建模
<ul>
<li>自顶向下：使用桩模块测试顶层模块，每次替换一个桩模块</li>
<li>自底向上：可工作的模块进行集成</li>
<li>可选的每日构建</li>
</ul>
</li>
<li><em>确认测试</em>：分析建模</li>
<li><em>系统测试</em>：系统工程</li>
</ul>
<p><em>测试人选</em>：</p>
<ul>
<li><em>开发人员</em>：了解系统，但是会“温和地”进行测试</li>
<li><em>测试人员</em>：必须学习系统，但是会试图摧毁系统</li>
</ul>
<p><em>回归测试</em>：</p>
<ul>
<li>重新运行以及测试过的测试子集，确保变更没有引发非预期的副作用</li>
<li>确保变更（由于测试或者其他原因）不会引入非预期的行为或者增加的错误。</li>
</ul>
<p><em>冒烟</em>：</p>
<ul>
<li>是基于“每日构建”的一种测试方法。</li>
<li>冒烟测试步骤:
<ul>
<li>已经被翻译为代码的软件构件被集成到构造（ “build” ）中。</li>
<li>设计一系列测试来揭示错误，使得此构造不能正确地执行其功能。</li>
<li>将此构造与其他构造集成在一起，每天都对整个产品（以其当前的形式）进行冒烟测试。</li>
</ul>
</li>
</ul>
<p><em>白盒测试</em>：</p>
<ul>
<li>目标是确保所有的语句和条件都至少被执行一次</li>
<li>V(G)：可能的执行路径数量</li>
</ul>
<p><em>黑盒测试</em>：<br>
考虑以下因素：</p>
<ul>
<li>测试功能的有效性</li>
<li>测试系统的行为和性能</li>
<li>哪种类型的输入会产生好的测试用例</li>
<li>系统是否对特定的输入值特别敏感</li>
<li>如何分离数据类的边界</li>
<li>系统能承受什么样的数据速率和数据量</li>
<li>特定类型的数据组合会对系统运行产生什么样的影响</li>
</ul>
<p><em>WebApp测试</em>：</p>
<ul>
<li>测试质量维度
<ul>
<li>用户界面测试</li>
<li>兼容性测试</li>
<li>导航测试</li>
<li>配置测试</li>
</ul>
</li>
</ul>
<h3 id="放在最后"><a class="markdownIt-Anchor" href="#放在最后"></a> 放在最后</h3>
<h4 id="用户体验与可用性"><a class="markdownIt-Anchor" href="#用户体验与可用性"></a> 用户体验与可用性</h4>
<p><em>用户体验的层次</em>（由低到高）：</p>
<ul>
<li>功能性</li>
<li>可用性</li>
<li>吸引力</li>
<li>品牌体验</li>
</ul>
<p><em>设计的层次</em>：</p>
<ul>
<li>直觉设计：软件应有的功能，藉由外观解释产品本身</li>
<li>行为设计：注重表现，产品的使用效率与满意度</li>
<li>思考：产品文化，象征</li>
</ul>
<p><em>可用性的特征和目标</em>：</p>
<ul>
<li>性能（Effectiveness）：能够完成任务</li>
<li>效率（Efficiency）：完成任务的工作量</li>
<li>易学性（Learnability）：用户交互</li>
<li>满意度（Satisfaction）：用户体验</li>
</ul>
<p><em>Persona</em>：</p>
<ul>
<li>定义：虚构的角色，表示不同的用户类型</li>
<li>有助于考虑用户的目标、需求和限制，从而指导产品设计，例如特征、交互、视觉设计</li>
<li>常用于用户中心的设计</li>
<li>目的：
<ul>
<li>帮助设计团队了解目标受众</li>
<li>为用户需求达成共识</li>
<li>帮助设计团队进行设计</li>
</ul>
</li>
</ul>
<p><em>用户中心设计的三个原则</em>：</p>
<ul>
<li>较早地关注用户和任务</li>
<li>产品使用的经验性度量</li>
<li>迭代式设计</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Adamska
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://adamska1008.github.io/2023/01/29/study-notes-software-engineering/" title="软件工程导论笔记">https://adamska1008.github.io/2023/01/29/study-notes-software-engineering/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag"># 软件工程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/01/26/integration-test-in-rust/" rel="prev" title="在Rust中进行集成测试">
                  <i class="fa fa-chevron-left"></i> 在Rust中进行集成测试
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/02/01/some-of-rustlings/" rel="next" title="rustlings选题">
                  rustlings选题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adamska</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js","integrity":"sha256-QdTG1YTLLTwD3b95jLqFxpQX9uYuJMNAtVZgwKX4oYU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha256-gMRN4/6qeELzO1wbFa8qQLU8kfuF2dnAPiUoI0ATjx8=" crossorigin="anonymous">



</body>
</html>
